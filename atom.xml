<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael&#39;s blog</title>
  
  <subtitle>Life-long Learning</subtitle>
  <link href="http://mikelhsia.github.io/atom.xml" rel="self"/>
  
  <link href="http://mikelhsia.github.io/"/>
  <updated>2023-09-03T06:32:48.158Z</updated>
  <id>http://mikelhsia.github.io/</id>
  
  <author>
    <name>Michael Hsia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【How 2】 Upgrade your backtesting arsenal - trading multiple stocks with &quot;backtrader&quot;</title>
    <link href="http://mikelhsia.github.io/2023/08/31/2023-08-31-backtrader-multistocks-backtesting/"/>
    <id>http://mikelhsia.github.io/2023/08/31/2023-08-31-backtrader-multistocks-backtesting/</id>
    <published>2023-08-31T06:29:36.000Z</published>
    <updated>2023-09-03T06:32:48.158Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2023/08/31/2023-08-31-backtrader-multistocks-backtesting/cover.jpeg" class="" width="1000"><p style="text-align:center; color: grey;">  <i>Photo by <a href='https://unsplash.com/@priscilladupreez?utm_source=medium&utm_medium=referral'>Priscilla Du Preez</a> on <a href='https://unsplash.com/?utm_source=medium&utm_medium=referral'>Unsplash</a></i></p><p>Backtrader is a well-known Python open-source library to backtest your quantitative trading strategy. Most of its components can support trading against one single trading target. To step up the game to trade against multiple stocks, there are a few things that need to be fine-tuned to make sure the trading strategy would trade as you expected. In this post, I’m going to share my experience and crucial tips with you as a starting point to build your own.</p><a id="more"></a><hr><p>Become a <a href="https://medium.com/@mikelhsia/membership">Medium member</a> to continue learning without limits. I’ll receive a small portion of your membership fee if you use the following link, at no extra cost to you.</p><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/tags/Interactive-Broker/">【How 2】Set Up Trading API Template In Python</a></li><li><a href="https://mikelhsia.github.io/2021/02/15/2021-02-15-how2-snp500-historic-composition/">【How 2】 Vol. 4. How to produce the S&amp;P 500 Historical Components &amp; Changes</a></li><li><a href="https://mikelhsia.github.io/2020/11/26/2020-11-28-how-to-produce-a-quality-tradable-stock-set-for-backtesting/">【How 2】 Vol. 3. How to produce quality tradable securities for backtesting</a></li></ul><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Backtrader is a well-known Python open-source library that allows you to use it for backtesting, strategy visualization, and live trading. Unfortunately, active development stopped in about 2018 with only a few bug fixes being merged here and there, but it is still considered to be one of the important beginner’s backtesting tools to get familiar with the framework and crucial components in quantitative trading.</p><p>As said, a few things needed to be taken care of to move on to the next phase from trading one single target such as stock, ETF, or bond to trading multiple stocks. I’m going to use one of my trading strategies which trades against stocks that have high IC/IR ratios to demonstrate the differences between before and after the changes. Of course, let me know if you’re interested in knowing this trading strategy. I’ll draft another post if I find out it will help certain people.</p><h2 id="1-How-to-add-data-from-multiple-stocks"><a href="#1-How-to-add-data-from-multiple-stocks" class="headerlink" title="1. How to add data from multiple stocks"></a>1. How to add data from multiple stocks</h2><p>The first thing to trade against multiple stocks is for sure to add data of different symbols into your backtrader <code>cerebro</code>. Below is the method that the official guide suggested to add data to your script:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> backtrader <span class="keyword">as</span> bt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">start_date = datetime.datetime(<span class="number">2022</span>, <span class="number">11</span>, <span class="number">28</span>)</span><br><span class="line">end_date = datetime.datetime(<span class="number">2023</span>, <span class="number">6</span>, <span class="number">12</span>)</span><br><span class="line">cerebro = bt.Cerebro()</span><br><span class="line">df = pd.read_csv(csv_file_path)</span><br><span class="line">data = bt.feeds.PandasData(</span><br><span class="line">    dataname=df,</span><br><span class="line">    fromdate=start_date,</span><br><span class="line">    todate=end_date,</span><br><span class="line">    name=ticker,</span><br><span class="line">    datetime=<span class="number">0</span>,</span><br><span class="line">    close=<span class="number">6</span>,</span><br><span class="line">    high=<span class="number">7</span>,</span><br><span class="line">    low=<span class="number">8</span>,</span><br><span class="line">    open=<span class="number">9</span>,</span><br><span class="line">    volume=<span class="number">10</span>,</span><br><span class="line">    openinterest=<span class="number">-1</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cerebro.adddata(data)</span><br></pre></td></tr></table></figure></p><p style="text-align:center; color: grey;">  <i>Method to add data suggested by the official guide</i></p><p>The way I added multiple symbols data into <code>cerebro</code> is:</p><ol><li>Stitched all the data into one big <code>csv</code> sheet.</li><li>Added <code>date</code> and <code>ticker</code> to remark the date and the symbol name of the data.</li><li>Looped through each ticker and sorted by <code>date</code> to add the data needed</li><li>Added <code>name</code> parameter into the loader function to remark the name of the data</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cerebro = bt.Cerebro()</span><br><span class="line"></span><br><span class="line">results_df = pd.read_csv(csv_file_path)</span><br><span class="line">universe = <span class="comment"># add symbols to</span></span><br><span class="line"><span class="keyword">for</span> ticker <span class="keyword">in</span> results_df[<span class="string">&#x27;ticker&#x27;</span>]:</span><br><span class="line">    tmp = results_df[(results_df[<span class="string">&#x27;ticker&#x27;</span>] == ticker) &amp; (results_df[<span class="string">&#x27;date&#x27;</span>] &lt;= end_date) &amp; (results_df[<span class="string">&#x27;date&#x27;</span>] &gt;= start_date)].sort_values(<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">    df1 = pd.merge(benchmark_framework[<span class="string">&#x27;date&#x27;</span>], tmp, left_on=<span class="string">&#x27;date&#x27;</span>, right_on=<span class="string">&#x27;date&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>).fillna(<span class="number">0</span>)</span><br><span class="line">    data = bt.feeds.PandasDatar(</span><br><span class="line">        dataname=df1,</span><br><span class="line">        fromdate=start_date,</span><br><span class="line">        todate=end_date,</span><br><span class="line">        name=ticker,</span><br><span class="line">        datetime=<span class="number">0</span>,</span><br><span class="line">        close=<span class="number">6</span>,</span><br><span class="line">        high=<span class="number">7</span>,</span><br><span class="line">        low=<span class="number">8</span>,</span><br><span class="line">        open=<span class="number">9</span>,</span><br><span class="line">        volume=<span class="number">10</span>,</span><br><span class="line">        openinterest=<span class="number">-1</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    cerebro.adddata(data)</span><br></pre></td></tr></table></figure><p style="text-align:center; color: grey;">  <i>Method to add data of multiple symbols</i></p><p>There you go!</p><h2 id="2-Wait-What-happens-to-my-plotting-visualization"><a href="#2-Wait-What-happens-to-my-plotting-visualization" class="headerlink" title="2. Wait! What happens to my plotting visualization?"></a>2. Wait! What happens to my plotting visualization?</h2><p>One of the features that backtrader is noted for is its plotting feature together with <code>matplotlib</code> library. This is how you enable this feature in your script:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># After you run cerebro.run()</span></span><br><span class="line">cerebro.plot()</span><br></pre></td></tr></table></figure></p><p style="text-align:center; color: grey;">  <i>How to enable the plotting feature</i></p><p>See! It’s that easy! But the thing is, once you add this line of code into our multiple stocks trading strategy script, it’s going to look like this:</p><img data-src="/2023/08/31/2023-08-31-backtrader-multistocks-backtesting/plot_true.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>The default diagrams when enabling the plotting feature</i></p><p>Obviously, there are too many price data lines that have been plotted in one single diagram. In order to make your diagram to be more readable, there are a few twists to be made:</p><h3 id="2-a-Disable-the-default-data-plotting"><a href="#2-a-Disable-the-default-data-plotting" class="headerlink" title="2.a. Disable the default data plotting"></a>2.a. Disable the default data plotting</h3><p>To do this, you have to disable the default plotting features and build your own plots.</p><p>First, you set the <code>plot</code> parameter in the data loader to <em>False</em>.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data = bt.feeds.PandasDatar(</span><br><span class="line">        dataname=df1,</span><br><span class="line">        fromdate=start_date,</span><br><span class="line">        todate=end_date,</span><br><span class="line">        name=ticker,</span><br><span class="line">        datetime=<span class="number">0</span>,</span><br><span class="line">        close=<span class="number">6</span>,</span><br><span class="line">        high=<span class="number">7</span>,</span><br><span class="line">        low=<span class="number">8</span>,</span><br><span class="line">        open=<span class="number">9</span>,</span><br><span class="line">        volume=<span class="number">10</span>,</span><br><span class="line">        openinterest=<span class="number">-1</span>,</span><br><span class="line">        plot=<span class="literal">False</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p><h3 id="2-b-Disable-the-default-backtesting-plotting"><a href="#2-b-Disable-the-default-backtesting-plotting" class="headerlink" title="2.b. Disable the default backtesting plotting"></a>2.b. Disable the default backtesting plotting</h3><p>Backtrader also embeds a few default plots when you enable the plotting feature. Let’s also disable them for now.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cerebro &#x3D; bt.Cerebro(</span><br><span class="line">    stdstats&#x3D;False,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="2-c-Add-your-customized-plot"><a href="#2-c-Add-your-customized-plot" class="headerlink" title="2.c. Add your customized plot"></a>2.c. Add your customized plot</h3><p>Lastly, the default plot is used to plot the price/value movement of a single stock. We need to transform the diagram into the way want it to be. Let’s add a customized observer to replace the original plot. In this plot, there are going to be two lines plotted: one is our benchmark data which is set to <code>SPY</code>. The second line would be the portfolio value. Here’s how we do this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BenchmarkBroker</span>(<span class="params">bt.Observer</span>):</span></span><br><span class="line">    _stclock = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    alias = (<span class="string">&#x27;Value&#x27;</span>,)</span><br><span class="line">    lines = (<span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;benchmark&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plotinfo = dict(plot=<span class="literal">True</span>, subplot=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.benchmarkFactor = <span class="literal">None</span></span><br><span class="line">        self.i = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;benchmark_symbol&#x27;</span> <span class="keyword">in</span> kwargs.keys():</span><br><span class="line">            self.benchmark_symbol = kwargs[<span class="string">&#x27;benchmark_symbol&#x27;</span>].lower()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.benchmark_symbol = <span class="string">&#x27;spy&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(self.datas):</span><br><span class="line">            <span class="keyword">if</span> data._name == self.benchmark_symbol:</span><br><span class="line">                self.i = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        super(bt.Observer, self).__init__()</span><br><span class="line"></span><br><span class="line">cerebro.addobserver(BenchmarkBroker, benchmark_symbol=<span class="string">&#x27;spy&#x27;</span>)</span><br><span class="line">cerebro.addobserver(</span><br><span class="line">    bt.observers.Benchmark,</span><br><span class="line">    data=benchmark_data,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p style="text-align:center; color: grey;">  <i>Customized observer class to show both portfolio value and benchmark value</i></p><p>In the end, you’ll get the following plot after running your backtest:</p><img data-src="/2023/08/31/2023-08-31-backtrader-multistocks-backtesting/plot_false.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>The final plotting we just built to track the movement of our portfolio value against the benchmark value</i></p><h2 id="3-Hey-The-start-date-and-the-end-date-won’t-match-my-customized-plot"><a href="#3-Hey-The-start-date-and-the-end-date-won’t-match-my-customized-plot" class="headerlink" title="3. Hey! The start date and the end date won’t match my customized plot!"></a>3. Hey! The start date and the end date won’t match my customized plot!</h2><p>I’ve been running backtests over and over again, and this issue bothered me for a long long time. Initially, I suspected it would be the problem of the missing price data as some of the symbols are either delisted or merged by the other corporations. So I tried not to import them into <code>cerebro</code> during the data importing stage. In the end, I found out that it caused the <a href="https://unacademy.com/content/jee/study-material/physics/what-is-forward-bias/"><strong><em>Forward bias</em></strong></a> in the algorithm. Then to eliminate this bias, I digged deeper and found this implicit rule hidden in the <code>backtrader</code> library:</p><ul><li>Scenario 1<ul><li>Data0 starts from 2018-01-02, end at 2018-01-30</li><li>Data1 starts from 2018-01-02, end at 2018-02-07</li><li>The missing stock price in data0 will be filled with the same price as 2018-01-30 throughout 2018-01-31 to 2018-02-07</li></ul></li></ul><img data-src="/2023/08/31/2023-08-31-backtrader-multistocks-backtesting/missing_data_scenario_1.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>Missing data scenario 1</i></p><ul><li>Scenario 2<ul><li>Data0 starts from 2018-01-02, end at 2018-02-07</li><li>Data1 starts from 2018-01-09, end at 2018-02-07</li><li>The data from 2018-01-02 to 2018-01-08 in <strong>Data1</strong> will be discarded because <strong>Data0</strong> data is missing in this period. Therefore, the backtest won’t be performed during this particular period.</li></ul></li></ul><img data-src="/2023/08/31/2023-08-31-backtrader-multistocks-backtesting/missing_data_scenario_2.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>Missing data scenario 2</i></p><p>Apparently, the backtesting period can be limited by the data length of the symbol that has the least data rows. However, we need to make sure that the stocks staying in our trading universe can still be backtested with the participation of the early delisted stocks or the later added stocks, I came up with a trick to pull this off:</p><h3 id="3-a-Use-price-data-of-SPY-to-produce-the-trading-calendar"><a href="#3-a-Use-price-data-of-SPY-to-produce-the-trading-calendar" class="headerlink" title="3.a. Use price data of SPY to produce the trading calendar"></a>3.a. Use price data of SPY to produce the trading calendar</h3><p>The first step would be using SPY to retrieve a series of trading dates. Then we use this trading calendar as the index for the data of every symbol to make sure every symbol shares the same index.</p><h3 id="3-b-Fill-NA"><a href="#3-b-Fill-NA" class="headerlink" title="3.b. Fill NA"></a>3.b. Fill NA</h3><p>After resetting the index for every symbol, there are a lot of empty cells in your pandas dataframe being generated. Then we need to fill a certain value into these empty cells. Which value we should use? In <code>backtrader</code>, using <code>None</code> or <code>NA</code> would cause a lot of problems. Therefore, I choose <code>0</code> to easily identify and process.</p><h3 id="3-c-Add-0-handling-logic-into-your-trading-script"><a href="#3-c-Add-0-handling-logic-into-your-trading-script" class="headerlink" title="3.c. Add 0 handling logic into your trading script"></a>3.c. Add 0 handling logic into your trading script</h3><p>The last step would be adjusting the logic when processing your <code>buy</code>, <code>sell</code>, and <code>close</code> actions. Make sure you don’t place any orders when the price equals <code>0</code>. It’s that easy to resolve this issue.</p><h2 id="4-What-I-don’t-have-enough-money-again-No-way"><a href="#4-What-I-don’t-have-enough-money-again-No-way" class="headerlink" title="4. What? I don’t have enough money again? No way!"></a>4. What? I don’t have enough money again? No way!</h2><p>Once you have all the processes above set, you can start conducting your backtest and filling in your trading strategy. In my case, after I started running my backtest, I saw one prompt message that showed up multiple times and bothered me the most, which was <code>&quot;[ticker] Order rejected due to Margin order status&quot;</code>. I checked here and there to see if there was anything wrong with my trading logic. I’ve made sure that I sell orders first to release the cash first, and then place the buy orders. I’ve also made sure the size of the order won’t exceed my available cash. How in the world that I still get this message all the time?</p><p>I’ve found two main reasons that cause this issue:</p><h3 id="4-a-The-time-to-execute-the-order"><a href="#4-a-The-time-to-execute-the-order" class="headerlink" title="4.a. The time to execute the order"></a>4.a. The time to execute the order</h3><p>To clearly understand the order execution logic of <code>backtrader</code>, let’s refer to the <a href="https://www.backtrader.com/docu/order/">backtrader’s documentation page</a>:</p><blockquote><p>Order.Market: A market order will be executed with the next available price. In backtesting it will be the opening price of the next bar.</p></blockquote><p>So the problem is almost vividly portrayed. The close price of yesterday would potentially have a gap against today’s open price. This rule renders the possibility that the actual cost of placing an order would deviate from the estimated cost higher. In reality, quantitative traders who use daily pricing data to predict the stocks to be bought on the next day would place their orders the next morning, and the estimated cost wouldn’t greatly deviate a lot from the actual cost. So how do we produce an effect that is similar to what is happening in real life?</p><p><strong><em>Cheat On Open</em></strong> is mentioned in the <a href="https://www.backtrader.com/docu/cerebro/cheat-on-open/cheat-on-open/">backtrader’s documentation page</a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cerebro = bt.Cerebro(</span><br><span class="line">    stdstats=<span class="literal">False</span>,</span><br><span class="line">    <span class="comment"># Add the following parameter to enable &quot;cheat_on_open&quot; feature</span></span><br><span class="line">    cheat_on_open=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Enabling the <code>cheat_on_open</code> feature with the parameter above, you’ll gain access to an extra function named <code>next_open</code> which is similar to the timing of entering the market if using only open price to place any of your order.</p><img data-src="/2023/08/31/2023-08-31-backtrader-multistocks-backtesting/backtrader_process.png" class="" width="1000"><p style="text-align:center; color: grey;">  <i>The process after enabling <b>"cheat_on_open"</b> feature</i></p><p>By doing this, you’ll be able to use the open price of the next day to place the buy/sell order, which will greatly decrease the difference in the overnight price gap. This also helps lower the possibility of receiving the  <code>&quot;[ticker] Order rejected due to Margin order status&quot;</code> prompt message.</p><h2 id="4-b-Available-cash-insufficient"><a href="#4-b-Available-cash-insufficient" class="headerlink" title="4.b. Available cash insufficient"></a>4.b. Available cash insufficient</h2><p>There is another scenario that triggers the Margin order state. As the <code>backtrader</code> process displayed above, your orders are usually placed using <strong>for loop</strong> to loop through each symbol in the <code>next</code> or <code>next_open</code> stage. Yet, your orders placed only get executed when you reach the <code>notify_order</code> and <code>notify_store</code> stage. That is to say, your available cash won’t update while you place orders in your <strong>for loop</strong>. If your trading strategy requires you to optimize capital utilization by holding minimum cash, your available cash is very likely to be sufficient to place any buy order even if you try to release your cash by selling your holding stocks.</p><p>To make sure your strategy won’t have any glitches while placing buy and sell orders on the same day, you need to <strong>keep track of your available cash at all times</strong>.</p><h2 id="5-Use-hot-data-over-cold-data"><a href="#5-Use-hot-data-over-cold-data" class="headerlink" title="5. Use hot data over cold data"></a>5. Use hot data over cold data</h2><p>In your trading script, you might need to load a huge pandas dataframe with a lot of columns and factors to support your algorithm. This huge amount of data costs you a lot of time to load into your <code>backtrader</code> script. From my point of view, I would rather complete many backtests as fast as possible. Therefore, I would keep a copy of my data and load it into the trading script as the hot data. In that case, you can save time while loading data into <code>backtrader</code> to be processed a second time.</p><hr><p>These are the things that I found when transforming <code>backtrader</code> into a multiple-stock trading framework. Hope this helps you to build your backtesting tool. Cheers.</p><h1 id="Misc-Source-code"><a href="#Misc-Source-code" class="headerlink" title="Misc - Source code"></a>Misc - Source code</h1><script src="https://gist.github.com/mikelhsia/c92ba87c16200b1b98ac285b2d76f3a2.js"></script>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2023/08/31/2023-08-31-backtrader-multistocks-backtesting/cover.jpeg&quot; class=&quot;&quot; width=&quot;1000&quot;&gt;
&lt;p style=&quot;text-align:center; color: grey;&quot;&gt;
  &lt;i&gt;Photo by &lt;a href=&#39;https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral&#39;&gt;Priscilla Du Preez&lt;/a&gt; on &lt;a href=&#39;https://unsplash.com/?utm_source=medium&amp;utm_medium=referral&#39;&gt;Unsplash&lt;/a&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;Backtrader is a well-known Python open-source library to backtest your quantitative trading strategy. Most of its components can support trading against one single trading target. To step up the game to trade against multiple stocks, there are a few things that need to be fine-tuned to make sure the trading strategy would trade as you expected. In this post, I’m going to share my experience and crucial tips with you as a starting point to build your own.&lt;/p&gt;</summary>
    
    
    
    <category term="Factor Analysis" scheme="http://mikelhsia.github.io/categories/Factor-Analysis/"/>
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Factor-Analysis/Quantitative-Trading/"/>
    
    <category term="How2" scheme="http://mikelhsia.github.io/categories/Factor-Analysis/Quantitative-Trading/How2/"/>
    
    
    <category term="Research" scheme="http://mikelhsia.github.io/tags/Research/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
    <category term="Python3" scheme="http://mikelhsia.github.io/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>【Pair Trading】 Complete Guide to Backtest Cointegration Pair Trading Strategy</title>
    <link href="http://mikelhsia.github.io/2023/04/26/2023-05-01-pair-trading-cointegration-part2/"/>
    <id>http://mikelhsia.github.io/2023/04/26/2023-05-01-pair-trading-cointegration-part2/</id>
    <published>2023-04-26T04:48:46.000Z</published>
    <updated>2023-05-08T13:36:22.987Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/cover.jpeg" class="" width="1000"><p style="text-align:center; color: grey;">  <i>Photo by <a href='https://medium.com/r/?url=https%3A%2F%2Funsplash.com%2F%40aaronburden%3Futm_source%3Dmedium%26utm_medium%3Dreferral'>Aaron Burden</a> on <a href='https://medium.com/r/?url=https%3A%2F%2Funsplash.com%3Futm_source%3Dmedium%26utm_medium%3Dreferral'>Unsplash</a></i></p><p>In the <a href="https://mikelhsia.github.io/2023/02/25/2023-02-25-pair-trading-cointegration-part1/">last post</a>, we learned the basics of performing the pair trading strategy and using cointegration as a method to identify the potential tradable stocks pair. All the theories and the math formulas are so seemingly promising and convincing enough for us to believe it’s a profitable and stable trading strategy. But is it? In order to test and check the profitability and effectiveness of this strategy, we need to backtest this trading strategy to simulate real-world scenarios.</p><a id="more"></a><hr><p>Become a <a href="https://medium.com/@mikelhsia/membership">Medium member</a> to continue learning without limits. I’ll receive a small portion of your membership fee if you use the following link, at no extra cost to you.</p><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2023/02/25/2023-02-25-pair-trading-cointegration-part1/">【Pair Trading】 Cointegration Test - A Key to Find High Probability Trading Strategy</a></li></ul><h1 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h1><p>Let’s pick up where we left off.</p><p>In the <a href="https://mikelhsia.github.io/2023/02/25/2023-02-25-pair-trading-cointegration-part1/">last post</a>, we spent time explaining the basic concepts of cointegration pair trading strategy such as what cointegration means, the meaning of stationary, and how we profit from these concepts. We chose <em><a href="https://mpra.ub.uni-muenchen.de/75967/1/MPRA_paper_75967.pdf">Engle-Granger 2-step approach</a></em> as a method to inspect the level of cointegration between two time series. Once we are able to find the stock pairs that have higher probabilities to stay cointegrated, then we can start monitoring the co-movement of their price and make trades when the pairs are temporarily not cointegrated.</p><p>We’ve also revealed the preliminary trading rules of the cointegration pair trading strategy. We</p><ul><li>Open a long position if the current spread is smaller than the mean of the spread $\mu - threshold * \sigma$</li><li>Close a long position if the current spread is bigger than the mean of the spread $\mu$</li><li>Open a short position if the current spread is bigger than the mean of the spread $\mu + threshold * \sigma$</li><li>Close a short position if the current spread is smaller than the mean of the spread $\mu$</li></ul><p><em>Where</em></p><ul><li>The <strong>mean of the residuals</strong> ($\mu$) as the benchmark line in our residual observation</li><li>The <strong>standard deviation of the residuals</strong> ($\sigma$) to calculate the trigger line in our residual observation</li><li>The <strong>threshold</strong> would be 2.32, indicating a 99% of the confidence level</li></ul><p>Even if we’ve done a lot of research to learn as much as we can about the pair trading method, there are some factors we can’t avoid in real-life settings. As a result, this is where backtesting comes into play. Conducting a successful backtest would mean a lot to simulate what is going to happen if you throw your trading strategy into the wild and unpredictable stock market.</p><h1 id="Build-our-trading-rules"><a href="#Build-our-trading-rules" class="headerlink" title="Build our trading rules"></a>Build our trading rules</h1><p>To conduct a backtest, we first need to set up the ground for this pair trading strategy. Here are a few trading rules that I have put together.</p><p><a id='pair_formation'></a></p><h2 id="Trading-pair-formation"><a href="#Trading-pair-formation" class="headerlink" title="Trading pair formation"></a>Trading pair formation</h2><ol><li>Selecting around 500 stocks based on their company financial fundamental data to find the companies that are stable and relatively financially healthy.</li><li>Obtaining the <strong>daily close price from the past two years</strong> for every stock that we picked</li><li>Using the <code>scipy.stats.pearsonr(Series_A, Series_B)</code> to calculate the <em>Pearson correlation</em>, and chose the stock pairs whose correlation value is bigger than <code>0.9</code> and the p-value is smaller than <code>0.05</code></li><li>Using the <strong>Engle-Granger 2-step approach</strong> to examine every existing pair<ol><li>Using <code>sm.OLS(Series_B as y, Series_A as x).fit()</code> to get the beta, intercept, and residual of each pair</li><li>Using <code>statsmodels.tsa.stattools.adfuller(model.resid, autolag = &#39;BIC&#39;)</code> to evaluate the level of stationary of the residual of this pair</li><li>Eliminating the stock pairs whose cointegration p-value is bigger than <code>0.05</code>, shows the stationary property is less significant.</li></ol></li><li>Lastly, we sort these pairs by their cointegration p-value, <strong>the smaller the better</strong>.</li><li>We repeat this process <strong><em>every month</em></strong> in order to closely follow the cointegration status of the potentially tradable stock pairs.</li></ol><h2 id="Monitoring-and-trading"><a href="#Monitoring-and-trading" class="headerlink" title="Monitoring and trading"></a>Monitoring and trading</h2><p>Since the pairs have been filtered and sorted by their level of correlation and cointegration, we consider these stock pairs to be our <strong>stock pair universe</strong>. As the methodology mentioned in the <a href="https://mikelhsia.github.io/2023/02/25/2023-02-25-pair-trading-cointegration-part1/">previous post</a>, we are already using the data of the past two years to build the upper and lower bands. There are more details to be defined in order to complete our trading strategy.</p><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/epsilon_channel.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>The upper and lower bands built from the residual of the OLS results</i></p><h3 id="Observing-frequency"><a href="#Observing-frequency" class="headerlink" title="Observing frequency"></a>Observing frequency</h3><p>We examine the status of the pairs in our observing universe and the pairs that we already traded for every 15 minutes. Since we’re using the daily close price to form the trading pairs and to trade accordingly, I presume that 15 minutes would be an ideal interval to inspect the status of the pairs.</p><h3 id="Enter-and-exit-signals"><a href="#Enter-and-exit-signals" class="headerlink" title="Enter and exit signals"></a>Enter and exit signals</h3><p>The basic idea of signal generation has been stated in the <strong>Recap</strong> section above, so I won’t waste any of your time and rewrite them here again.</p><h3 id="Stop-loss-and-stop-gain"><a href="#Stop-loss-and-stop-gain" class="headerlink" title="Stop loss and stop gain"></a>Stop loss and stop gain</h3><p>In the post of <a href="https://mikelhsia.github.io/2022/10/21/2022-10-15-meta-label/">【Momentum Trading】Use machine learning to boost your day trading skill - meta-labeling</a>, we have learned the idea of using the <strong>Triple Barrier Method (TBM)</strong> to control our gain/loss ratio. In this pair trading strategy, I’m using <strong>2:1</strong> as our gain/loss ratio. This <strong>2:1</strong> ratio essentially indicates that we will be able to tolerate 50% of our expected gain as our maximum loss per trade. For example, in our trading rules, we will close the pairs for those pairs whose residuals ($\mu$) return to the level of 0, meaning the stop gain would be 2.32 as we exit the trades when the residual is back to the level of 0. Then we define our stop loss to be at the level of <code>2.32 + 2 (2.32 - 0) / 2 = 4.64</code> and exit our trade at it in order to prevent greater loss when both stock prices further deviate.</p><p>As the ground rules have been set up to implement our trading strategy, I’m going to run the first round of backtest to see how it performs and to check the profitability of this strategy.<br><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/trial.png" class="" width="800"></p><p style="text-align:center; color: grey;">  <i>First-round backtest of the pair trading strategy</i></p><p><strong>Wow!</strong> At first glance, the performance was quite impressive and satisfying. However, if we get a closer look, some illogical mistakes hide behind this backtest result. In the bottom chart <code>HeldPositions</code>, the number of long positions and the number of short positions should equal all the time, as we trade pairs including one long stock and one short stock. Therefore, in the red circle, you can tell the number of one side was decreased and the other side wasn’t. This would leave our portfolio exposed to risk as our positions were not hedged properly, increasing the odds to lose money on such an anomaly in our portfolio.</p><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/trial_diagnostic.png" class="" width="800"><p style="text-align:center; color: grey;">  <i>Red circles indicate weird things happened in our trading activities</i></p><h2 id="Several-scenarios-we-need-to-consider-and-address"><a href="#Several-scenarios-we-need-to-consider-and-address" class="headerlink" title="Several scenarios we need to consider and address"></a>Several scenarios we need to consider and address</h2><p>After looking into the log message in the tested backtest, several loopholes can be found and concluded in my trading strategy:<br><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/trial_diagnostic_w_log.png" class="" width="800"></p><p style="text-align:center; color: grey;">  <i>Incorrect trading activities that need to be taken care of properly</i></p><h3 id="Hazard-1-Margin-call"><a href="#Hazard-1-Margin-call" class="headerlink" title="Hazard 1: Margin call"></a>Hazard 1: Margin call</h3><p>According to the trading log message, the first red circle was due to the <strong>margin call</strong> getting executed to recover the remaining margin in your margin account. In order to trade stock options or to short-sell assets, you are required by brokers to retain the investor’s equity above a certain percentage so that you demonstrate your capability to repay the potential loss of your current investment. Once such a loss occurs and your equity falls under this percentage, you will receive this <strong>margin call</strong> notice from the broker that requires you to sell a part of your investment and turn it into cash to raise the percentage of equity.</p><p>In our backtest, the stock price of <code>TSLA</code> has declined drastically which brought the percentage of equity below that percentage, that’s why we were forced to sell any investment and turn it into cash. The point being, that we don’t want to sell <strong>ANY</strong> asset in our portfolio. Instead, we need to make sure we sell <strong>a pair of assets</strong> to remain our market neutrality. In the meantime, we also need to decide which pair to be liquidated that has the least impact on our trading strategy. In the paper <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1330689">An Anatomy of Pairs Trading: The Role of Idiosyncratic News, Common Information and Liquidity</a>, the experiments demonstrate that the probabilities and profitability of the pair start to increase day by day since the deviation has been detected, and then it will start to decline since reaching the top performance on day six. Therefore, I made an assumption that the longer a pair was held, the lower probability for this pair to be profitable. So we need to sell the pair that we hold the longest when the margin call occurs.</p><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/time_impact_profitability.png" class="" width="800"><p style="text-align:center; color: grey;">  <i>The profitability dwindles as the day pass</i></p><h3 id="Hazard-2-Fails-to-place-two-orders-one-long-and-one-short-simultaneously"><a href="#Hazard-2-Fails-to-place-two-orders-one-long-and-one-short-simultaneously" class="headerlink" title="Hazard 2: Fails to place two orders (one long and one short) simultaneously"></a>Hazard 2: Fails to place two orders (one long and one short) simultaneously</h3><p>The other two incidents in our <code>HeldPositions</code> plot are referring to <strong>Insufficient Buying Power</strong>. <strong>Buying power</strong> is a concept that is quite easy to understand but is relatively complex to calculate. According to <a href="https://www.interactivebrokers.co.uk/en/?f=%2Fen%2Fgeneral%2Feducation%2Fpdfnotes%2FWN-UnderstandingIBMargin.php#:~:text=Buying%20Power%20%E2%80%93%20value%20of%20securities,of%20held%20stock%20as%20collateral">Understanding IB Margin Webinar Notes</a>, the buying power can be defined as follow:</p><blockquote><p><strong>Buying Power</strong></p><p>Is the value of securities you can purchase without depositing additional funds. In cash accounts this is the settled cash. In a margin account, buying power is increased through the use of leverage using cash and the value of held stock as collateral. The amount of leverage depends upon whether you have a Reg. T Margin or Portfolio Margin account. Active traders can take advantage of reduced intraday margin for securities – generally 25% of the long stock value. But keep in mind this requirement reverts to the Reg T 50% of stock value to hold overnight.<br>$\text{Cash Account Buying Power} = Min(\text{Equity with Loan Value, Previous Day Equity with Loan Value}) –\text{Initial Margin}$<br>$\text{Margin Account Buying Power} = \text{Cash Account Buying Power} * \text{Leverage Ratio}$</p><p style="text-align:center; color: grey;">  <i>Formulas to calculate the Buying Power</i></p></blockquote><p>Given the buying power as the limitation of placing orders with the margin account, we will face the scenario that one of the orders in the pair is successfully executed but the other order failed to be executed because the buying power of the day is insufficient. Unfortunately, <a href="https://www.quantconnect.com">QuantConnect</a> doesn’t provide a function to check the current buying power in real-time. Therefore, we also need to come up with a solution to remedy this problem.</p><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/fixing_the_issue_of_the_backtest.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>Backtest result after fixing the loopholes found</i></p><p>We have spotted two different potential scenarios that might endanger the profitability of our trading strategy, and we have successfully addressed them in a more theoretically trustworthy method. Looking back to the number of long positions and short positions in the plot <code>HeldPositions</code> are the same at all times. Now we can move on to the last part of the backtest.</p><h1 id="Backtest"><a href="#Backtest" class="headerlink" title="Backtest"></a>Backtest</h1><p>Even if we have successfully replicated the pair trading technique that has been profitable for the past two years, a single backtest cannot guarantee that this backtest will perform similarly in the real world. However, we may employ this backtest as a research tool to determine which parameters could potentially improve the win rate and Sharpe Ratio. This is so-called <strong>Hyperparameter Optimizing</strong>. In this section, I’m going to run backtest against several scenarios to answer the following questions:</p><ol><li>Should we use close price or log(close price) while calculating cointegration parameters and epsilon</li><li>Does the profitability impact by the holding period as stated in <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1330689">An Anatomy of Pairs Trading: The Role of Idiosyncratic News, Common Information and Liquidity</a>?<br>Therefore, I’m going to create <strong>eight</strong> scenarios using <code>price/log(price)</code> and close the pair trade when it’s been <code>10/22/132/264 days</code> indicating we close the trade after it’s 10 days, one month, six months, and one year.</li></ol><p>Furthermore, aside from the standard KPIs such as Total Return, Sharpe Ratio, and MaxDrawDown, other KPIs such as Win Rate will be incorrect because it is based on a single stock and always equals around 50%. Hence I wrote a script to process the order records into a pair-wise order record and visualize the pair-wise performance.</p><h2 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h2><p><a href="https://www.quantconnect.com">QuantConnect</a></p><h2 id="Backtest-Periods"><a href="#Backtest-Periods" class="headerlink" title="Backtest Periods"></a>Backtest Periods</h2><p>2020/12/27 - 2023/03/03</p><h2 id="Backtest-Universe"><a href="#Backtest-Universe" class="headerlink" title="Backtest Universe"></a>Backtest Universe</h2><p>As stated in the section <a href='#pair_formation'>Pair formation</a></p><h2 id="Backtest-benchmark"><a href="#Backtest-benchmark" class="headerlink" title="Backtest benchmark"></a>Backtest benchmark</h2><p>SPDR S&amp;P 500 ETF Trust (SPY)</p><h2 id="Backtest-Results"><a href="#Backtest-Results" class="headerlink" title="Backtest Results"></a>Backtest Results</h2><h3 id="Strategy-wise-performance"><a href="#Strategy-wise-performance" class="headerlink" title="Strategy-wise performance"></a>Strategy-wise performance</h3><div class="table-container"><table><thead><tr><th></th><th>Using close price</th><th>Using log(close price)</th></tr></thead><tbody><tr><td>Close after 10 days</td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/backtest_price_10.png" class="" width="600"></td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/backtest_log_price_10.png" class="" width="600"></td></tr><tr><td>Close after one month</td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/backtest_price_22.png" class="" width="600"></td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/backtest_log_price_22.png" class="" width="600"></td></tr><tr><td>Close after six months</td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/backtest_price_132.png" class="" width="600"></td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/backtest_log_price_132.png" class="" width="600"></td></tr><tr><td>Close after one year</td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/backtest_price_264.png" class="" width="600"></td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/backtest_log_price_264.png" class="" width="600"></td></tr></tbody></table></div><p style="text-align:center; color: grey;">  <i>Strategy-wise performance of every scenario</i></p><p>Once I put the backtest results altogether, it’s quite easy to notice that the performances of the pair trading strategy do conform to the curve as we see above but not exactly following the days in the plot. You can tell that the portfolio returns that close after six months and one year is comparatively lower than the portfolio returns that close after 10 days and one month. The scenarios that have the highest portfolio returns are all closing the trade after <strong>one month</strong>, no matter whether it’s using close price or log(close price).</p><p>On the other hand, the scenarios using close price don’t seem to have an obvious edge compared to the scenarios using log(close price). I guess we need some more parameters involved and more backtests to be performed in order to find out whether the difference exists.</p><h3 id="Pair-wise-performance"><a href="#Pair-wise-performance" class="headerlink" title="Pair-wise performance"></a>Pair-wise performance</h3><p>Before we shift our focus to this part, there are a few types of labels that I need to explain beforehand:</p><ol><li><strong>Normal Close</strong>: This type of order is the order that received the sell signals before hitting the holding period limitation, the same as hitting the vertical time bar of the <strong>Triple Barrier Method (TBM)</strong> (see <a href="https://mikelhsia.github.io/2022/10/21/2022-10-15-meta-label/">here</a> for more details). In the most optimal case, we would like to see the more <strong>Normal Close</strong> orders the better, as they are the orders that follow the central idea of pair trading to produce positive profit via buying when two stock prices deviate and selling when two stock prices start to cointegrate.</li><li><strong>Early Close</strong>: This category represents the orders that are not yet received the sell signals but hit the vertical time bar. The <strong>Early Close</strong> orders are considered as their momentum/energy/tendency to converge are less stronger than they used to be, therefore we close them before they converge in exchange for other pairs that have higher chances to converge. They could be in the money or out of money while we close these <strong>Early Close</strong> orders and have higher uncertainty compared to <strong>normal close</strong> orders. We use <code>+</code> to label this pair trading generate positive profit and <code>-</code> to label this trade’s profit as negative.</li><li><strong>Stop Loss Close</strong>: These orders are closed because their <em>epsilons</em> are getting too big or too small, indicating the prices of the stocks in this pair are starting to further diverge. To avoid a huge loss, we close this type of order before we hit any other bands. We use <code>+</code> to label this pair trading generate positive profit and <code>-</code> to label this trade’s profit as negative.</li></ol><div class="table-container"><table><thead><tr><th></th><th>Using close price</th><th>Using log(close price)</th></tr></thead><tbody><tr><td>Close after 10 days</td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/price_10_dist.png" class="" width="600"></td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/log_price_10_dist.png" class="" width="600"></td></tr><tr><td>Close after one month</td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/price_22_dist.png" class="" width="600"></td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/log_price_22_dist.png" class="" width="600"></td></tr><tr><td>Close after six months</td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/price_132_dist.png" class="" width="600"></td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/log_price_132_dist.png" class="" width="600"></td></tr><tr><td>Close after one year</td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/price_264_dist.png" class="" width="600"></td><td><img data-src="/2023/04/26/2023-05-01-pair-trading-cointegration-part2/log_price_264_dist.png" class="" width="600"></td></tr></tbody></table></div><p style="text-align:center; color: grey;">  <i>Pair-wise performance of every scenario</i></p><p>From the charts above, you can tell that the volume of the <code>Stop Loss orders</code> increases while the holding period increase. That somewhat corroborates the inference stated in the paper <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1330689">An Anatomy of Pairs Trading: The Role of Idiosyncratic News, Common Information and Liquidity</a> that the profits of pair trading do decrease along with the longer holding period. In the meantime, the volume of the <code>Normal Close</code> and <code>Early Close (+)</code> orders remain fairly stable. The full distribution charts above show that the cointegrated pair has a lower probability to diverge once a specific amount of time has passed. The win rate statistics table provided below further back up our conclusion drawn.</p><div class="table-container"><table><thead><tr><th></th><th>Early Close Win Rate</th><th>Total Win Rate</th></tr></thead><tbody><tr><td>price_10_dist</td><td>60.83%</td><td>50.43%</td></tr><tr><td>price_22_dist</td><td>66.67%</td><td>44.13%</td></tr><tr><td>price_132_dist</td><td>50.00%</td><td>38.31%</td></tr><tr><td>price_1264_dist</td><td>N/A</td><td>38.02%</td></tr><tr><td>log_price_10_dist</td><td>61.31%</td><td>51.22%</td></tr><tr><td>log_price_22_dist</td><td>73.63%</td><td>54.95%</td></tr><tr><td>log_price_132_dist</td><td>75.00%</td><td>40.56%</td></tr><tr><td>log_price_1264_dist</td><td>100.00%</td><td>35.33%</td></tr></tbody></table></div><p style="text-align:center; color: grey;">  <i>Pair-wise performance of every scenario II</i></p><h1 id="Take-away"><a href="#Take-away" class="headerlink" title="Take away"></a>Take away</h1><p>In this post, I have shown you how to implement the cointegration pair trading in detail step-by-step. There are two potential defects in our trading strategy that we detected once we release the trading script to the live environment, and theoretical-based and trustworthy solutions have been applied to mitigate the consequences brought by these defects. Lastly, we use this complete backtest to confirm that the profitability of each trading pair does make a difference given using different holding periods to safeguard your strategy from being sabotaged by time volatility. Hope you enjoy reading this post, and let me know if you would like to know any parameter that might impact the performance of the cointegration pair trading strategy, let me know.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1330689">An Anatomy of Pairs Trading: The Role of Idiosyncratic News, Common Information and Liquidity</a></li><li><a href="http://epchan.blogspot.com/2013/11/cointegration-trading-with-log-prices.html">Cointegration Trading with Log Prices vs. Prices</a></li><li><a href="https://ibkr.info/node/2085/">Determining Buying Power</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2023/04/26/2023-05-01-pair-trading-cointegration-part2/cover.jpeg&quot; class=&quot;&quot; width=&quot;1000&quot;&gt;
&lt;p style=&quot;text-align:center; color: grey;&quot;&gt;
  &lt;i&gt;Photo by &lt;a href=&#39;https://medium.com/r/?url=https%3A%2F%2Funsplash.com%2F%40aaronburden%3Futm_source%3Dmedium%26utm_medium%3Dreferral&#39;&gt;Aaron Burden&lt;/a&gt; on &lt;a href=&#39;https://medium.com/r/?url=https%3A%2F%2Funsplash.com%3Futm_source%3Dmedium%26utm_medium%3Dreferral&#39;&gt;Unsplash&lt;/a&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&quot;https://mikelhsia.github.io/2023/02/25/2023-02-25-pair-trading-cointegration-part1/&quot;&gt;last post&lt;/a&gt;, we learned the basics of performing the pair trading strategy and using cointegration as a method to identify the potential tradable stocks pair. All the theories and the math formulas are so seemingly promising and convincing enough for us to believe it’s a profitable and stable trading strategy. But is it? In order to test and check the profitability and effectiveness of this strategy, we need to backtest this trading strategy to simulate real-world scenarios.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
    <category term="Pair Trading" scheme="http://mikelhsia.github.io/tags/Pair-Trading/"/>
    
  </entry>
  
  <entry>
    <title>【Pair Trading】 Cointegration Test - A Key to Find High Probability Trading Strategy</title>
    <link href="http://mikelhsia.github.io/2023/02/25/2023-02-25-pair-trading-cointegration-part1/"/>
    <id>http://mikelhsia.github.io/2023/02/25/2023-02-25-pair-trading-cointegration-part1/</id>
    <published>2023-02-25T05:40:39.000Z</published>
    <updated>2023-03-03T16:51:59.682Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/cover.png" class="" width="600"><p>Cointegration is a statistical technique to find out whether a time series closely follows the movement of the other time series. Therefore, it becomes an important technique in the pair trading strategy for us to determine the right stock pair to trade with. In this post, we’re going to see why traders prefer using the cointegration test over the correlation test in pair trading, and whether the cointegration test results can boost our trading performance.</p><a id="more"></a><hr><p>Become a <a href="https://medium.com/@mikelhsia/membership">Medium member</a> to continue learning without limits. I’ll receive a small portion of your membership fee if you use the following link, at no extra cost to you.</p><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/">【Pair Trading】Part 1. Introduction to pair trading strategy</a></li><li><a href="https://mikelhsia.github.io/2021/08/30/2021-08-30-pair-trading-distance-approach/">【Pair Trading】Part 2. 5 in-depth analysis of distance approach in pair trading</a></li><li><a href="https://mikelhsia.github.io/2021/09/30/2021-10-05-pair-trading-market-neutral/">【Pair Trading】Part 3. The strategy that helps minimize your portfolio risk</a></li></ul><p>From the results of the previous research posts, I’ve found out that the pair trading strategies using the distance approach and Pearson correlation approach are not as satisfying as I expected. Even though we’re able to achieve the goal of making our strategy market neutral and reducing the max drawdown drastically, our Sharpe Ratio of each strategy variation is also reduced to a relatively low level compared to the benchmark buy-and-hold strategy.</p><p>Since the first method in these five pair trading strategies, let’s start putting efforts into the second method and see whether this test can generate more insights to evaluate and then determine whether this is a profitable pair trading strategy.</p><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/methods.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>Extracted from <a href='https://www.youtube.com/watch?v=gd009r7QUuM&list=PLfv9eTYgatm3oz8uq8G17-50ed_s-n5ds&index=2&t=238s'>Pairs Trading: The Distance Approach</a> by <a href='https://www.youtube.com/channel/UC8hI87gt0dmTAIEupEcsckA'>Hudson & Thames</a></i></p><h1 id="1-Lesson-101-of-cointegration-pair-trading"><a href="#1-Lesson-101-of-cointegration-pair-trading" class="headerlink" title="1. Lesson 101 of cointegration pair trading"></a>1. Lesson 101 of cointegration pair trading</h1><h2 id="1-1-What-is-Cointegration"><a href="#1-1-What-is-Cointegration" class="headerlink" title="1.1. What is Cointegration"></a>1.1. What is Cointegration</h2><p>Cointegration describes the relationship between time series in the long run. It is a milestone in the long history of studying multi-asset trading strategies. It first appeared in Granger’s seminal paper “<a href="https://www.sciencedirect.com/science/article/abs/pii/0304407681900798">Some properties of time series data and their use in econometric model specification</a>” <em>(Granger, 1981)</em>. When we put the term cointegration into the words of quantitative trading, cointegration helps us to find whether two stock prices have the spread (usually the difference of price or difference of log(price)) is stationary, indicating the mean and the variance of the spread stays the same in the observation period. This statistic feature meets the criteria of a mean-reversion strategy that involves two indifferent stocks.</p><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/step1.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>The price plot of KEY and RF</i></p><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/step2.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>The price spread between KEY and RF will eventually go back to its mean value</i></p><p>But how do we examine whether the spread of two stock prices is stationary? Statistically speaking, a value in time series can be represented with the following equation:</p><script type="math/tex; mode=display">Y_t = \alpha Y_{t-1} + \beta X_e + constant + \epsilon</script><script type="math/tex; mode=display">or</script><script type="math/tex; mode=display">Y_t = \alpha_1 Y_{t-1} + \alpha_2 Y_{t-2} + ... + \alpha_p Y_{t-p} + constant + \epsilon</script><script type="math/tex; mode=display">\begin{align}&where:\\&Y_t \text{ represents the Y value at time t}\\&\alpha \text{ represents the unit root of this equation}\\&\beta X_t \text{ represents the impact from the previous Y value from t-1 to t-p}\\&\epsilon \text{ represents the residual, which suppose to be a random-distributed value}\end{align}</script><p>By looking at the equation, we can tell that if the unit root $\alpha$ is greater than 1, the $Y_t$ is affected by the previous value $Y_{t-1}, Y_{t-2}, …$ in this time series and is no longer a random-distributed time series. Therefore, our goal is to see whether $\alpha$ exists, the smaller the better. If $\alpha$ doesn’t exist in this equation, then we can say that this time series is stationary as $Y_t$ is simply an add-up of $constant$ and a randomly-distributed $\epsilon$. Here’s where the <strong>Augmented Dickey-Fuller test (ADF test)</strong> comes into play. We use the ADF test to examine whether the unit root exists or not.</p><p>There are a lot of materials here for you if you would like to know more about what cointegration is about:</p><ul><li><a href="https://analyzingalpha.com/stationarity">What is stationary?</a></li><li><a href="https://analyzingalpha.com/check-time-series-stationarity-python">How to check time series stationarity in Python</a></li><li><a href="https://www.youtube.com/watch?v=vvTKjm94Ars">Cointegration - an introduction</a></li></ul><h2 id="1-2-Misconception-about-the-relationship-between-correlation-and-cointegration"><a href="#1-2-Misconception-about-the-relationship-between-correlation-and-cointegration" class="headerlink" title="1.2. Misconception about the relationship between correlation and cointegration"></a>1.2. Misconception about the relationship between correlation and cointegration</h2><p>One might say that, doesn’t the <strong>correlation test</strong> describe the same statistical feature as the <strong><em>cointegration test</em></strong> which both methods are trying to see whether two time series are moving towards the same direction in the same observation period?</p><p>Correlation is meant to examine and measure the linear relationship between two time series. The positive correlation (correlation &gt; 0) means these two variables move in the same direction (up or down) over time, whereas the negative correlation (correlation &lt; 0) means they move in different directions. On the other hand, the cointegration test doesn’t care how these two variables move together. Instead, it measures whether the difference between two variables remains constant over time. Therefore, high cointegration doesn’t necessarily exist if two time series are highly correlated.</p><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/hi_correlation_hi_cointegration.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>Time series that illustrates perfect correlation and cointegration - <a href='https://www.r-bloggers.com/2017/11/cointegration-correlation-and-log-returns/'>Rbloggers</a> by <a href='https://www.r-bloggers.com/author/cfsmith/'>cfsmith</a></i></p><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/low_correlation_hi_cointegration.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>Time series that has perfect cointegration, but zero correlation - <a href='https://www.r-bloggers.com/2017/11/cointegration-correlation-and-log-returns/'>Rbloggers</a> by <a href='https://www.r-bloggers.com/author/cfsmith/'>cfsmith</a></i></p><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/low_correlation_hi_cointegration2.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>Time series has the same perfect cointegration, but has a relatively low correlation - <a href='https://www.r-bloggers.com/2017/11/cointegration-correlation-and-log-returns/'>Rbloggers</a> by <a href='https://www.r-bloggers.com/author/cfsmith/'>cfsmith</a></i></p><p>Reference:</p><ul><li><a href="https://www.r-bloggers.com/2017/11/cointegration-correlation-and-log-returns/">Cointegration, correlation, and log return</a></li></ul><h2 id="1-3-The-methodology"><a href="#1-3-The-methodology" class="headerlink" title="1.3. The methodology"></a>1.3. The methodology</h2><p>In this post, I choose to use <strong>Engle-Granger 2-step approach</strong> as it is the most commonly seen cointegration test process for pair trading. As the name tells, there are two steps to go through in order to find out whether the pair of stocks is suitable for this strategy:</p><h3 id="First-step"><a href="#First-step" class="headerlink" title="First step"></a>First step</h3><p>First of all, we use OLS as the regression method to get the residuals of the equation. The regression formula should look like this given both $x$ and $y$ are time series that we have:</p><script type="math/tex; mode=display">y = \beta * x + constant</script><p>By doing this, we can get the parameters $\beta$ and $constant$. Then we are going to calculate the residuals by using the following equation:</p><script type="math/tex; mode=display">\epsilon = y - \beta * x - constant</script><p>Now we save the residuals as the input of the second step.</p><h3 id="Second-step"><a href="#Second-step" class="headerlink" title="Second step"></a>Second step</h3><p>The second step is much more straightforward. We use the Augmented Dickey-Fuller test to see whether the unit root exists in the residuals. If the hypothesis of having a unit root can be rejected by applying the Augmented Dickey-Fuller test, then we can say that the residuals are stationary and the time series $x$ and $y$ are cointegrated. Therefore, we can say this pair $\text{x-y}$ would be our trading target.</p><p>In python, it’s going to be as easy as:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.tsa.stattools <span class="keyword">import</span> adfuller</span><br><span class="line"></span><br><span class="line">adf_value, p_value= adfuller(TIME_SERIES_X, autolag = <span class="string">&#x27;BIC&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="1-4-Trading-rules"><a href="#1-4-Trading-rules" class="headerlink" title="1.4. Trading rules"></a>1.4. Trading rules</h2><p>Theoretically speaking, the OLS-generated residuals should conform to the random distribution. That is to say, the cointegration pair trading strategy essentially is a mean-reverting, market-neutral, long-short strategy as the other pair trading strategy. The only difference is what would be the indicator to monitor and observe. In this case, we use the residual $\epsilon$ to generate the trading signals to either enter or exit a trade. Below is the most common trading rules performed in most of the research papers:</p><ul><li>Variables required<ul><li><strong>Residuals ($\epsilon$)</strong> generated from the OLS regression: $\epsilon = y - \beta * x - constant$</li><li><strong>Mean of the residuals ($\mu$)</strong> as the benchmark line in our residual observation</li><li><strong>Standard deviation of the residuals ($\sigma$)</strong> to calculate the trigger line in our residual observation</li><li><strong>Threshold</strong> is a fixed value that uses together with the standard deviation of the residuals to calculate the trigger line. In this research, we set it to 2.32 for calculating the upper bound and -2.32 for calculating the lower bound. (2.32 is usually used as it includes 99% inside the normal distribution)</li></ul></li><li>Trading rules<ul><li>Generating enter trading signals<ul><li>Open a long position if the current spread is smaller than the mean of the spread $\mu - threshold * \sigma$</li><li>Close a long position if the current spread is bigger than the mean of the spread $\mu$</li><li>Open a short position if the current spread is bigger than the mean of the spread $\mu + threshold * \sigma$</li><li>Close a short position if the current spread is smaller than the mean of the spread $\mu$</li></ul></li><li>Exit trading signals<ul><li>residual cross the mean of the residuals</li></ul></li><li>Repeated trading signals<ul><li>Only process the first signal if there are two consecutive enter/exit signals</li></ul></li></ul></li></ul><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/trading_rules.png" class="" width="800"><p style="text-align:center; color: grey;">    <i>Pair trading rules flow chart</i></p><p>To make our trading rules more intuitively easier to understand, let’s have a look at the below chart:</p><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/intuitive_visualization.png" class="" width="800"><p style="text-align:center; color: grey;">    <i>Top: Pair pricing movements; Middle: Residual movement; Bottom: Accumulative return (%)</i></p><h1 id="2-Research-plan"><a href="#2-Research-plan" class="headerlink" title="2. Research plan"></a>2. Research plan</h1><h2 id="2-1-Goal-of-this-research"><a href="#2-1-Goal-of-this-research" class="headerlink" title="2.1. Goal of this research"></a>2.1. Goal of this research</h2><p>Before starting to backtest the strategy performance, there are a few things that I would like to understand beforehand. Therefore, I set up three sets of scenarios to validate the answers to the below questions:</p><ol><li>When doing regression, whether stock price or log(price) will give us an edge?</li><li>Do we need to filter out those pairs whose correlation is low before the cointegration test?</li><li>Does the scenario using the pair in the same industries will have a lot of difference in performance compared to the scenario using the pair in different industries?</li></ol><p>I believe having a clear view of the above questions will help conduct backtest in the later stage. So let’s get started!</p><h2 id="2-2-Platform"><a href="#2-2-Platform" class="headerlink" title="2.2. Platform"></a>2.2. Platform</h2><p><a href="https://www.quantconnect.com">QuantConnect</a></p><h2 id="2-3-Fetching-data-needed"><a href="#2-3-Fetching-data-needed" class="headerlink" title="2.3. Fetching data needed"></a>2.3. Fetching data needed</h2><p>In this research, we use 24 months of data as training data and feed them into the ADF test and OLS regression to get the results forming the pairs we need for the following steps. Once the pairs have formed, we’re going to use another 12 months of data as testing data to see whether the pairs with high cointegration intention would have the character of mean-reversion.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">formation_period = <span class="number">22</span> * <span class="number">24</span></span><br><span class="line">trading_period = <span class="number">22</span> * <span class="number">12</span></span><br><span class="line">data_length = formation_period + trading_period</span><br><span class="line"></span><br><span class="line">history_price = qb.History(universe, data_length+<span class="number">1</span>, Resolution.Daily)</span><br><span class="line">history_price = history_price.reset_index().pivot(index=<span class="string">&#x27;time&#x27;</span>, columns=<span class="string">&#x27;symbol&#x27;</span>, values=<span class="string">&#x27;close&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&#x27;There are <span class="subst">&#123;history_price.shape[<span class="number">1</span>]&#125;</span> in the symbols&#x27;</span>)</span><br><span class="line"></span><br><span class="line">training_data = history_price.iloc[:formation_period, :]</span><br><span class="line">trading_data = history_price.iloc[formation_period:, :]</span><br></pre></td></tr></table></figure><h2 id="2-4-Universe-and-implementation"><a href="#2-4-Universe-and-implementation" class="headerlink" title="2.4. Universe and implementation"></a>2.4. Universe and implementation</h2><p>I’m using the component stocks from S&amp;P500 at one point as the base universe to start with. After downloading all the historic pricing data, I fed the necessary data into the following class to build the screening criteria:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, symbol_a:str, symbol_b:str, rtn_a, rtn_b</span>):</span></span><br><span class="line">        self.symbol_a = symbol_a</span><br><span class="line">        self.symbol_b = symbol_b</span><br><span class="line">        self.rtn_a = np.array(rtn_a)</span><br><span class="line">        self.rtn_b = np.array(rtn_b)</span><br><span class="line">        self.corr, self.corr_p = self.correlation()</span><br><span class="line">        self.ols_hedge_ratio, self.ols_intercept, self.coint_value, self.coint_stationary_p, self.ols_res = self.cointeration_test()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">correlation</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># calculate the sum of squared deviations between two normalized price series</span></span><br><span class="line">        corr, p = pearsonr(self.rtn_a, self.rtn_b)</span><br><span class="line">        <span class="keyword">return</span> corr, p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cointeration_test</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = self.rtn_a</span><br><span class="line">        y = self.rtn_b</span><br><span class="line"></span><br><span class="line">        x = sm.add_constant(x)</span><br><span class="line">        model = sm.OLS(y, x).fit()</span><br><span class="line"></span><br><span class="line">        intercept = model.params[<span class="number">0</span>]</span><br><span class="line">        beta = model.params[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        adf_result = adfuller(model.resid, autolag = <span class="string">&#x27;BIC&#x27;</span>)</span><br><span class="line">        adf_value = adf_result[<span class="number">0</span>]</span><br><span class="line">        stationary_p_value = adf_result[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beta, intercept, adf_value, stationary_p_value, model.resid</span><br></pre></td></tr></table></figure></p><p>Then here’s how I feed the data into this defined class:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is for storing the final results</span></span><br><span class="line">pair_corrs = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> stock_pair <span class="keyword">in</span> tqdm.tqdm(symbol_pairs):</span><br><span class="line">  <span class="keyword">if</span> str(stock_pair[<span class="number">0</span>]) <span class="keyword">not</span> <span class="keyword">in</span> history_price.columns:</span><br><span class="line">    <span class="comment"># print(f&#x27;&#123;str(stock_pair[0])&#125; not in the history_price table&#x27;)</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  <span class="keyword">if</span> str(stock_pair[<span class="number">1</span>]) <span class="keyword">not</span> <span class="keyword">in</span> history_price.columns:</span><br><span class="line">    <span class="comment"># print(f&#x27;&#123;str(stock_pair[1])&#125; not in the history_price table&#x27;)</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> SPREAD_MODE == LOG_PRICE_MODE:</span><br><span class="line">    tmp = np.log(training_data.loc[:, [str(stock_pair[<span class="number">0</span>]), str(stock_pair[<span class="number">1</span>])]].dropna())</span><br><span class="line">  <span class="keyword">elif</span> SPREAD_MODE == PRICE_MODE:</span><br><span class="line">    tmp = training_data.loc[:, [str(stock_pair[<span class="number">0</span>]), str(stock_pair[<span class="number">1</span>])]].dropna()</span><br><span class="line"></span><br><span class="line">  pair_corrs[(str(stock_pair[<span class="number">0</span>]), str(stock_pair[<span class="number">1</span>]))] = Pair(</span><br><span class="line">    str(stock_pair[<span class="number">0</span>]),</span><br><span class="line">    str(stock_pair[<span class="number">1</span>]),</span><br><span class="line">    tmp.loc[:, str(stock_pair[<span class="number">0</span>])],</span><br><span class="line">    tmp.loc[:, str(stock_pair[<span class="number">1</span>])]</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><br>Once the above actions have been accomplished, I’m choosing only the pairs whose ADF test p-value is smaller than 0.05 to be our candidates for pair trading:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_pairs = &#123;key:value <span class="keyword">for</span> key, value <span class="keyword">in</span> pair_corrs.items() <span class="keyword">if</span> value.coint_stationary_p &lt;= <span class="number">0.05</span>&#125;</span><br></pre></td></tr></table></figure></p><p>Lastly, let’s sort the pairs first by their correlation value and then by their cointegration p-value. By doing this, it’ll be easier for us to conduct our stratified analysis based on their level of cointegration.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final_pairs = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> sorted(</span><br><span class="line">  final_pairs.items(),</span><br><span class="line">  key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>].corr</span><br><span class="line">)&#125;</span><br><span class="line">final_pairs = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> sorted(</span><br><span class="line">  final_pairs.items(),</span><br><span class="line">  key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>].coint_stationary_p</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-Results"><a href="#2-5-Results" class="headerlink" title="2.5. Results"></a>2.5. Results</h2><p>To better visualize our results, I’m going to <strong>compare different scenarios simply based on the visualized diagram using stratified analysis and accumulative return diagram from the top 20 stock pairs that have the lowest ADF test p-value</strong>. In the stratified analysis, I expect to see if the accumulative returns of each group are parted from each other and are ranked from group 1 (the lowest cointegration p-value) to group 8 (the highest cointegration p-value). As for the accumulative return diagram from the <strong>top 20</strong> stock pairs, undoubtedly seeing a soaring return without a huge max drawdown would be the optimal result.</p><h3 id="2-5-1-Using-simply-stock-price-v-s-log-stock-price"><a href="#2-5-1-Using-simply-stock-price-v-s-log-stock-price" class="headerlink" title="2.5.1. Using simply stock price v.s. log(stock price)"></a>2.5.1. Using simply stock price v.s. log(stock price)</h3><p>In the blog post <strong><em><a href="http://epchan.blogspot.com/2013/11/cointegration-trading-with-log-prices.html">Cointegration Trading with Log Prices vs. Prices</a></em></strong> by Dr. Ernest P. Chen, the difference between using price and using log price has been stated clearly:</p><blockquote><p>For most cointegrating pairs that I have studied, both the price spreads and the log price spreads are stationary, so it doesn’t matter which one we use for our trading strategy. However, for an unusual pair where its log price spread cointegrates but price spread does not (Hat tip: Adam G. for drawing my attention to one such example), the implication is quite significant.</p><div style="text-align: right"> <i>- Ernest P. Chen</i></div></blockquote><p>Therefore, it would be interesting to see how this impact the entire strategy return.</p><div class="table-container"><table><thead><tr><th></th><th>Price</th><th>log(Price)</th></tr></thead><tbody><tr><td>Industry pairs without correlation filter</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_w_ind_wo_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_w_ind_wo_corr_1.png" class="" width="600"></td></tr><tr><td>Non-industry pairs without correlation filter</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_wo_ind_wo_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_wo_ind_wo_corr_1.png" class="" width="600"></td></tr><tr><td>Industry pairs with correlation filter</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_w_ind_w_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_w_ind_w_corr_1.png" class="" width="600"></td></tr><tr><td>Non-industry pairs with correlation filter</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_wo_ind_w_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_wo_ind_w_corr_1.png" class="" width="600"></td></tr></tbody></table></div><p>The scenarios using <strong>log(price)</strong> don’t seem to have distinct differences from the scenarios using <strong>price</strong>. So we can’t say for sure that whether using <strong>price</strong> or <strong>log(price)</strong> is superior.</p><h3 id="2-5-2-Filter-by-correlation-cointegration-v-s-filter-by-cointegration"><a href="#2-5-2-Filter-by-correlation-cointegration-v-s-filter-by-cointegration" class="headerlink" title="2.5.2. Filter by correlation + cointegration v.s. filter by cointegration"></a>2.5.2. Filter by correlation + cointegration v.s. filter by cointegration</h3><p>In this second research, I would like to know whether a high correlation has any positive impact on this trading strategy. The way I run this research is that, in addition to the already-have cointegration p-value filter, I add another filter to eliminate the pairs where the correlation value is under 0.9 and the p-value is greater than 0.05. Then, we do everything the same as the previous research.</p><div class="table-container"><table><thead><tr><th></th><th>with correlation filter</th><th>without correlation filter</th></tr></thead><tbody><tr><td>Industry pairs with price</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_w_ind_w_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_w_ind_wo_corr_1.png" class="" width="600"></td></tr><tr><td>Non-industry pairs with log(price)</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_wo_ind_w_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_wo_ind_wo_corr_1.png" class="" width="600"></td></tr><tr><td>Industry pairs with log(price)</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_w_ind_w_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_w_ind_wo_corr_1.png" class="" width="600"></td></tr><tr><td>Non-industry pairs with price</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_wo_ind_w_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_wo_ind_wo_corr_1.png" class="" width="600"></td></tr></tbody></table></div><p>Somehow it seems that the scenarios without the correlation filter are always better performed than the corresponding scenarios with the correlation filter. This might give us a clue that maybe the correlation filter is not needed.</p><h3 id="2-5-3-Construct-pairs-within-the-same-industries-or-across-different-industries"><a href="#2-5-3-Construct-pairs-within-the-same-industries-or-across-different-industries" class="headerlink" title="2.5.3. Construct pairs within the same industries or across different industries"></a>2.5.3. Construct pairs within the same industries or across different industries</h3><p>As we all know that the stock prices of companies in the same industry tend to be impacted simultaneously by the economic or industrial incidence, which we can deduce that companies in the same industry could have higher cointegration relationships than companies in different industries. Is this true? And how will it impact our pair trading strategy? I construct the trading pairs in two different ways: 1. we make all possible combinations using the native python function <code>itertools.combinations()</code>. 2. we only make possible combinations when two companies are in the same industry.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pairs = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create pairs only when two companies are in the same industry</span></span><br><span class="line">INDUSTRY_PAIR_FLAG = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> INDUSTRY_PAIR_FLAG:</span><br><span class="line">    time = datetime.now()</span><br><span class="line">    sector = &#123;x: y.iloc[<span class="number">-1</span>][<span class="number">-1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> universe <span class="keyword">if</span> <span class="keyword">not</span> (y:=qb.GetFundamental(x, <span class="string">&quot;AssetClassification.MorningstarSectorCode&quot;</span>, time - timedelta(days=<span class="number">3</span>), time)).empty&#125;</span><br><span class="line">    sectors_table = pd.DataFrame.from_dict(sector, orient=<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">    sectors_set = set(sectors_table.squeeze().values.tolist())</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> sectors_set:</span><br><span class="line">        sector_list = sectors_table[sectors_table.squeeze() == s].index.tolist()</span><br><span class="line">        pairs.extend(list(it.combinations(sector_list, <span class="number">2</span>)))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    pairs = list(it.combinations(universe, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&#x27;The <span class="subst">&#123;len(pairs)=&#125;</span> in the symbols_pairs&#x27;</span>)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>Pairing within the same industry</th><th>Pairing across different industry</th></tr></thead><tbody><tr><td>Price with correlation filter</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_w_ind_w_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_wo_ind_w_corr_1.png" class="" width="600"></td></tr><tr><td>Price without correlation filter</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_w_ind_wo_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/price_wo_ind_wo_corr_1.png" class="" width="600"></td></tr><tr><td>log(price) with correlation filter</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_w_ind_w_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_wo_ind_w_corr_1.png" class="" width="600"></td></tr><tr><td>log(price) without correlation filter</td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_w_ind_wo_corr_1.png" class="" width="600"></td><td><img data-src="/2023/02/25/2023-02-25-pair-trading-cointegration-part1/logprice_wo_ind_wo_corr_1.png" class="" width="600"></td></tr></tbody></table></div><p>Same to previous research results, the first group returns in scenarios that form pairs across different industries seem always better than the ones in scenarios pairing within the same industry. That might tell us the cointegration relationship also exists across industries.</p><h1 id="3-Conclusion"><a href="#3-Conclusion" class="headerlink" title="3. Conclusion"></a>3. Conclusion</h1><p>From the research above, we have gained some insights regarding how each factor impacts the performance of the pair trading strategy. But, are we able to answer the three questions we mentioned above with 100% confidence? No. There are more details that we need to take into account when conducting the backtest, such as:</p><ul><li>Update the universe periodically by recalculating the cointegration p-value of all the pairs.</li><li>Use a smaller threshold to generate trading signals as the smaller entry point and exit will get a shorter holding period and more round trip trades and generally higher profits.</li><li>Use <a href="https://www.investopedia.com/terms/z/zscore.asp#:~:text=Investopedia%20%2F%20Tara%20Anand-,What%20Is%20Z%2DScore%3F,identical%20to%20the%20mean%20score.">z-score</a> method to smooth the $\epsilon$ that we’re tracking.</li><li>Close early if the trades were opened for too long.</li><li>Add a stop-loss threshold to prevent losing more if the $\epsilon$ goes way beyond the threshold.</li><li>…</li></ul><p>A lot of techniques can be experimented with and tested during backtesting. In the next episode, I’m going to work on the backtest and see whether there’s a possibility that we can find a profitable cointegration trading strategy.</p><p>Cheers!</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2023/02/25/2023-02-25-pair-trading-cointegration-part1/cover.png&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p&gt;Cointegration is a statistical technique to find out whether a time series closely follows the movement of the other time series. Therefore, it becomes an important technique in the pair trading strategy for us to determine the right stock pair to trade with. In this post, we’re going to see why traders prefer using the cointegration test over the correlation test in pair trading, and whether the cointegration test results can boost our trading performance.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Research" scheme="http://mikelhsia.github.io/tags/Research/"/>
    
    <category term="Pair Trading" scheme="http://mikelhsia.github.io/tags/Pair-Trading/"/>
    
  </entry>
  
  <entry>
    <title>【How 2】 Set Up Trading API Template In Python - Q&amp;A</title>
    <link href="http://mikelhsia.github.io/2022/12/15/2022-12-17-IBKR-broker-4/"/>
    <id>http://mikelhsia.github.io/2022/12/15/2022-12-17-IBKR-broker-4/</id>
    <published>2022-12-15T07:30:52.000Z</published>
    <updated>2023-03-03T16:52:06.336Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/12/15/2022-12-17-IBKR-broker-4/cover.png" class="" width="800"><p>In the last post in this series, we’re going to look at some questions that I discovered while working on connecting to Interactive Broker API. Some of them are due to the obscurity of the configuration and hard to find the right place to configure them, and some of them would need the extra tool to resolve. I put all of them down into one post and share it with you.</p><a id="more"></a><hr><p>Become a <a href="https://medium.com/@mikelhsia/membership">Medium member</a> to continue learning without limits. I’ll receive a small portion of your membership fee if you use the following link, at no extra cost to you.</p><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">【Momentum Trading】A Defense Trading Strategy That Works - CPPI (Constant Proportion Portfolio Insurance)</a></li><li><a href="https://mikelhsia.github.io/2022/12/12/2022-12-10-IBKR-Broker/">【How 2】 Set Up Trading API Template In Python - Connecting My Trading Strategies To Interactive Brokers</a></li><li><a href="https://mikelhsia.github.io/2022/12/12/2022-12-16-IBKR-broker-2/">【How 2】 Set Up Trading API Template In Python - Placing Orders with Interactive Broker</a></li><li><a href="https://mikelhsia.github.io/2022/12/14/2022-12-17-IBKR-broker-3/">【How 2】 Set Up Trading API Template In Python - Build Local Storage For Storing Trades</a></li></ul><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="1-When-I’m-using-apscheduler-and-ib-insync-at-the-same-time-there-are-errors-and-I-can’t-get-my-trading-script-to-work"><a href="#1-When-I’m-using-apscheduler-and-ib-insync-at-the-same-time-there-are-errors-and-I-can’t-get-my-trading-script-to-work" class="headerlink" title="1. When I’m using apscheduler and ib_insync at the same time, there are errors and I can’t get my trading script to work"></a>1. When I’m using apscheduler and ib_insync at the same time, there are errors and I can’t get my trading script to work</h2><p><a href="https://apscheduler.readthedocs.io/en/3.x/"><code>Apscheduler</code></a> is the standard package in my quantitative trading setup. It’s a python library that helps you schedule your python code/function to be run at a specific DateTime or regular intervals with consideration of timezone. I gotta recommend this library to those traders/developers who have similar requirements in their trading scripts.</p><p>However, both <code>apscheduler</code> and <code>ib_insync</code> packages use the design of multi-threading in their package. If you include both of them, you’ll run into a problem and find a <code>RuntimeError</code> occurred when you try to run your script. Fortunately, <code>ib_insync</code> package includes this functionality to enable nested threading.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: There <span class="keyword">is</span> no current event loop <span class="keyword">in</span> thread <span class="string">&#x27;ThreadPoolExecutor-0_0&#x27;</span>.</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>RuntimeError saying there is no current event loop</i></p><p>And all you have to do is to:</p><ol><li>Call <code>ib_insync.util.patchAsyncio()</code> after you import <code>ib_insync</code> library.</li><li>Use <code>AsyncIOScheduler</code> to create your scheduler.</li><li>Add <code>async</code> before the scheduled function definition.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ibkr_api.py</span></span><br><span class="line"><span class="keyword">import</span> ib_insync</span><br><span class="line">ib_insync.util.patchAsyncio()</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.asyncio <span class="keyword">import</span> AsyncIOScheduler</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">  print(datetime.datetime.now().strftime(’%Y-%m-%d-%H_%M_%S’))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  scheduler = AsyncIOScheduler()</span><br><span class="line"></span><br><span class="line">  scheduler.add_job(</span><br><span class="line">    test,</span><br><span class="line">    <span class="string">&#x27;cron&#x27;</span>,</span><br><span class="line">    day_of_week=<span class="string">&#x27;mon-fri&#x27;</span>,</span><br><span class="line">    hour=<span class="number">9</span>,</span><br><span class="line">    minute=<span class="number">10</span>,</span><br><span class="line">    timezone=ZoneInfo(<span class="string">&#x27;US/Easter&#x27;</span>),</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Apscheduler + ib_insync code snippet</i></p><p>By making the above changes, the <code>apscheduler</code> and <code>ib_insync</code> can coexist in the same script.</p><blockquote><p><em>Note: There are things that could still go wrong as using the nested threads are relatively complicated.</em><br>Reference: <a href="https://groups.io/g/insync/topic/using_ib_insync_with/7866651">Using ib-insync with APScheduler</a></p></blockquote><h2 id="2-Why-I-can’t-get-a-valid-stock-price-back-by-using-reqMktData"><a href="#2-Why-I-can’t-get-a-valid-stock-price-back-by-using-reqMktData" class="headerlink" title="2. Why I can’t get a valid stock price back by using reqMktData?"></a>2. Why I can’t get a valid stock price back by using reqMktData?</h2><p>There are several steps and restrictions for requesting stock prices using <code>reqMktData()</code> function:</p><ol><li>Before requesting a market quote, you need to subscribe to the market data on the IBKR platform. You can find the management page in the TWS or IB gateway tab <em>“Account” -&gt; “Manage Account” -&gt; “Subscribe Market Data/Research”</em>.</li><li>The <code>ib.reqMarketDataType(N)</code> is to specify what kind of data type you would like to request. For example, if you request market data type = 1 (live market data) outside the trading hour, you won’t be able to receive any valid pricing data from the server. Therefore choose the market data type carefully, and test and explore their limitation.</li><li>As said in the previous post, this entire querying of pricing data is an asynchronous process, meaning you could run into the situation that you’re accessing the pricing data while your script is still trying to fetch the data from the server. Therefore, remember to use <code>ib.sleep()</code> wisely to ensure you only access the pricing data when the pricing data is returned.</li></ol><blockquote><p>Reference: <a href="https://mikelhsia.github.io/2022/12/12/2022-12-16-IBKR-broker-2/">【How 2】 Set Up Trading API Template In Python - Placing orders with Interactive Brokers</a></p></blockquote><h2 id="3-There-are-popup-windows-that-prevent-me-from-placing-orders-using-API-What-happened"><a href="#3-There-are-popup-windows-that-prevent-me-from-placing-orders-using-API-What-happened" class="headerlink" title="3. There are popup windows that prevent me from placing orders using API. What happened?"></a>3. There are popup windows that prevent me from placing orders using API. What happened?</h2><p>Inside the TWS and the IB gateway, there are pre-configured conditions that prevent API consumers to place an unintended order. If you accidentally place an order that falls outside of the size or value range, or if the current market data is lagged and hasn’t been updated for a long time, then the TWS/IB gateway will pop up a warning window to tell you that there is a potential hazard to place such an order.</p><p>To prevent this from happening and stop your trading script, you can check the box in <em>API -&gt; Precautions -&gt; “Bypass Order Precaution for API Order”</em> to prevent the warning dialog boxes from popping up when you place orders through API. Yet, you have to bare the risk of unexpected loss when your script goes wrong.</p><img data-src="/2022/12/15/2022-12-17-IBKR-broker-4/order_precaution.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Check this checkbox to prevent the warning appears when placing orders via API</i></p><blockquote><p>Reference: <a href="https://guides.interactivebrokers.com/tws/usersguidebook/configuretws/apiprecautions.htm">API Precautions</a></p></blockquote><h2 id="4-How-could-I-reset-my-paper-account"><a href="#4-How-could-I-reset-my-paper-account" class="headerlink" title="4. How could I reset my paper account?"></a>4. How could I reset my paper account?</h2><p>Whenever you feel like starting a new test from a clean slate, you can always reset your paper account. However, the setting is quite hard to find. You have to log in to your paper account on the IBKR website, and then follow the below steps to reset your paper account.</p><img data-src="/2022/12/15/2022-12-17-IBKR-broker-4/step1.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>How to reset your paper account 1</i></p><img data-src="/2022/12/15/2022-12-17-IBKR-broker-4/step2.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>How to reset your paper account 2</i></p><img data-src="/2022/12/15/2022-12-17-IBKR-broker-4/step3.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>How to reset your paper account 3</i></p><h2 id="5-There-are-times-that-my-TWS-or-IB-gateway-won’t-successfully-auto-reconnect-What-should-I-do"><a href="#5-There-are-times-that-my-TWS-or-IB-gateway-won’t-successfully-auto-reconnect-What-should-I-do" class="headerlink" title="5. There are times that my TWS or IB gateway won’t successfully auto-reconnect. What should I do?"></a>5. There are times that my TWS or IB gateway won’t successfully auto-reconnect. What should I do?</h2><p>TWS and IB gateway are two very important intermediaries to relay the API instructions from your local trading script to the remote IBKR API server. However, there is a hidden mechanism inside TWS and IB gateway applications. These two applications need to restart every day and will automatically reconnect, and require human intervention to log in again every seven days. Therefore, there are two scenarios that we need to address:</p><ol><li><strong>Q:</strong> How do we keep the connection with IBKR after the software applications have auto-reconnected?<ul><li><strong>A:</strong> Avoid using the long connection as possible. Disconnect your <code>IB()</code> instance as long as the required actions are done, and reconnect to the server when new actions are needed.</li></ul></li><li><strong>Q:</strong> What if there’s an error occurred while software applications are rebooting?<ul><li><strong>A:</strong> As the software applications are run locally on your desktop or laptop, meaning this type of software crash is not monitored by any script or process. One possible solution is to wrap the headless software application inside docker. You can download the docker image of “ib-gateway-docker” from <a href="https://github.com/UnusualAlpha/ib-gateway-docker">here</a> and run this docker container on your local machine so that the process can be protected and monitored by the daemon inside the docker container.</li></ul></li></ol><blockquote><p>Reference:<a href="https://github.com/UnusualAlpha/ib-gateway-docker">IB gateway docker</a></p></blockquote><h2 id="6-What-to-do-with-2-factor-authentication-when-trading-using-a-real-account"><a href="#6-What-to-do-with-2-factor-authentication-when-trading-using-a-real-account" class="headerlink" title="6. What to do with 2-factor authentication when trading using a real account?"></a>6. What to do with 2-factor authentication when trading using a real account?</h2><p>Since Interactive Brokers adopts two-factor authentication for logging in and buying/selling stocks, it essentially means that working with Interactive Brokers API won’t be fully automated (See <a href="https://ibkr.info/article/2260">here</a> and <a href="https://ibkr.info/article/2879">here</a>). Every time you place a random order or log in to your TWS/IB gateway application, you will receive a message on your smartphone to confirm your corresponding action once more “<strong>manually</strong>“. Here are two posts that could give you a rough idea of how to work with this two-factor authentication system:</p><ul><li><a href="https://groups.io/g/insync/topic/81744821#6060">live trading and two-factor authentication</a></li><li><a href="https://groups.io/g/insync/topic/95475509#8603">Watchdog with 2fa</a></li></ul><p>There could be a possibility in the future to have a workaround to bypass this system. Currently, having your smartphone with you during trading hours would seem to be the most promising method.</p><hr><p>This is the last post in this <strong><em>Set-Up Trading API Template In Python</em></strong> series. I hope you enjoy reading these and let me know if there is any other topic you would like to read.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/12/15/2022-12-17-IBKR-broker-4/cover.png&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;p&gt;In the last post in this series, we’re going to look at some questions that I discovered while working on connecting to Interactive Broker API. Some of them are due to the obscurity of the configuration and hard to find the right place to configure them, and some of them would need the extra tool to resolve. I put all of them down into one post and share it with you.&lt;/p&gt;</summary>
    
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/categories/How2/"/>
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/How2/Quantitative-Trading/"/>
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/tags/How2/"/>
    
    <category term="Interactive Broker" scheme="http://mikelhsia.github.io/tags/Interactive-Broker/"/>
    
  </entry>
  
  <entry>
    <title>【How 2】 Set Up Trading API Template In Python - Build Local Storage For Storing Trades</title>
    <link href="http://mikelhsia.github.io/2022/12/14/2022-12-17-IBKR-broker-3/"/>
    <id>http://mikelhsia.github.io/2022/12/14/2022-12-17-IBKR-broker-3/</id>
    <published>2022-12-13T17:42:02.000Z</published>
    <updated>2022-12-15T07:12:01.091Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/12/14/2022-12-17-IBKR-broker-3/cover.png" class="" width="800"><p>Now we come to the third part of this series. In this post, I’m going to show you how I design and build my local database to store IBKR trades and other necessary information for generating meaningful indicators to review our strategy performance.</p><a id="more"></a><hr><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">【Momentum Trading】A Defense Trading Strategy That Works - CPPI (Constant Proportion Portfolio Insurance)</a></li><li><a href="https://mikelhsia.github.io/2022/12/12/2022-12-10-IBKR-Broker/">【How 2】 Set Up Trading API Template In Python - Connecting My Trading Strategies To Interactive Brokers</a></li><li><a href="https://mikelhsia.github.io/2022/12/12/2022-12-16-IBKR-broker-2/">【How 2】 Set Up Trading API Template In Python - Placing Orders with Interactive Broker</a></li></ul><h1 id="Why-do-we-need-to-build-this-capability-ourselves"><a href="#Why-do-we-need-to-build-this-capability-ourselves" class="headerlink" title="Why do we need to build this capability ourselves?"></a>Why do we need to build this capability ourselves?</h1><p>We have most of our functions ready in our previous two posts except the <code>def get_transaction()</code> function. Most of the brokers would provide the function to retrieve historic transactions for at least 60 days. However, Interactive Brokers doesn’t support the functionality to retrieve the historic trades and portfolio performance from it. The reason I want this function supported is that I need to:</p><ol><li>Use the historic portfolio performance to compare with the benchmark evaluating KPIs and see whether my trading strategy is successful or not.</li><li>In the <a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">CPPI strategy</a> we talked about before, the B and E ratio calculation depends on the previous day’s maximum portfolio value. Therefore we need to persist it so that we won’t lose it every time we restart our trading script.</li><li>I would like to take the impact of the commission into account. Since Interactive Brokers won’t save my trading records any longer, I would need to save those trading records on my local DB so that I get to keep track of the commission spent on this strategy.</li></ol><p>To address the requirements that I put together above, building a database on the local machine is imperative. Below, I’m going to put down my solution into two sections:</p><ul><li>Design DB schema</li><li>Implement DB-related capabilities</li></ul><p>Also, in terms of which DB should be used here, SQL such as MySql or NoSQL like MongoDB will be too complicated and way too powerful. Therefore, I simply pick <code>sqlite3</code> to create easy-to-use local storage.</p><h1 id="Design-DB-schema"><a href="#Design-DB-schema" class="headerlink" title="Design DB schema"></a>Design DB schema</h1><p>We are going to create three tables, and each of them is going to address the requirements that we raised above respectively.</p><ul><li>IB_SQLITE_CPPI_TBL_NAME<ul><li>The only critical variable here is the <code>MAX_ASSET</code>. This is a value to keep track of the max portfolio value and calculate the CPPI E_ratio and B_ratio. If you want to know why we need this variable tracked in the data table, you can check out <a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">this post</a></li></ul></li><li>IB_SQLITE_TRANSACTION_TBL_NAME<ul><li>This table is basically recording the daily performance of our portfolio and market benchmark. We have <code>PORTFOLIO_CLOSE_VALUE</code>, <code>SPY_CLOSE_PRICE</code>, and <code>COMMISSION</code>, where the commission is a sum added up from the <strong>IB_SQLITE_ORDER_TBL_NAME</strong>.</li></ul></li><li>IB_SQLITE_ORDER_TBL_NAME<ul><li>This table is meant to record all the orders placed. I extracted the following information from the <code>ib.trades()</code> response and tuck them into the table: <code>symbol</code>, <code>order_id</code>, <code>action</code> (buy or sell), <code>quantity</code>, <code>order status</code>, <code>commission cost</code>, and the <code>account number</code>.</li></ul></li></ul><img data-src="/2022/12/14/2022-12-17-IBKR-broker-3/db_schema.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>DB schema of three tables</i></p><h1 id="Implement-DB-related-capabilities"><a href="#Implement-DB-related-capabilities" class="headerlink" title="Implement DB-related capabilities"></a>Implement DB-related capabilities</h1><img data-src="/2022/12/14/2022-12-17-IBKR-broker-3/db_helper_functions.png" class="" width="600"><p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Private and public functions for managing our DB</i></p><br>Here I separated the functions into two groups. The first part of functions is the private functions that conduct database operations such as connecting to the database, creating the table, checking whether the table exists or not, and so on. This provides the minimum capability for managing the database. The second part of the functions is public functions that use private functions to interact with the specified data table in the database.</p><p>Below are the private sqlite3 DB functions:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="comment"># Sqlite3 private functions</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqlite_connect</span>(<span class="params">self</span>):</span></span><br><span class="line">    dirs = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        db_path = os.path.join(dirs, IB_SQLITE_DB_NAME)</span><br><span class="line">        conn = sqlite3.connect(db_path)</span><br><span class="line">        print(<span class="string">f&#x27;Sqlite connection established&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> conn</span><br><span class="line">        conn.close()</span><br><span class="line">        print(<span class="string">f&#x27;Sqlite connection closed&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">f&#x27;We are having an OS error&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sqlite_create_table</span>(<span class="params">self, conn=None, tbl_name=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tbl_name <span class="keyword">or</span> <span class="keyword">not</span> conn:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tbl_name == IB_SQLITE_TRANSACTION_TBL_NAME:</span><br><span class="line">        conn.execute(<span class="string">f&#x27;&#x27;&#x27;CREATE TABLE <span class="subst">&#123;IB_SQLITE_TRANSACTION_TBL_NAME&#125;</span></span></span><br><span class="line"><span class="string">            (ID INTEGER PRIMARY KEY AUTOINCREMENT,</span></span><br><span class="line"><span class="string">            CREATE_TIME DATETIME NOT NULL,</span></span><br><span class="line"><span class="string">            PORTFOLIO_CLOSE_VALUE FLOAT NOT NULL,</span></span><br><span class="line"><span class="string">            SPY_CLOSE_PRICE FLOAT NOT NULL,</span></span><br><span class="line"><span class="string">            COMMISSION FLOAT NOT NULL);</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> tbl_name == IB_SQLITE_CPPI_TBL_NAME:</span><br><span class="line">        conn.execute(<span class="string">f&#x27;&#x27;&#x27;CREATE TABLE <span class="subst">&#123;IB_SQLITE_CPPI_TBL_NAME&#125;</span></span></span><br><span class="line"><span class="string">            (ID INTEGER PRIMARY KEY AUTOINCREMENT,</span></span><br><span class="line"><span class="string">            CREATE_TIME DATETIME NOT NULL,</span></span><br><span class="line"><span class="string">            MAX_ASSET FLOAT NOT NULL,</span></span><br><span class="line"><span class="string">            E_RATIO FLOAT NOT NULL,</span></span><br><span class="line"><span class="string">            B_RATIO FLOAT NOT NULL);</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> tbl_name == IB_SQLITE_ORDER_TBL_NAME:</span><br><span class="line">        conn.execute(<span class="string">f&#x27;&#x27;&#x27;CREATE TABLE <span class="subst">&#123;IB_SQLITE_ORDER_TBL_NAME&#125;</span></span></span><br><span class="line"><span class="string">            (ID INTEGER PRIMARY KEY AUTOINCREMENT,</span></span><br><span class="line"><span class="string">            CREATE_TIME DATETIME NOT NULL,</span></span><br><span class="line"><span class="string">            SYMBOL TEXT NOT NULL,</span></span><br><span class="line"><span class="string">            ORDER_ID TEXT NOT NULL UNIQUE,</span></span><br><span class="line"><span class="string">            ACTION TEXT NOT NULL,</span></span><br><span class="line"><span class="string">            QUANTITY INT NOT NULL,</span></span><br><span class="line"><span class="string">            ORDER_STATUS TEXT NOT NULL,</span></span><br><span class="line"><span class="string">            COMMISSION FLOAT NOT NULL,</span></span><br><span class="line"><span class="string">            ACCOUNT TEXT NOT NULL);</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sqlite_is_table_exist</span>(<span class="params">self, conn=None, tbl_name=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tbl_name <span class="keyword">or</span> <span class="keyword">not</span> conn:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    c = conn.cursor()</span><br><span class="line"></span><br><span class="line">    c.execute(<span class="string">f&#x27;&#x27;&#x27;SELECT count(name)</span></span><br><span class="line"><span class="string">        FROM sqlite_master</span></span><br><span class="line"><span class="string">        WHERE type=&quot;table&quot; AND name=&quot;<span class="subst">&#123;tbl_name&#125;</span>&quot;;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.fetchone()[<span class="number">0</span>]==<span class="number">1</span> :</span><br><span class="line">        <span class="comment"># Table exists</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="comment"># Table does not exist</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sqlite_query_data</span>(<span class="params">self, conn=None, tbl_name=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> conn <span class="keyword">or</span> <span class="keyword">not</span> tbl_name:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.__sqlite_is_table_exist(conn, tbl_name):</span><br><span class="line">        self.__sqlite_create_table(conn, tbl_name)</span><br><span class="line"></span><br><span class="line">    df = pd.read_sql_query(<span class="string">f&#x27;SELECT * from <span class="subst">&#123;tbl_name&#125;</span>;&#x27;</span>, conn)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sqlite_insert_record</span>(<span class="params">self, conn=None, sql=None, value_tuple: tuple=None, tbl_name=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.__sqlite_is_table_exist(conn, tbl_name):</span><br><span class="line">        self.__sqlite_create_table(conn, tbl_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sql:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f&#x27;SQL string is empty&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    conn.execute(sql, value_tuple)</span><br><span class="line"></span><br><span class="line">    conn.commit()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><p>As for the public functions in our script, they provide support for our trading script so that it can achieve the purpose we want it to.</p><p>First of all, these two functions are for us to retrieve data from the corresponding data table and return in <code>pd.DataFrame()</code> format.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_transactions</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        df = self.__sqlite_query_data(conn, IB_SQLITE_TRANSACTION_TBL_NAME)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cppi_variables</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        df = self.__sqlite_query_data(conn, IB_SQLITE_CPPI_TBL_NAME)</span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure></p><p>Secondly, we created three functions for handling parsing the corresponding API responses into the data format we need. Therefore, this part of the functions involves interacting with the Interactive Brokers API, fetching data from sqlite3 local database, and processing the data accordingly.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_orders_in_db</span>(<span class="params">self</span>):</span></span><br><span class="line">    sql = <span class="string">f&#x27;&#x27;&#x27;INSERT OR IGNORE INTO <span class="subst">&#123;IB_SQLITE_ORDER_TBL_NAME&#125;</span> (CREATE_TIME, SYMBOL, ORDER_ID, ACTION, QUANTITY, ORDER_STATUS, COMMISSION, ACCOUNT) VALUES (?, ?, ?, ?, ?, ?, ?, ?);&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        trades = self.client.trades()</span><br><span class="line">        <span class="keyword">for</span> trade <span class="keyword">in</span> trades:</span><br><span class="line">            perm_id = trade.order.permId</span><br><span class="line">            qty = trade.order.filledQuantity</span><br><span class="line">            symbol = trade.contract.symbol</span><br><span class="line">            action = trade.order.action</span><br><span class="line">            commission = sum([fill.commissionReport.commission <span class="keyword">for</span> fill <span class="keyword">in</span> trade.fills])</span><br><span class="line">            status = trade.orderStatus.status</span><br><span class="line">            exec_time = trade.log[<span class="number">0</span>].time</span><br><span class="line">            account = trade.order.account</span><br><span class="line">            self.__sqlite_insert_record(</span><br><span class="line">                conn,</span><br><span class="line">                sql,</span><br><span class="line">                (exec_time, symbol, perm_id, action, qty, status, commission, account),</span><br><span class="line">                IB_SQLITE_ORDER_TBL_NAME</span><br><span class="line">            )</span><br><span class="line">    logger.logger.debug(<span class="string">f&#x27;Database <span class="subst">&#123;IB_SQLITE_ORDER_TBL_NAME&#125;</span> updated&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_transactions_in_db</span>(<span class="params">self</span>):</span></span><br><span class="line">    sql = <span class="string">f&#x27;&#x27;&#x27;INSERT OR IGNORE INTO <span class="subst">&#123;IB_SQLITE_TRANSACTION_TBL_NAME&#125;</span> (CREATE_TIME, PORTFOLIO_CLOSE_VALUE, SPY_CLOSE_PRICE, COMMISSION) VALUES (?,?,?,?);&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Portfolio value</span></span><br><span class="line">    portfolio_value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> self.accounts:</span><br><span class="line">        data = self.client.accountValues(account)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;TotalCashBalance&#x27;</span>, <span class="string">&#x27;StockMarketValue&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                portfolio_value += float(row.value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SPY close value</span></span><br><span class="line">    benchmark_value = self.get_last_price_from_quote(<span class="string">&#x27;SPY&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update the latest commission</span></span><br><span class="line">    commission = self.get_commission_from_db(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        self.__sqlite_insert_record(</span><br><span class="line">            conn,</span><br><span class="line">            sql,</span><br><span class="line">            (datetime.now(), portfolio_value, benchmark_value, commission),</span><br><span class="line">            IB_SQLITE_TRANSACTION_TBL_NAME</span><br><span class="line">        )</span><br><span class="line">    logger.logger.debug(<span class="string">f&#x27;Database <span class="subst">&#123;IB_SQLITE_TRANSACTION_TBL_NAME&#125;</span> updated&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_cppi_variables_in_db</span>(<span class="params">self, max_asset, E, B</span>):</span></span><br><span class="line">    sql = <span class="string">f&#x27;&#x27;&#x27;INSERT OR IGNORE INTO <span class="subst">&#123;IB_SQLITE_CPPI_TBL_NAME&#125;</span> (CREATE_TIME, MAX_ASSET, E_RATIO, B_RATIO) VALUES (?,?,?,?);&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        self.__sqlite_insert_record(</span><br><span class="line">            conn,</span><br><span class="line">            sql,</span><br><span class="line">            (datetime.now(), max_asset, E, B),</span><br><span class="line">            IB_SQLITE_CPPI_TBL_NAME</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><p>Lastly, this is the function to achieve the goal for me to calculate the commission sum on the day (or for multiple days).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_commission_from_db</span>(<span class="params">self, time_delta:int=<span class="number">0</span></span>) -&gt; float:</span></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        df = self.__sqlite_query_data(conn, IB_SQLITE_ORDER_TBL_NAME)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df.empty:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> df[(datetime.now(self.timezone) - pd.to_datetime(df[<span class="string">&#x27;CREATE_TIME&#x27;</span>], utc=<span class="literal">False</span>)) &lt; timedelta(days=time_delta)][<span class="string">&#x27;COMMISSION&#x27;</span>].sum()</span><br></pre></td></tr></table></figure><h1 id="My-strategy-report-card"><a href="#My-strategy-report-card" class="headerlink" title="My strategy report card"></a>My strategy report card</h1><p>In the last part of this post, I’ll show you the portfolio performance metrics that I plan using to evaluate the trading strategy with the data stored in our local database. You can also modify the DB schema, record the information you need, and come up with important and helpful for you to evaluate the effectiveness of your trading script.</p><ol><li>Sharpe Ratio (SR)</li><li>Total return</li><li>Annualized return</li><li>Variance</li><li>Max Drawdown (MDD)</li><li>Trading fee spent</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_strategy_report</span>(<span class="params">self, config=None, verbose=False</span>):</span></span><br><span class="line">    final = self.get_transactions()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        print(final)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tmp.empty:</span><br><span class="line">        ret_data[<span class="string">&#x27;Version&#x27;</span>] = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">        ret_data[<span class="string">&#x27;SR/Portfolio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;SR/Benchmark&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Total Return/Portfolio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Total Return/Benchmark&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Annualized Return/Portfolio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Annualized Return/Benchmark&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Variance/Portfolio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Variance/Benchmark&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;MDD/Portfolio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;MDD/Benchmark&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Trading fee&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Trading fee ratio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ret_data[<span class="string">&#x27;Version&#x27;</span>] = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">        ret_data[<span class="string">&#x27;SR/Portfolio&#x27;</span>] = tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>].mean() / tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>].std()</span><br><span class="line">        ret_data[<span class="string">&#x27;SR/Benchmark&#x27;</span>] = tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>].mean() / tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>].std()</span><br><span class="line">        ret_data[<span class="string">&#x27;Total Return/Portfolio&#x27;</span>] = (tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>].iloc[<span class="number">-1</span>] / c[<span class="string">&#x27;init_cash&#x27;</span>]) - <span class="number">1</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Total Return/Benchmark&#x27;</span>] = (tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>].iloc[<span class="number">-1</span>] / tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>].iloc[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Annualized Return/Portfolio&#x27;</span>] = (<span class="number">1</span> + ret_data[<span class="string">&#x27;Total Return/Portfolio&#x27;</span>])**(<span class="number">365</span>/(datetime.today() - pd.to_datetime(c[<span class="string">&#x27;start_date&#x27;</span>])).days) - <span class="number">1</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Annualized Return/Benchmark&#x27;</span>] = (<span class="number">1</span> + ret_data[<span class="string">&#x27;Total Return/Benchmark&#x27;</span>])**(<span class="number">365</span>/(datetime.today() - pd.to_datetime(c[<span class="string">&#x27;start_date&#x27;</span>])).days) - <span class="number">1</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Variance/Portfolio&#x27;</span>] = tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>].var()</span><br><span class="line">        ret_data[<span class="string">&#x27;Variance/Benchmark&#x27;</span>] = tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>].var()</span><br><span class="line">        ret_data[<span class="string">&#x27;MDD/Portfolio&#x27;</span>] = self.__calculate_mdd(tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>])</span><br><span class="line">        ret_data[<span class="string">&#x27;MDD/Benchmark&#x27;</span>] = self.__calculate_mdd(tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>])</span><br><span class="line">        ret_data[<span class="string">&#x27;Trading fee&#x27;</span>] = tmp.loc[:, <span class="string">&#x27;COMMISSION&#x27;</span>].sum()</span><br><span class="line">        ret_data[<span class="string">&#x27;Trading fee ratio&#x27;</span>] = ret_data[<span class="string">&#x27;Trading fee&#x27;</span>] / tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>].iloc[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret_data</span><br></pre></td></tr></table></figure><hr><p>That’s it! I know it’s a bit too much code and too little talk in this post, but a good trading strategy should always include a performance evaluation to know whether this strategy is still in effect. This is the last bit of what I built in my API template so I hope it would help people who want to build their own API templates.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/12/14/2022-12-17-IBKR-broker-3/cover.png&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;p&gt;Now we come to the third part of this series. In this post, I’m going to show you how I design and build my local database to store IBKR trades and other necessary information for generating meaningful indicators to review our strategy performance.&lt;/p&gt;</summary>
    
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/categories/How2/"/>
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/How2/Quantitative-Trading/"/>
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/tags/How2/"/>
    
    <category term="Python3" scheme="http://mikelhsia.github.io/tags/Python3/"/>
    
    <category term="Interactive Broker" scheme="http://mikelhsia.github.io/tags/Interactive-Broker/"/>
    
    <category term="Sqlite3" scheme="http://mikelhsia.github.io/tags/Sqlite3/"/>
    
  </entry>
  
  <entry>
    <title>【How 2】 Set Up Trading API Template In Python - Placing orders with Interactive Brokers</title>
    <link href="http://mikelhsia.github.io/2022/12/12/2022-12-16-IBKR-broker-2/"/>
    <id>http://mikelhsia.github.io/2022/12/12/2022-12-16-IBKR-broker-2/</id>
    <published>2022-12-12T03:11:24.000Z</published>
    <updated>2022-12-15T07:05:45.858Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/12/12/2022-12-16-IBKR-broker-2/cover.png" class="" width="800"><p>This is the second part of the <a href="https://mikelhsia.github.io/2022/12/12/2022-12-10-IBKR-Broker/"><strong>Set Up Trading API Template In Python</strong></a>. We’re going to focus on implementing the rest of the functions in our Interactive Broker class.</p><a id="more"></a><hr><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">【Momentum Trading】A Defense Trading Strategy That Works - CPPI (Constant Proportion Portfolio Insurance)</a></li><li><a href="https://mikelhsia.github.io/2022/12/12/2022-12-10-IBKR-Broker/">【How 2】Set Up Trading API Template In Python - Connecting My Trading Strategies To Interactive Brokers</a></li></ul><h1 id="Recap-and-what’s-the-next"><a href="#Recap-and-what’s-the-next" class="headerlink" title="Recap and what’s the next"></a>Recap and what’s the next</h1><p>In the previous post, we get to know how our trading script sends API calls to the IBKR API service via the IB gateway. Also, we have learned how to configure the IB gateway application. Lastly, we also showcase the code snippet to get the available cash balance and the total investment market value under your account from the server. Now, we’ll look at the rest of the functions in our <code>InteractiveBrokerTradeAPI</code> class.</p><ul><li>Get a much more detailed status report with get_account_detail</li><li>Fetch the market calendar</li><li>How to create a valid order for Interactive Broker</li></ul><h1 id="API-document-reference"><a href="#API-document-reference" class="headerlink" title="API document reference"></a>API document reference</h1><p><a href="https://ib-insync.readthedocs.io/api.html"><code>ib_insync</code></a></p><h1 id="Get-a-deep-dive-status-report-with-get-account-detail"><a href="#Get-a-deep-dive-status-report-with-get-account-detail" class="headerlink" title="Get a deep dive status report with get_account_detail"></a>Get a deep dive status report with get_account_detail</h1><p>The <code>get_account_detail()</code> in our earlier example has successfully extracted the <code>TotalCashBalance</code> and <code>StockMarketValue</code> from the <code>ib.accountValues()</code> response. Yet, if we would like to know more about our portfolio status, we can include two more calls to obtain more information about our portfolio: 1. positions in our portfolio, 2. the orders that we placed in the past 24 hours.</p><p>For 1., we use <code>ib.portfolio()</code> to acquire information on the stocks we hold. We will extract the position size and the market value of each symbol, thus gaining a bigger picture of how our portfolio looks like.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[PortfolioItem(contract=Stock(conId=<span class="number">42454579</span>, symbol=<span class="string">&#x27;SHV&#x27;</span>, right=<span class="string">&#x27;0&#x27;</span>, primaryExchange=<span class="string">&#x27;NASDAQ&#x27;</span>, currency=<span class="string">&#x27;USD&#x27;</span>, localSymbol=<span class="string">&#x27;SHV&#x27;</span>, tradingClass=<span class="string">&#x27;NMS&#x27;</span>), position=<span class="number">427.0</span>, marketPrice=<span class="number">109.9701004</span>, marketValue=<span class="number">46957.23</span>, averageCost=<span class="number">109.98463535</span>, unrealizedPNL=<span class="number">-6.21</span>, realizedPNL=<span class="number">0.0</span>, account=<span class="string">&#x27;DU4399668&#x27;</span>),</span><br><span class="line"> PortfolioItem(contract=Stock(conId=<span class="number">39622943</span>, symbol=<span class="string">&#x27;SSO&#x27;</span>, right=<span class="string">&#x27;0&#x27;</span>, primaryExchange=<span class="string">&#x27;ARCA&#x27;</span>, currency=<span class="string">&#x27;USD&#x27;</span>, localSymbol=<span class="string">&#x27;SSO&#x27;</span>, tradingClass=<span class="string">&#x27;SSO&#x27;</span>), position=<span class="number">1060.0</span>, marketPrice=<span class="number">47.5340004</span>, marketValue=<span class="number">50386.04</span>, averageCost=<span class="number">48.7388397</span>, unrealizedPNL=<span class="number">-1277.13</span>, realizedPNL=<span class="number">-62.91</span>, account=<span class="string">&#x27;DU4399668&#x27;</span>)]</span><br></pre></td></tr></table></figure></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Response from <b>ib.portfolio()</b> call</i></p><p>As for 2., we use <code>ib.trades()</code> to obtain the trades we made in the past 24 hours. Remember, the Interactive broker holds this information for only 24 hours or so, and you won’t be able to retrieve this piece once the server drops this information. Therefore, we will find a way to address this in another post to persist the order-related information. In the below Trade objects, we extract the information we need such as order id, average price, order status, commission cost, and so on for each symbol.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Trade(contract=Stock(conId=<span class="number">42454579</span>, symbol=<span class="string">&#x27;SHV&#x27;</span>, right=<span class="string">&#x27;?&#x27;</span>, exchange=<span class="string">&#x27;SMART&#x27;</span>, currency=<span class="string">&#x27;USD&#x27;</span>, localSymbol=<span class="string">&#x27;SHV&#x27;</span>, tradingClass=<span class="string">&#x27;NMS&#x27;</span>), order=Order(permId=<span class="number">423185966</span>, action=<span class="string">&#x27;SELL&#x27;</span>, orderType=<span class="string">&#x27;MKT&#x27;</span>, lmtPrice=<span class="number">0.0</span>, auxPrice=<span class="number">0.0</span>, tif=<span class="string">&#x27;DAY&#x27;</span>, ocaType=<span class="number">3</span>, displaySize=<span class="number">2147483647</span>, rule80A=<span class="string">&#x27;0&#x27;</span>, openClose=<span class="string">&#x27;&#x27;</span>, volatilityType=<span class="number">0</span>, deltaNeutralOrderType=<span class="string">&#x27;None&#x27;</span>, referencePriceType=<span class="number">0</span>, account=<span class="string">&#x27;DU4399668&#x27;</span>, clearingIntent=<span class="string">&#x27;IB&#x27;</span>, cashQty=<span class="number">0.0</span>, dontUseAutoPriceForHedge=True, filledQuantity=<span class="number">1.0</span>, refFuturesConId=<span class="number">2147483647</span>, shareholder=<span class="string">&#x27;Not an insider or substantial shareholder&#x27;</span>), orderStatus=OrderStatus(orderId=<span class="number">0</span>, status=<span class="string">&#x27;Filled&#x27;</span>, filled=<span class="number">0.0</span>, remaining=<span class="number">0.0</span>, avgFillPrice=<span class="number">0.0</span>, permId=<span class="number">0</span>, parentId=<span class="number">0</span>, lastFillPrice=<span class="number">0.0</span>, clientId=<span class="number">0</span>, whyHeld=<span class="string">&#x27;&#x27;</span>, mktCapPrice=<span class="number">0.0</span>), fills=[Fill(contract=Stock(conId=<span class="number">42454579</span>, symbol=<span class="string">&#x27;SHV&#x27;</span>, right=<span class="string">&#x27;?&#x27;</span>, exchange=<span class="string">&#x27;SMART&#x27;</span>, currency=<span class="string">&#x27;USD&#x27;</span>, localSymbol=<span class="string">&#x27;SHV&#x27;</span>, tradingClass=<span class="string">&#x27;NMS&#x27;</span>), execution=Execution(execId=<span class="string">&#x27;00025b49.63971bea.01.01&#x27;</span>, time=datetime.datetime(<span class="number">2022</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">38</span>, tzinfo=datetime.timezone.utc), acctNumber=<span class="string">&#x27;DU4399668&#x27;</span>, exchange=<span class="string">&#x27;EDGEA&#x27;</span>, side=<span class="string">&#x27;SLD&#x27;</span>, shares=<span class="number">1.0</span>, price=<span class="number">109.97</span>, permId=<span class="number">423185966</span>, clientId=<span class="number">0</span>, orderId=<span class="number">0</span>, liquidation=<span class="number">0</span>, cumQty=<span class="number">1.0</span>, avgPrice=<span class="number">109.97</span>, orderRef=<span class="string">&#x27;&#x27;</span>, evRule=<span class="string">&#x27;&#x27;</span>, evMultiplier=<span class="number">0.0</span>, modelCode=<span class="string">&#x27;&#x27;</span>, lastLiquidity=<span class="number">2</span>), commissionReport=CommissionReport(execId=<span class="string">&#x27;00025b49.63971bea.01.01&#x27;</span>, commission=<span class="number">1.002648</span>, currency=<span class="string">&#x27;USD&#x27;</span>, realizedPNL=<span class="number">-1.017284</span>, yield_=<span class="number">0.0</span>, yieldRedemptionDate=<span class="number">0</span>), time=datetime.datetime(<span class="number">2022</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">38</span>, tzinfo=datetime.timezone.utc))], log=[TradeLogEntry(time=datetime.datetime(<span class="number">2022</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">38</span>, tzinfo=datetime.timezone.utc), status=<span class="string">&#x27;Filled&#x27;</span>, message=<span class="string">&#x27;Fill 1.0@109.97&#x27;</span>, errorCode=<span class="number">0</span>)], advancedError=<span class="string">&#x27;&#x27;</span>)]</span><br></pre></td></tr></table></figure></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Response from <b>ib.trades()</b> call</i></p><p>Combining everything we talked about above, we can construct our <code>get_account_detail()</code> function as below:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_account_detail</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.accounts = self.client.managedAccounts()</span><br><span class="line"></span><br><span class="line">    acc_data = []</span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> self.accounts:</span><br><span class="line">        acc = &#123;&#125;</span><br><span class="line">        acc[<span class="string">&#x27;account&#x27;</span>] = account</span><br><span class="line">        data = self.client.accountValues(account)</span><br><span class="line">        acc[<span class="string">&#x27;cash&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        acc[<span class="string">&#x27;total_assets&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;TotalCashBalance&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                acc[<span class="string">&#x27;cash&#x27;</span>] = row.value</span><br><span class="line">                acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">            <span class="keyword">elif</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;StockMarketValue&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">        acc_data.append(acc)</span><br><span class="line"></span><br><span class="line">    pos_data = []</span><br><span class="line">    data = self.client.portfolio()</span><br><span class="line">    <span class="keyword">for</span> position <span class="keyword">in</span> data:</span><br><span class="line">        pos = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        pos[<span class="string">&#x27;code&#x27;</span>] = position.contract.symbol</span><br><span class="line">        pos[<span class="string">&#x27;qty&#x27;</span>] = position.position</span><br><span class="line">        pos[<span class="string">&#x27;cost_price&#x27;</span>] = position.averageCost</span><br><span class="line">        pos[<span class="string">&#x27;market_val&#x27;</span>] = position.marketValue</span><br><span class="line">        pos[<span class="string">&#x27;pl_val&#x27;</span>] = position.unrealizedPNL</span><br><span class="line">        <span class="keyword">if</span> pos[<span class="string">&#x27;cost_price&#x27;</span>] * pos[<span class="string">&#x27;qty&#x27;</span>] == <span class="number">0</span>:</span><br><span class="line">            pos[<span class="string">&#x27;pl_ratio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pos[<span class="string">&#x27;pl_ratio&#x27;</span>] = pos[<span class="string">&#x27;pl_val&#x27;</span>] / (pos[<span class="string">&#x27;cost_price&#x27;</span>] * pos[<span class="string">&#x27;qty&#x27;</span>])</span><br><span class="line">        pos_data.append(pos)</span><br><span class="line"></span><br><span class="line">    orders_data = []</span><br><span class="line">    data = self.client.trades()</span><br><span class="line">    <span class="keyword">for</span> order <span class="keyword">in</span> data:</span><br><span class="line">        o = &#123;&#125;</span><br><span class="line">        o[<span class="string">&#x27;order_id&#x27;</span>] = order.order.orderId</span><br><span class="line">        o[<span class="string">&#x27;order_status&#x27;</span>] = order.orderStatus.status</span><br><span class="line">        o[<span class="string">&#x27;create_time&#x27;</span>] = order.log[<span class="number">-1</span>].time</span><br><span class="line">        o[<span class="string">&#x27;trd_side&#x27;</span>] = order.order.action</span><br><span class="line">        o[<span class="string">&#x27;order_type&#x27;</span>] = order.order.action</span><br><span class="line">        o[<span class="string">&#x27;code&#x27;</span>] = order.contract.symbol</span><br><span class="line">        orders_data.append(o)</span><br><span class="line">    <span class="keyword">return</span> acc_data, pos_data, orders_data</span><br></pre></td></tr></table></figure></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Full code of <b>get_account_detail()</b> function</i></p><h1 id="Fetch-the-market-calendar"><a href="#Fetch-the-market-calendar" class="headerlink" title="Fetch the market calendar"></a>Fetch the market calendar</h1><p>The trading hours information in <code>ib_insync</code> package is quite discreet. After reading the API document very carefully, I finally found it in the response of <code>ib.reqContractDetails()</code> call and look like this:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ContractDetails(contract=Contract(secType=<span class="string">&#x27;STK&#x27;</span>, conId=<span class="number">756733</span>, symbol=<span class="string">&#x27;SPY&#x27;</span>, exchange=<span class="string">&#x27;SMART&#x27;</span>, primaryExchange=<span class="string">&#x27;ARCA&#x27;</span>, currency=<span class="string">&#x27;USD&#x27;</span>, localSymbol=<span class="string">&#x27;SPY&#x27;</span>,</span><br><span class="line">tradingClass=<span class="string">&#x27;SPY&#x27;</span>), marketName=<span class="string">&#x27;SPY&#x27;</span>, minTick=<span class="number">0.01</span>, orderTypes=<span class="string">&#x27;ACTIVETIM,AD,ADJUST,ALERT,ALGO,ALLOC,AON,AVGCOST,BASKET,BENCHPX,CASHQTY,COND,CONDORDER,DARKONLY,</span></span><br><span class="line"><span class="string">DARKPOLL,DAY,DEACT,DEACTDIS,DEACTEOD,DIS,DUR,GAT,GTC,GTD,GTT,HID,IBKRATS,ICE,IOC,LIT,LMT,LOC,MIDPX,MIT,MKT,MOC,MTL,NGCOMB,NODARK,NONALGO,OCA,OPG,OPGREROUT,PEGBENCH,</span></span><br><span class="line"><span class="string">PEGMID,POSTATS,POSTONLY,PREOPGRTH,PRICECHK,REL,REL2MID,RELPCTOFS,RTH,SCALE,SCALEODD,SCALERST,SIZECHK,SMARTSTG,SNAPMID,SNAPMKT,SNAPREL,STP,STPLMT,SWEEP,TRAIL,TRAILLIT,</span></span><br><span class="line"><span class="string">TRAILLMT,TRAILMIT,WHATIF&#x27;</span>, validExchanges=<span class="string">&#x27;SMART,AMEX,NYSE,CBOE,PHLX,ISE,CHX,ARCA,ISLAND,DRCTEDGE,BEX,BATS,EDGEA,CSFBALGO,JEFFALGO,BYX,IEX,EDGX,FOXRIVER,PEARL,NYSENAT,</span></span><br><span class="line"><span class="string">LTSE,MEMX,IBEOS,PSX&#x27;</span>, priceMagnifier=<span class="number">1</span>, underConId=<span class="number">0</span>, longName=<span class="string">&#x27;SPDR S&amp;P 500 ETF TRUST&#x27;</span>, contractMonth=<span class="string">&#x27;&#x27;</span>, industry=<span class="string">&#x27;&#x27;</span>, category=<span class="string">&#x27;&#x27;</span>, subcategory=<span class="string">&#x27;&#x27;</span>, timeZoneId=<span class="string">&#x27;US/Eastern&#x27;</span>,</span><br><span class="line"> tradingHours=<span class="string">&#x27;20221212:0400-20221212:2000;20221213:0400-20221213:2000;20221214:0400-20221214:2000;20221215:0400-20221215:2000;20221216:0400-20221216:2000&#x27;</span>,</span><br><span class="line"> liquidHours=<span class="string">&#x27;20221212:0930-20221212:1600;20221213:0930-20221213:1600;20221214:0930-20221214:1600;20221215:0930-20221215:1600;20221216:0930-20221216:1600&#x27;</span>, evRule=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> evMultiplier=<span class="number">0</span>, mdSizeMultiplier=<span class="number">1</span>, aggGroup=<span class="number">1</span>, underSymbol=<span class="string">&#x27;&#x27;</span>, underSecType=<span class="string">&#x27;&#x27;</span>, marketRuleIds=<span class="string">&#x27;26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26&#x27;</span>,</span><br><span class="line"> secIdList=[TagValue(tag=<span class="string">&#x27;ISIN&#x27;</span>, value=<span class="string">&#x27;US78462F1030&#x27;</span>)], realExpirationDate=<span class="string">&#x27;&#x27;</span>, lastTradeTime=<span class="string">&#x27;&#x27;</span>, stockType=<span class="string">&#x27;ETF&#x27;</span>, minSize=<span class="number">0.0001</span>, sizeIncrement=<span class="number">0.0001</span>,</span><br><span class="line"> suggestedSizeIncrement=<span class="number">100.0</span>, cusip=<span class="string">&#x27;&#x27;</span>, ratings=<span class="string">&#x27;&#x27;</span>, descAppend=<span class="string">&#x27;&#x27;</span>, bondType=<span class="string">&#x27;&#x27;</span>, couponType=<span class="string">&#x27;&#x27;</span>, callable=False, putable=False, coupon=<span class="number">0</span>, convertible=False,</span><br><span class="line"> maturity=<span class="string">&#x27;&#x27;</span>, issueDate=<span class="string">&#x27;&#x27;</span>, nextOptionDate=<span class="string">&#x27;&#x27;</span>, nextOptionType=<span class="string">&#x27;&#x27;</span>, nextOptionPartial=False, notes=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Response of <b></b>ib.reqContractDetails()</b> functions</i></p><p>The trading calendar resides in this response, and we can extract them by parsing them like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_market_open</span>(<span class="params">self, offset_days=<span class="number">0</span></span>):</span></span><br><span class="line">    spy_contract = ib_insync.Stock(<span class="string">&#x27;SPY&#x27;</span>, <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">    self.client.qualifyContracts(spy_contract)</span><br><span class="line">    trading_days = self.client.reqContractDetails(spy_contract)[<span class="number">0</span>].liquidHours</span><br><span class="line">    trading_days_dict = &#123;d.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>]:d.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>] <span class="keyword">for</span> d <span class="keyword">in</span> trading_days.split(<span class="string">&#x27;;&#x27;</span>)&#125;</span><br><span class="line">    today_str = (datetime.now().astimezone(self.timezone) + timedelta(days=offset_days)).strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> trading_days_dict.items():</span><br><span class="line">        <span class="keyword">if</span> (today_str <span class="keyword">in</span> k) <span class="keyword">and</span> (v == <span class="string">&#x27;CLOSED&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_market_open_now</span>(<span class="params">self</span>):</span></span><br><span class="line">    spy_contract = ib_insync.Stock(<span class="string">&#x27;SPY&#x27;</span>, <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">    self.client.qualifyContracts(spy_contract)</span><br><span class="line">    trading_days = self.client.reqContractDetails(spy_contract)[<span class="number">0</span>].liquidHours</span><br><span class="line">    trading_days_list = [d.split(<span class="string">&#x27;-&#x27;</span>) <span class="keyword">for</span> d <span class="keyword">in</span> trading_days.split(<span class="string">&#x27;;&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">    day_str = datetime.now().astimezone(self.timezone).strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">    time_str = datetime.now().astimezone(self.timezone).strftime(<span class="string">&#x27;%H%M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> trading_days_list:</span><br><span class="line">        <span class="keyword">if</span> len(d) &gt; <span class="number">1</span> <span class="keyword">and</span> day_str <span class="keyword">in</span> d[<span class="number">0</span>].split()[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">if</span> time_str &gt; d[<span class="number">0</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>] <span class="keyword">and</span> time_str &lt; d[<span class="number">1</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Full code of <b>is_market_open()</b> and <b>is_market_open_now()</b> functions</i></p><h1 id="How-to-create-a-valid-order-for-Interactive-Broker"><a href="#How-to-create-a-valid-order-for-Interactive-Broker" class="headerlink" title="How to create a valid order for Interactive Broker"></a>How to create a valid order for Interactive Broker</h1><p>In order to create a valid order that Interactive Broker could recognize, there are a few steps to follow:</p><ol><li>Specify the symbol and the currency used. Use <code>contract = ib_insync.Stock(symbol, &#39;SMART&#39;, self.currency)</code> to create a <code>contract</code> object for later use. Stock symbol would be the first parameter, the name of the stock exchange be the second, and the currency symbol (here we use <code>USD</code>) would be the third.</li><li>Make a query to the broker to filter and find the related stock information. <code>ib.qualifyContracts(contract)</code> would activate the <code>contract</code> object and infuse live data from the stock exchange.<img data-src="/2022/12/12/2022-12-16-IBKR-broker-2/contract.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;"><i>Contract object before and after using <b>ib.qualifyContracts()</b> to infuse correct data</i></p></li><li>We need the latest quote price in order to calculate how many shares we would like to purchase. First of all, you need to specify the <code>reqMarketDataType</code> to tell the server which type of data you’re requesting. There are four market data types:<ol><li>1 - Live market data: (top of the book)</li><li>2 - Frozen data (at the close)</li><li>3 - Delayed data (can be used if there are no live subscriptions)</li><li>4 - Frozen Delayed data (outside of regular trading hours)<br>Once we have specified the market data type, we’re all set to request the quote price from the server using the <code>contract</code> in your first parameter and <code>snapshot</code> to <em>True</em>.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ib.reqMarketDataType(<span class="number">3</span>)</span><br><span class="line">quote = ib.reqMktData(</span><br><span class="line">    contract,</span><br><span class="line">    genericTickList=<span class="string">&quot;&quot;</span>,</span><br><span class="line">    snapshot=<span class="literal">True</span>,</span><br><span class="line">    regulatorySnapshot=<span class="literal">False</span>,</span><br><span class="line">    mktDataOptions=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>One thing worth mentioning is that, do you remember the reason why I’m using the <code>ib_insync</code> package instead of the native IBKR API? Instead of saying fetching a quote price from the API server, subscribing to the periodical price change would be a better way to put it. We first subscribe to the price bar to get 5-minute, 10-minute, or one-day price data, and another thread would be created to stream the price data. Therefore, to extract the quote price from the returned object, you first must ensure the quote price has been successfully returned/received.<blockquote><p><em>Notes: Before requesting a market quote, you need to subscribe to the market data on the IBKR platform. You can find the management page in the TWS or IB gateway tab “Account” -&gt; “Manage Account” -&gt; “Subscribe Market Data/Research”</em></p></blockquote></li></ol></li><li>Lastly, other than using <code>sleep()</code> function call to ensure that we have received the price data from the server, we can also assign the callback function to monitor the status of a specific order status change. Here we use a global configuration under the <code>ib</code> instance to specify this callback function by using <code>ib.orderStatusEvent += [callback function]</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.client = ib_insync.IB()</span><br><span class="line">    <span class="comment"># Newly added</span></span><br><span class="line">    self.client.orderStatusEvent += self.__order_status</span><br><span class="line">    self.client.connect(</span><br><span class="line">        IB_TWS_URI,</span><br><span class="line">        <span class="comment"># IB_GATEWAY_PAPER_PORT,</span></span><br><span class="line">        IB_TWS_PAPER_PORT,</span><br><span class="line">        IB_TWS_CLIENT_ID</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> self</span><br><span class="line"></span><br><span class="line">    self.client.disconnect()</span><br><span class="line">    self.client.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">place_order</span>(<span class="params">self, symbol: str, quantity: int, price: float=<span class="number">0</span></span>):</span></span><br><span class="line">    contract = ib_insync.Stock(symbol.upper(), <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">    self.client.qualifyContracts(contract)</span><br><span class="line">    <span class="keyword">if</span> quantity &gt;= <span class="number">0.0</span>:</span><br><span class="line">        order = ib_insync.MarketOrder(<span class="string">&#x27;BUY&#x27;</span>, quantity)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        order = ib_insync.MarketOrder(<span class="string">&#x27;SELL&#x27;</span>, -quantity)</span><br><span class="line">    trade = self.client.placeOrder(contract, order)</span><br><span class="line">    self.client.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_last_price_from_quote</span>(<span class="params">self</span>):</span></span><br><span class="line">    contract = ib_insync.Stock(symbol.upper(), <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">    self.client.qualifyContracts(contract)</span><br><span class="line">    <span class="comment"># ib.reqMarketDataType(1)   # Live market data: (top of the book)</span></span><br><span class="line">    <span class="comment"># ib.reqMarketDataType(2)   # Frozen data (at the close)</span></span><br><span class="line">    <span class="comment"># ib.reqMarketDataType(3)   # Delayed data (can be used if there is no live subscriptions)</span></span><br><span class="line">    <span class="comment"># ib.reqMarketDataType(4)   # Frozen Delayed data (outside of regular trading hours)</span></span><br><span class="line">    self.client.reqMarketDataType(<span class="number">3</span>)</span><br><span class="line">    quote = self.client.reqMktData(</span><br><span class="line">        contract,</span><br><span class="line">        genericTickList=<span class="string">&quot;&quot;</span>,</span><br><span class="line">        snapshot=<span class="literal">True</span>,</span><br><span class="line">        regulatorySnapshot=<span class="literal">False</span>,</span><br><span class="line">        mktDataOptions=<span class="literal">None</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> math.isnan(quote.last):</span><br><span class="line">            self.client.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> quote.last</span><br><span class="line">    logger.logger.error(<span class="string">&#x27;&#123;&#125;[&#123;&#125;]: &#123;&#125;&#x27;</span>.format(sys._getframe().f_code.co_name, symbol, <span class="string">&#x27;No last price in quote&#x27;</span>))</span><br><span class="line">    self.notifier.send_msg(<span class="string">&#x27;&#123;&#125;[&#123;&#125;]&#x27;</span>.format(sys._getframe().f_code.co_name, symbol), <span class="string">&#x27;No last price in quote&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__order_status</span>(<span class="params">self, trade</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Call back function for checking order status</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">f&#x27;Order [<span class="subst">&#123;trade.contract.symbol&#125;</span>] status updated: <span class="subst">&#123;trade.orderStatus.status&#125;</span>&#x27;</span>)</span><br><span class="line">    match trade.orderStatus.status:</span><br><span class="line">        case <span class="string">&#x27;Filled&#x27;</span>:</span><br><span class="line">            print(<span class="string">f&#x27;<span class="subst">&#123;trade=&#125;</span>&#x27;</span>)</span><br><span class="line">            self.update_order_from_filledEvent_in_db(trade)</span><br><span class="line">        case <span class="string">&#x27;PendingSubmit&#x27;</span>:</span><br><span class="line">            <span class="comment"># print(f&#x27;Pending submit: &#123;trade&#125;&#x27;)</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        case <span class="string">&#x27;Submitted&#x27;</span>:</span><br><span class="line">            <span class="comment"># print(f&#x27;Submitted: &#123;trade&#125;&#x27;)</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        case _:</span><br><span class="line">            <span class="comment"># print(f&#x27;Others: &#123;trade.orderStatus.status&#125;&#x27;)</span></span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="Let’s-wrap-it-up"><a href="#Let’s-wrap-it-up" class="headerlink" title="Let’s wrap it up"></a>Let’s wrap it up</h1><p>We have all the pieces ready except the <code>get_transaction()</code>, which we will talk about it in another post as we need to take Database management into account. Let’s now add some test code so that you can also place the order.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="keyword">import</span> ib_insync</span><br><span class="line"><span class="keyword">from</span> modules.broker.TradeAPI <span class="keyword">import</span> AbstractTradeInterface</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> zoneinfo <span class="keyword">import</span> ZoneInfo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InteractiveBrokerTradeAPI</span>(<span class="params">AbstractTradeInterface</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,currency=<span class="string">&#x27;USD&#x27;</span></span>):</span></span><br><span class="line">        self.client = <span class="literal">None</span></span><br><span class="line">        self.accounts = []</span><br><span class="line">        self.currency = currency</span><br><span class="line">        self.timezone = ZoneInfo(<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @contextmanager</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.client = ib_insync.IB()</span><br><span class="line">        <span class="comment"># Newly added</span></span><br><span class="line">        self.client.orderStatusEvent += self.__order_status</span><br><span class="line">        self.client.connect(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">7497</span>, <span class="number">101</span>)</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">        print(<span class="string">&quot;Connection established&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> self</span><br><span class="line"></span><br><span class="line">        self.client.disconnect()</span><br><span class="line">        self.client.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">        print(<span class="string">&quot;Connection closed&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_account_detail</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.accounts = self.client.managedAccounts()</span><br><span class="line"></span><br><span class="line">        acc_data = []</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> self.accounts:</span><br><span class="line">            acc = &#123;&#125;</span><br><span class="line">            acc[<span class="string">&#x27;account&#x27;</span>] = account</span><br><span class="line">            data = self.client.accountValues(account)</span><br><span class="line">            acc[<span class="string">&#x27;cash&#x27;</span>] = <span class="number">0</span></span><br><span class="line">            acc[<span class="string">&#x27;total_assets&#x27;</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">if</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;TotalCashBalance&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                    acc[<span class="string">&#x27;cash&#x27;</span>] = row.value</span><br><span class="line">                    acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">                <span class="keyword">elif</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;StockMarketValue&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                    acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">            acc_data.append(acc)</span><br><span class="line"></span><br><span class="line">        pos_data = []</span><br><span class="line">        data = self.client.portfolio()</span><br><span class="line">        <span class="keyword">for</span> position <span class="keyword">in</span> data:</span><br><span class="line">            pos = &#123;&#125;</span><br><span class="line"></span><br><span class="line">            pos[<span class="string">&#x27;code&#x27;</span>] = position.contract.symbol</span><br><span class="line">            pos[<span class="string">&#x27;qty&#x27;</span>] = position.position</span><br><span class="line">            pos[<span class="string">&#x27;cost_price&#x27;</span>] = position.averageCost</span><br><span class="line">            pos[<span class="string">&#x27;market_val&#x27;</span>] = position.marketValue</span><br><span class="line">            pos[<span class="string">&#x27;pl_val&#x27;</span>] = position.unrealizedPNL</span><br><span class="line">            <span class="keyword">if</span> pos[<span class="string">&#x27;cost_price&#x27;</span>] * pos[<span class="string">&#x27;qty&#x27;</span>] == <span class="number">0</span>:</span><br><span class="line">                pos[<span class="string">&#x27;pl_ratio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos[<span class="string">&#x27;pl_ratio&#x27;</span>] = pos[<span class="string">&#x27;pl_val&#x27;</span>] / (pos[<span class="string">&#x27;cost_price&#x27;</span>] * pos[<span class="string">&#x27;qty&#x27;</span>])</span><br><span class="line">            pos_data.append(pos)</span><br><span class="line"></span><br><span class="line">        orders_data = []</span><br><span class="line">        data = self.client.trades()</span><br><span class="line">        <span class="keyword">for</span> order <span class="keyword">in</span> data:</span><br><span class="line">            o = &#123;&#125;</span><br><span class="line">            o[<span class="string">&#x27;order_id&#x27;</span>] = order.order.permId</span><br><span class="line">            o[<span class="string">&#x27;order_status&#x27;</span>] = order.orderStatus.status</span><br><span class="line">            o[<span class="string">&#x27;create_time&#x27;</span>] = order.log[<span class="number">-1</span>].time</span><br><span class="line">            o[<span class="string">&#x27;trd_side&#x27;</span>] = order.order.action</span><br><span class="line">            o[<span class="string">&#x27;order_type&#x27;</span>] = order.order.action</span><br><span class="line">            o[<span class="string">&#x27;code&#x27;</span>] = order.contract.symbol</span><br><span class="line">            orders_data.append(o)</span><br><span class="line">        <span class="keyword">return</span> acc_data, pos_data, orders_data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">place_order</span>(<span class="params">self, symbol: str, quantity: int, price: float=<span class="number">0</span></span>):</span></span><br><span class="line">        contract = ib_insync.Stock(symbol.upper(), <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">        self.client.qualifyContracts(contract)</span><br><span class="line">        <span class="keyword">if</span> quantity &gt;= <span class="number">0.0</span>:</span><br><span class="line">            order = ib_insync.MarketOrder(<span class="string">&#x27;BUY&#x27;</span>, quantity)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            order = ib_insync.MarketOrder(<span class="string">&#x27;SELL&#x27;</span>, -quantity)</span><br><span class="line">        trade = self.client.placeOrder(contract, order)</span><br><span class="line">        self.client.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_last_price_from_quote</span>(<span class="params">self, symbol:str</span>):</span></span><br><span class="line">        contract = ib_insync.Stock(symbol.upper(), <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">        <span class="comment"># self.client.reqMarketDataType(3)</span></span><br><span class="line">        self.client.reqMarketDataType(<span class="number">3</span>)</span><br><span class="line">        self.client.qualifyContracts(contract)</span><br><span class="line">        quote = self.client.reqMktData(</span><br><span class="line">            contract,</span><br><span class="line">            genericTickList=<span class="string">&quot;&quot;</span>,</span><br><span class="line">            snapshot=<span class="literal">True</span>,</span><br><span class="line">            regulatorySnapshot=<span class="literal">False</span>,</span><br><span class="line">            mktDataOptions=<span class="literal">None</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> math.isnan(quote.last):</span><br><span class="line">                self.client.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> quote.last</span><br><span class="line">        print(<span class="string">f&#x27;No last price in quote for <span class="subst">&#123;symbol&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__order_status</span>(<span class="params">self, trade</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Call back function for checking order status</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">f&#x27;Order [<span class="subst">&#123;trade.contract.symbol&#125;</span>] status updated: <span class="subst">&#123;trade.orderStatus.status&#125;</span>&#x27;</span>)</span><br><span class="line">        match trade.orderStatus.status:</span><br><span class="line">            case <span class="string">&#x27;Filled&#x27;</span>:</span><br><span class="line">                print(<span class="string">f&#x27;Order <span class="subst">&#123;trade.contract.symbol&#125;</span>, filled.&#x27;</span>)</span><br><span class="line">            case _:</span><br><span class="line">                print(<span class="string">f&#x27;Others order status: <span class="subst">&#123;trade.orderStatus.status&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_market_open</span>(<span class="params">self, offset_days=<span class="number">0</span></span>):</span></span><br><span class="line">        spy_contract = ib_insync.Stock(<span class="string">&#x27;SPY&#x27;</span>, <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">        self.client.qualifyContracts(spy_contract)</span><br><span class="line">        trading_days = self.client.reqContractDetails(spy_contract)[<span class="number">0</span>].liquidHours</span><br><span class="line">        trading_days_dict = &#123;d.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>]:d.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>] <span class="keyword">for</span> d <span class="keyword">in</span> trading_days.split(<span class="string">&#x27;;&#x27;</span>)&#125;</span><br><span class="line">        today_str = (datetime.now().astimezone(self.timezone) + timedelta(days=offset_days)).strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> trading_days_dict.items():</span><br><span class="line">            <span class="keyword">if</span> (today_str <span class="keyword">in</span> k) <span class="keyword">and</span> (v == <span class="string">&#x27;CLOSED&#x27;</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_market_open_now</span>(<span class="params">self</span>):</span></span><br><span class="line">        spy_contract = ib_insync.Stock(<span class="string">&#x27;SPY&#x27;</span>, <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">        self.client.qualifyContracts(spy_contract)</span><br><span class="line">        trading_days = self.client.reqContractDetails(spy_contract)[<span class="number">0</span>].liquidHours</span><br><span class="line">        trading_days_list = [d.split(<span class="string">&#x27;-&#x27;</span>) <span class="keyword">for</span> d <span class="keyword">in</span> trading_days.split(<span class="string">&#x27;;&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">        day_str = datetime.now().astimezone(self.timezone).strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">        time_str = datetime.now().astimezone(self.timezone).strftime(<span class="string">&#x27;%H%M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> trading_days_list:</span><br><span class="line">            <span class="keyword">if</span> len(d) &gt; <span class="number">1</span> <span class="keyword">and</span> day_str <span class="keyword">in</span> d[<span class="number">0</span>].split()[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> time_str &gt; d[<span class="number">0</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>] <span class="keyword">and</span> time_str &lt; d[<span class="number">1</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_transactions</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main function</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    broker = InteractiveBrokerTradeAPI()</span><br><span class="line">    print(datetime.now().strftime(<span class="string">&#x27;Now is %Y-%m-%d&#x27;</span>))</span><br><span class="line">    <span class="keyword">with</span> broker.connect() <span class="keyword">as</span> c:</span><br><span class="line">        accounts, positions, orders = c.get_account_detail()</span><br><span class="line">        print(ib_insync.util.df(accounts))</span><br><span class="line">        print(ib_insync.util.df(positions))</span><br><span class="line">        print(ib_insync.util.df(orders))</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">        market_open = c.is_market_open()</span><br><span class="line">        market_open_now = c.is_market_open_now()</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;market_open=&#125;</span>&#x27;</span>)</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;market_open_now=&#125;</span>&#x27;</span>)</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">        print(c.get_last_price_from_quote(<span class="string">&#x27;SSO&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> market_open <span class="keyword">and</span> market_open_now:</span><br><span class="line">            last = c.get_last_price_from_quote(<span class="string">&#x27;AAPL&#x27;</span>)</span><br><span class="line">            print(<span class="string">f&#x27;<span class="subst">&#123;last=&#125;</span>&#x27;</span>)</span><br><span class="line">            c.place_order(<span class="string">&#x27;AAPL&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>And here’s the output.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Output</span></span><br><span class="line">Now <span class="keyword">is</span> <span class="number">2022</span><span class="number">-12</span><span class="number">-14</span></span><br><span class="line">==============================</span><br><span class="line">Connection established</span><br><span class="line">==============================</span><br><span class="line">     account      cash  total_assets</span><br><span class="line"><span class="number">0</span>  DU4399668  <span class="number">2118.598</span>     <span class="number">99946.918</span></span><br><span class="line">  code     qty  cost_price  market_val   pl_val  pl_ratio</span><br><span class="line"><span class="number">0</span>  SHV   <span class="number">427.0</span>  <span class="number">109.987048</span>    <span class="number">46970.03</span>     <span class="number">5.56</span>  <span class="number">0.000118</span></span><br><span class="line"><span class="number">1</span>  SSO  <span class="number">1019.0</span>   <span class="number">48.717576</span>    <span class="number">50858.29</span>  <span class="number">1215.08</span>  <span class="number">0.024476</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">==============================</span><br><span class="line">market_open=<span class="literal">True</span></span><br><span class="line">market_open_now=<span class="literal">True</span></span><br><span class="line">==============================</span><br><span class="line"><span class="number">49.94</span></span><br><span class="line">last=<span class="number">147.86</span></span><br><span class="line">Order [AAPL] status updated: PreSubmitted</span><br><span class="line">Others order status: PreSubmitted</span><br><span class="line">Order [AAPL] status updated: Filled</span><br><span class="line">Order AAPL, filled.</span><br><span class="line">==============================</span><br><span class="line">Connection closed</span><br><span class="line">==============================</span><br></pre></td></tr></table></figure><p>Voila! Now as long as we schedule the time for each function to run, we will have our automated trading script ready to run! It’s time for you to put on your creative hat and start improvising, adding your own magic to your trading script. See you next time.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/12/12/2022-12-16-IBKR-broker-2/cover.png&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;p&gt;This is the second part of the &lt;a href=&quot;https://mikelhsia.github.io/2022/12/12/2022-12-10-IBKR-Broker/&quot;&gt;&lt;strong&gt;Set Up Trading API Template In Python&lt;/strong&gt;&lt;/a&gt;. We’re going to focus on implementing the rest of the functions in our Interactive Broker class.&lt;/p&gt;</summary>
    
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/categories/How2/"/>
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/How2/Quantitative-Trading/"/>
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/tags/How2/"/>
    
    <category term="Python3" scheme="http://mikelhsia.github.io/tags/Python3/"/>
    
    <category term="Interactive Broker" scheme="http://mikelhsia.github.io/tags/Interactive-Broker/"/>
    
  </entry>
  
  <entry>
    <title>【How 2】Set Up Trading API Template In Python - Connecting My Trading Strategies To Interactive Brokers</title>
    <link href="http://mikelhsia.github.io/2022/12/07/2022-12-10-IBKR-Broker/"/>
    <id>http://mikelhsia.github.io/2022/12/07/2022-12-10-IBKR-Broker/</id>
    <published>2022-12-07T06:58:04.000Z</published>
    <updated>2022-12-15T07:05:45.857Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/12/07/2022-12-10-IBKR-Broker/cover.png" class="" width="800"><p>Building your trading strategy to connect to a broker with the broker’s proprietary API is always dreadful. There are tones of API documentation to read, tones of trial-and-error tests to conduct, and tones of unknown causes and bugs that fail your API test. In this post, I’m going to demonstrate my MVP API template to get my trading strategies to work, so that you can build your own in a way that makes your trading strategies work as well.</p><a id="more"></a><hr><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">【Momentum Trading】A Defense Trading Strategy That Works - CPPI (Constant Proportion Portfolio Insurance)</a></li></ul><p>After completing the research CPPI investment strategy, I need to find a new broker with a new account to start trading. <a href="https://www.interactivebrokers.ca/en/trading/lp-why-ibkr.php?wid=978897570"><strong>Interactive Broker (IBKR)</strong></a> is the first broker that I am familiar with when I was a student, so I kinda have this obsession to make my trades through it. Years later, I consider myself finally had the luxury to sit down and spend time reading their API documentation. I’ve found the <a href="https://www.interactivebrokers.com/en/trading/api-guides.php">IBKR API</a> doesn’t support retrieving historical transaction data, for example, the orders you placed three days ago and the commissions you paid for each trade wouldn’t be stored anywhere in the IBKR server. However, I need this information to build my performance evaluation report. Therefore, I’ve decided to put it on hold until there’s a good enough solution to come to rescue me. Now, as my knowledge grows, I’ve figured it’s about time to tackle this task.</p><p><a href="https://www.interactivebrokers.ca/en/trading/lp-why-ibkr.php?wid=978897570"><strong>Interactive Broker (IBKR)</strong></a> is a renowned investment broker that has successfully operated its business across the world. It is also famous for its low trading fees in both the equity and the derivative markets. On the other hand, its proprietary API is notorious for being complicated enough to work with. I’m going to give you my two cents here and hopefully it’ll help people who would like to consider Interactive Broker as their market broker. Here are the things I’m going to talk about:</p><ul><li>IBKR TWS and IB gateway</li><li>IB gateway configurations</li><li>My MVP broker API template</li><li>Introduce ib_insync package and start connecting</li><li>Implement our first IBKR call</li></ul><h1 id="IBKR-TWS-and-IB-gateway"><a href="#IBKR-TWS-and-IB-gateway" class="headerlink" title="IBKR TWS and IB gateway"></a>IBKR TWS and IB gateway</h1><p>In order to connect to the broker’s API service, each broker provides different methods to do so. <a href="https://developer.tdameritrade.com/apis">TD Ameritrade API</a> allows you to use their API service remotely through the API token provided. <a href="https://openapi.futunn.com/futu-api-doc/en/">Futu OpenAPI</a> requires you to download extra software on your local PC/laptop, so that your API calls will be able to access their API service through this middleware. As for [IBKR API], it is similar to Futu OpenAPI that all the API calls are connected through its proprietary software to reach the API service.</p><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/cover.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>How does your API call reach the IBKR API service</i></p><p>Interactive broker provides two software applications to help you connect to their API service:</p><p><strong>TWS</strong><br>TWS stands for Trader Workstation. TWS is designed for trades who would like to conduct a series of research and trade equity and derivatives across many markets in one unified platform. Users can read the latest news, study company fundamentals and annual reports, research the stock trend or patterns, and even place orders with it. Also, it embeds the capability of being an intermediary between your desktop/laptop and the IBKR API service.<br><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/tws.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>IBKR TWS Trading Station</i></p><p><strong>IB gateway</strong><br>Compared to TWS, IB gateway is simply an API gateway without all the User Interface that you can see in the TWS. You can’t buy or sell or do anything with the IB gateway. It allows you to connect to the IBKR API service and nothing more. In general, it is a super lightweight TWS that will consume much less of your desktop/laptop memories and resources.<br><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/ib_gateway.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>IBKR IB Gateway</i></p><p>These two software applications have similar configurations but hold separate parameters which they don’t share mutually. Now let’s take a look at the configurations that will concern us before we start programming our API connection to IBKR.</p><h1 id="IB-gateway-configurations"><a href="#IB-gateway-configurations" class="headerlink" title="IB gateway configurations"></a>IB gateway configurations</h1><p>Let’s use IB gateway as an example so that we don’t get distracted by the various features that TWS offers. First of all, we need to log in to the IB gateway software application. I don’t want to mess around with my real money while testing my trading script, I would instead use a paper account. <em>(Tip: You can reset your paper account on your account management page every day.)</em></p><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/login.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Login to your paper account</i></p><p>Here is a few configurations that you need to pay attention to before starting to code:</p><ol><li>In API -&gt; Setting, uncheck the <em>“Read-Only API”</em>.</li><li>In API -&gt; Setting, remember or configure the <em>“Socket port”</em> because you will need it when connecting to this software.</li><li>In API -&gt; Precautions, check the box <em>“Bypass Order Precaution for API Order”</em> to prevent additional errors or warning dialog boxes popped up when you place orders through API.</li><li>If you’re using TWS as your middleman service, you need to check one more box <em>“Enable ActiveX and Socket Client”</em>.</li></ol><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/api_configuration.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>API configuration</i></p><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/api_configuration2.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>API configuration 2</i></p><p>Now we’re all set. Let’s get down to the business.</p><h1 id="My-MVP-broker-API-template"><a href="#My-MVP-broker-API-template" class="headerlink" title="My MVP broker API template"></a>My MVP broker API template</h1><p>There are a few actions required in your trading strategies in order to run the basic buy/sell operations properly:</p><ol><li>Connect to and disconnect from the dedicated broker API service.</li><li>Get your basic account info in order to know the account status such as <code>Total asset value</code>, <code>Remaining cash balance</code>, <code>Purchasing power</code>, … and so on.</li><li>Check the trading calendar and trading hours to see whether the market is open for trading or if it’s a holiday today.</li><li>Check the current quote price of a specific symbol in order to know how many shares we would purchase.</li><li>Place orders through the broker API.</li><li>Get the transaction history for performance evaluation later on.</li></ol><p>I use the <a href="https://docs.python.org/3/library/abc.html">python package <code>abc</code></a> (abbreviation for <strong>Abstract Base Class</strong>) to build my base API template. The most obvious advantage of building a baseclass with an abstract base class is that you can easily extend from it to build another class. For example, you have a class called <strong>InteractiveBrokerClass</strong> to make trades, and another class called <strong>TDAmeritradeBrokerClass</strong> to make trades with <a href="https://www.tdameritrade.com/">TD Ameritrade</a>. Both broker classes do similar things and require similar functions. Implementing them using as abstract base class would make your life easier in terms of managing the actions in both derived classes. Here’s my broker base class:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TradeAPI.py</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractTradeInterface</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_account_detail</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_last_price_from_quote</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">place_order</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_market_open</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_market_open_now</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_transactions</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Abstract Trading API Template</i></p><p>Implementing any of them could be straightforward and also could be extremely complex, depending on the design of the structure of the proprietary broker API. Like I said earlier that Interactive Broker didn’t support querying historic transactions/trades, we need to build alternative functions on the side in order to support the <code>def get_transactions(self)</code> in our base template. I’m not going to dive into how to build them now and we will come back to this in another post. I will start by looking at how we are going to connect to the IB gateway by implementing the <code>def connect()</code> function, and then we can check the quote price and place orders with API calls whenever we want to.</p><h1 id="Introduce-ib-insync-package-and-start-connecting"><a href="#Introduce-ib-insync-package-and-start-connecting" class="headerlink" title="Introduce ib_insync package and start connecting"></a>Introduce ib_insync package and start connecting</h1><p>Instead of using the native <code>ib_api</code> package to connect to the IBKR API service, I choose to use <a href="https://pypi.org/project/ib-insync/"><code>ib_insync</code></a> package developed by <strong><em>Ewald R. de Wit</em></strong>. <code>ib_insync</code> not only simplifies the way to connect and communicate with the IBKR API service, but it also adds the asynchronous capability so that less CPU time was wasted while requesting data from the server. Here is an introductory post to get you familiar with the functions provided in <code>ib_insync</code>: <a href="https://algotrading101.com/learn/ib_insync-interactive-brokers-api-guide/">ib_insync: Interactive Broker API guide</a>. We can clearly learn that we can connect to the IBKR API service with the following code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ib = IB()</span><br><span class="line">ib.connect(</span><br><span class="line">  host=<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment"># local host IP</span></span><br><span class="line">  port=<span class="number">4002</span>, <span class="comment"># The port that we configured in the IB gateway</span></span><br><span class="line">  clientId=<span class="number">1</span> <span class="comment"># The non-duplicated client ID for each connection</span></span><br><span class="line">)</span><br><span class="line">ib.disconnect() <span class="comment"># To disconnect from the server</span></span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>You would need to connect to server before you make any request</i></p><p>This established connection <code>ib</code> was handled and maintained by whoever initiated it. In order to better and easier to handle the connection and close it effectively once we finished using it, I would suggest using <a href="https://docs.python.org/3/library/contextlib.html"><code>contextmanager</code></a> so that the context manager will close the connection once we finished using it. We don’t have to explicitly disconnect from the API service. Instead, the context manager will handle it every time when the <code>with</code> clause is finished.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">  self.client = ib_insync.IB()</span><br><span class="line">  self.client.connect(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">4002</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">yield</span> self <span class="comment"># Return the self instance</span></span><br><span class="line"></span><br><span class="line">  self.client.disconnect()</span><br><span class="line">  self.client.sleep(<span class="number">2</span>)  <span class="comment"># make sure the connection is closed before next time you connect to IBKR API service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  <span class="keyword">with</span> broker.connect() <span class="keyword">as</span> c:</span><br><span class="line">    <span class="comment"># Make requests to the server</span></span><br><span class="line">  <span class="comment"># The connections will be closed since we disconnect from the server after `yield self`</span></span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Connect function implemented with context manager</i></p><h1 id="Implement-our-first-IBKR-call"><a href="#Implement-our-first-IBKR-call" class="headerlink" title="Implement our first IBKR call"></a>Implement our first IBKR call</h1><p>In the last part of this post, let’s try to implement <code>get_account_detail()</code> call in our broker class so that we could learn the account status.</p><p>In the original <a href="https://ib-insync.readthedocs.io/api.html">ib_insync document</a>, I found out that <code>ib.managedAccounts()</code> can retrieve a list of account names, and <code>ib.accountValues(account:str)</code> can retrieve all stats under this account parameter. Hence, I’m going to:</p><ol><li>First, use <code>ib.managedAccounts()</code> to retrieve all the accounts created.</li><li>Use <code>ib.accountValues()</code> to get all variables related to this account.</li><li>Extract the <code>TotalCashBalance</code> and <code>StockMarketValue</code> concerned USD so that I could tell how much money I have in cash and as well the total value under my account.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="keyword">import</span> ib_insync</span><br><span class="line"><span class="keyword">from</span> zoneinfo <span class="keyword">import</span> ZoneInfo</span><br><span class="line"><span class="keyword">from</span> modules.broker.TradeAPI <span class="keyword">import</span> AbstractTradeInterfac</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InteractiveBrokerTradeAPI</span>(<span class="params">AbstractTradeInterface</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,currency=<span class="string">&#x27;USD&#x27;</span></span>):</span></span><br><span class="line">        self.client = <span class="literal">None</span></span><br><span class="line">        self.accounts = []</span><br><span class="line">        self.currency = currency</span><br><span class="line"></span><br><span class="line"><span class="meta">    @contextmanager</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.client = ib_insync.IB()</span><br><span class="line">        self.client.connect(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">4002</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> self</span><br><span class="line"></span><br><span class="line">        self.client.disconnect()</span><br><span class="line">        self.client.sleep(<span class="number">2</span>)  <span class="comment"># make sure the connection is closed before next time you connect to IBKR API service</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_account_detail</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.accounts = self.client.managedAccounts()</span><br><span class="line"></span><br><span class="line">        acc_data = []</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> self.accounts:</span><br><span class="line">            acc = &#123;&#125;</span><br><span class="line">            acc[<span class="string">&#x27;account&#x27;</span>] = account</span><br><span class="line">            data = self.client.accountValues(account)</span><br><span class="line">            acc[<span class="string">&#x27;cash&#x27;</span>] = <span class="number">0</span></span><br><span class="line">            acc[<span class="string">&#x27;total_assets&#x27;</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">if</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;TotalCashBalance&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                    acc[<span class="string">&#x27;cash&#x27;</span>] = row.value</span><br><span class="line">                    acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">                <span class="keyword">elif</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;StockMarketValue&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                    acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">            acc_data.append(acc)</span><br><span class="line">        <span class="keyword">return</span> acc_data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_last_price_from_quote</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">place_order</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_market_open</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_market_open_now</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_transactions</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main function</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    broker = InteractiveBrokerTradeAPI()</span><br><span class="line">    <span class="keyword">with</span> broker.connect() <span class="keyword">as</span> c:</span><br><span class="line">        accounts = c.get_account_detail()</span><br><span class="line">        print(accounts)</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Full code</i></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Output</span></span><br><span class="line">&gt;&gt; [&#123;<span class="string">&#x27;account&#x27;</span>: <span class="string">&#x27;DU4399668&#x27;</span>, <span class="string">&#x27;cash&#x27;</span>: <span class="string">&#x27;77.44&#x27;</span>, <span class="string">&#x27;total_assets&#x27;</span>: <span class="number">96737.42</span>&#125;]</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Account status output</i></p><p><em>Noted: Make sure you attach the rest of the unimplemented functions as I did, as this is required in an abstract class. Otherwise, you will see the following error message when you run the test code.</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/michael/quantitative-strategy/app/trading/test.py&quot;</span>, line <span class="number">86</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    broker = InteractiveBrokerTradeAPI(version_param=SCRIPT_VERSION)</span><br><span class="line">TypeError: Can<span class="string">&#x27;t instantiate abstract class InteractiveBrokerTradeAPI with abstract methods get_last_price_from_quote, get_transactions, is_market_open, is_market_open_now, place_order</span></span><br></pre></td></tr></table></figure></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>You need to implement all defined functions in the base class</i></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Done! We’re not officially connecting our trading script to the Interactive Broker API service. To make sure this broker class can fully support the functionalities of your trading program, there are still more functions to be implemented. Don’t worry, I’ll see you next time.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/12/07/2022-12-10-IBKR-Broker/cover.png&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;p&gt;Building your trading strategy to connect to a broker with the broker’s proprietary API is always dreadful. There are tones of API documentation to read, tones of trial-and-error tests to conduct, and tones of unknown causes and bugs that fail your API test. In this post, I’m going to demonstrate my MVP API template to get my trading strategies to work, so that you can build your own in a way that makes your trading strategies work as well.&lt;/p&gt;</summary>
    
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/categories/How2/"/>
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/How2/Quantitative-Trading/"/>
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/tags/How2/"/>
    
    <category term="Python3" scheme="http://mikelhsia.github.io/tags/Python3/"/>
    
    <category term="Interactive Broker" scheme="http://mikelhsia.github.io/tags/Interactive-Broker/"/>
    
  </entry>
  
  <entry>
    <title>【Momentum Trading】A Defense Trading Strategy That Works - CPPI (Constant Proportion Portfolio Insurance)</title>
    <link href="http://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/"/>
    <id>http://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/</id>
    <published>2022-11-03T17:04:25.000Z</published>
    <updated>2022-12-12T03:37:33.065Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/cover.jpg" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Photo by <a href='https://medium.com/r?url=https%3A%2F%2Funsplash.com%2F%40sasun1990%3Futm_source%3Dmedium%26utm_medium%3Dreferral'>Sasun Bughdaryan</a> on <a href='https://unsplash.com/?utm_source=medium&utm_medium=referral'>Unsplash</a></i></p><p>We’ve been talking too much about the attack side of quantitative trading, such as momentum, mean reversion, and ML. These strategies aim to outperform the benchmark/index by adding your personal points of view to the trading strategies. Beating the benchmark becomes the only goal when playing the offense. What about defense? After reading <a href="https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/">Introduction to CPPI – Constant Proportion Portfolio Insurance</a>, I started to feel that I can’t agree more with the idea of “The best defense is a good offense” once said by Sun Tzu, a Chinese military general, a strategist, and a philosopher. What does defense mean in the field of quantitative trading? Does defense mean we strive not to lose money and then nothing else worth doing? Maybe talking about the CPPI strategy would give us a better picture of what actually defense means to the traders. Let’s now have a look at how to approach the other side of trading.</p><a id="more"></a><hr><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><h1 id="What-does-it-mean-by-playing-defense-in-trading"><a href="#What-does-it-mean-by-playing-defense-in-trading" class="headerlink" title="What does it mean by playing defense in trading?"></a>What does it mean by playing defense in trading?</h1><p>When talking about quantitative strategy, they all come down to this advanced CAPM formula and use it to categorize different trading strategies. $\beta$ in this formula stands for the sensitivity of your portfolio against the movement of the market return and $\alpha$ stands for the excessive market return that can’t be captured by the $\beta$ term. For example, if the current risk-free rate is 1%, and the market return is 4% with 0 in $\alpha$, then you can calculate that your expected return would be $2*(4\%-1\%) + 1\% = 7\%$ if the $\beta$ equals to 2, or 10% if the $\beta$ equals 3.</p><script type="math/tex; mode=display">Return_{Expected} = Return_{riskfree} + \beta \times (Return_{market} - Return_{riskfree}) + \alpha</script><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Advanced CAPM model by <a href='https://www.investopedia.com/terms/j/jensensmeasure.asp'>Jensen</a></i></p><p>The $\beta$ here is essentially the <strong>exposure</strong> of our portfolio against market fluctuation. The idea of playing defense in trading is to reduce the exposure against the market so that you will lose less money than other people in the bear market. There are ways to reduce market exposure, such as market-neutral strategy, portfolio diversification, hedging, and many other methods that help reduce your market exposure and $\beta$ of your portfolio. However, reducing $\beta$ could also harm your profit when the overall market goes up because you have a smaller $\beta$. This is what happens when you play defense in trading.</p><h1 id="What-is-CPPI-Constant-Proportion-Portfolio-Insurance-strategy"><a href="#What-is-CPPI-Constant-Proportion-Portfolio-Insurance-strategy" class="headerlink" title="What is CPPI (Constant Proportion Portfolio Insurance) strategy?"></a>What is CPPI (Constant Proportion Portfolio Insurance) strategy?</h1><p>CPPI (Constant Proportion Portfolio Insurance) strategy achieves the goal of reducing risk exposure by adding a risk-free asset such as a 3-month treasury into your portfolio, which can be considered as a type of <em>portfolio diversification</em>. Short-term treasury usually has very little risk exposure against the market. You can see below the close price movement of SHV, SHY, TLT, and IEF compare to the movement of SPY close price.</p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/riskfree.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Which asset is worth being picked as a risk-free asset? As SHY and SHV are short-term Treasury ETFs, and TLT and IEF are long-term Treasury ETF</i></p><p>On top of adding a risk-free asset into the portfolio, the CPPI strategy proposes concepts named <strong><em>Floor</em></strong> and <strong><em>Cushion</em></strong>. <strong><em>Floor</em></strong> would be the minimum asset value that you want to protect from loss, and the <strong><em>Cushion</em></strong> is the asset value that you would like to invest in riskier assets in order to gain an additional return. CPPI strategy allows investors to keep the potential chances of profiting, and limiting the downside risk by scaling the ratios of the floor and cushion dynamically. I’m listing the related formulas below for reference. For more details, go take a look at the <a href="https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/">article</a> in <a href="https://quantpedia.com">QuantPedia</a>.</p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/intro-to-CPPI.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Extracted from <a href='https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/'>Introduction to CPPI – Constant Proportion Portfolio Insurance</a></i></p><h1 id="Disadvantages-when-applying-CPPI-strategies"><a href="#Disadvantages-when-applying-CPPI-strategies" class="headerlink" title="Disadvantages when applying CPPI strategies"></a>Disadvantages when applying CPPI strategies</h1><p>After conducting a series of backtesting against the proposed strategies in the <a href="https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/">article</a>, I’ve found the strategies are less promising and less satisfying than I originally expected. Here are a few things I discovered:</p><h2 id="Floor-level-is-fixed-even-if-the-total-asset-value-go-rocket-high"><a href="#Floor-level-is-fixed-even-if-the-total-asset-value-go-rocket-high" class="headerlink" title="Floor level is fixed even if the total asset value go rocket high"></a>Floor level is fixed even if the total asset value go rocket high</h2><ul><li>In <strong>Basic CPPI</strong> strategy: I approached this strategy by setting a fixed percentage (80%) of the original asset that I want to protect from the beginning. This means, for example, I have \$100,000 as my start-up fund, and I want to protect 80% value of my fund. Then I’ll have \$80,000 as my floor level.</li><li>Even though we have the minimum asset value protected, the floor value stays the same throughout the entire backtesting period. This also means that there is a big chunk of the asset not protected when the portfolio grows a certain amount. That’s the reason why we suffer a huge drop at the beginning of 2022.</li></ul><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/basic_cppi.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Basic CPPI: Max Drawdown: 59.3%, Annual Variance: 0.069</i></p><h2 id="The-value-floor-trench"><a href="#The-value-floor-trench" class="headerlink" title="The value floor trench"></a>The value floor trench</h2><ul><li>In <strong>New High CPPI</strong> Strategy: Applying <em>New High CPPI strategy</em> will update the floor when the total portfolio value reaches a new high and the floor value accordingly. Therefore, our increasingly growing floor will help us protect more value when there’s higher value in our portfolio.</li><li>There’s one scenario that could cause this strategy less effective. When your portfolio value grows substantially, your floor value also increased along the way and reached a skyrocket-high number. What if one day the market crashed and the portfolio value dropped way below the floor value, you’ll then need to invest 100% of your asset into bonds/treasuries by the definition of the New High CPPI strategy. It’d take months or even years for the portfolio to recover to above the floor level. By looking at the backtesting result below, we miss the fantastic opportunity to grow our portfolio back to where it was and <em>fall into a floor trench</em>.</li></ul><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/newhigh_cppi.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>New High CPPI ex1: Invest nearly 100% in bonds/treasuries after 2020</i></p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/newhigh_cppi_2.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>New High CPPI ex2: Investment loss will take a long time to recover back to floor level</i></p><h1 id="Let’s-add-some-spices-to-make-the-strategy-promising"><a href="#Let’s-add-some-spices-to-make-the-strategy-promising" class="headerlink" title="Let’s add some spices to make the strategy promising"></a>Let’s add some spices to make the strategy promising</h1><p>Since now we know the basics and pros and cons of the CPPI strategy, let’s add some spice to this strategy to make it more appealing so that traders like you will be more than willing to invest.</p><h2 id="Change-the-meat"><a href="#Change-the-meat" class="headerlink" title="Change the meat"></a>Change the meat</h2><p>As we all know the CPPI strategy can preserve the upward potential and limit the downward loss to a certain degree, why don’t we use the 2x SPY ETF to replace the SPY ETF to gain more upward space? Therefore,</p><ul><li>Risky asset<ul><li>We use <code>SSO</code> which is a <code>2x SPY</code> ETF so that we can exploit the high upward growth possibility.</li></ul></li><li>Risk-free asset<ul><li>We use <code>SHV</code> as it seems to be the more stable among the four risk-free assets we mentioned earlier in this post.</li></ul></li><li>Benchmark<ul><li>We still use <code>SPY</code> to be our benchmark</li></ul></li></ul><h2 id="Add-seasoning"><a href="#Add-seasoning" class="headerlink" title="Add seasoning"></a>Add seasoning</h2><p>As proposed in the article <a href="https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/">Introduction to CPPI – Constant Proportion Portfolio Insurance</a>, we can apply the dynamic multiplier method so that we get to use different multipliers depending on the market volatility instead of picking a fixed number throughout the backtesting period.</p><ul><li>Fixed multiplier<ul><li>We make the multiplier equal to 3 at all times.</li></ul></li><li>Dynamic multiplier<ul><li>We set a few indicators to categorize the regimes of current market volatility<ul><li>$EMA_{21d}$: Exponential moving average of close price in past 21 days</li><li>$SMA_{63d}$: Simple moving average of close price in the past 63 days</li><li>$\overline{EMA_{21d}}$: 126 days average of $EMA_{21d}$</li><li>$\overline{SMA_{63d}}$: 126 days average of $SMA_{63d}$<script type="math/tex; mode=display">\text{Dynamic multiplier} = \left\{\begin{array}\\  4 & \text{if } EMA_{21d} > \overline{EMA_{21d}} \text{ and } SMA_{63d} > \overline{SMA_{63d}} \\  2 & \text{if } EMA_{21d} < \overline{EMA_{21d}} \text{ and } SMA_{63d} < \overline{SMA_{63d}} \\  3 & \mbox{if others } \\\end{array}\right.</script></li></ul></li></ul></li></ul><h2 id="Additional-flavor-Smart-Floor"><a href="#Additional-flavor-Smart-Floor" class="headerlink" title="Additional flavor: Smart Floor"></a>Additional flavor: Smart Floor</h2><p>An idea struck me when I was working on backtesting the scenarios from the article: what if we can build a somewhat flexible/intelligent mechanism that can adjust the floor level based on historic values? The whole process of calculating the floor value has reminded me the process of using <strong>Gradient Descent</strong> to approach the local optima. If you are not familiar with the idea of <strong>Gradient Descent</strong>, check this video out, and it will give you a general idea of what it is and what it is for.</p><p><iframe src="//player.bilibili.com/player.html?aid=678849381&bvid=BV1Mm4y1Z7C4&cid=501387405&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Gradient Descent, Step-by-Step by <a href='https://www.youtube.com/c/joshstarmer'>StatQuest</a></i></p><p>Therefore by borrowing the main idea from the Gradient Descent, we can update our floor value based on the difference between the current total asset value and the total asset value from the previous period. We multiply this difference with the learning rate $\alpha$ and add it to the previous total asset value. Then the base value used for calculating the floor level is now one step closer to the current total asset value. Here’s what the formula looks like:</p><script type="math/tex; mode=display">\begin{align}\text{diff} &= \text{Current AV} - \text{Previous AV}\\\text{Updated Base Value} &= \text{Previous AV} + \text{diff} * \alpha\\\text{Smart Floor} &= \text{Updated Base Value} * \text{Floor Percentage}\\\end{align}</script><script type="math/tex; mode=display">where</script><script type="math/tex; mode=display">AV = \text{Asset Value}</script><script type="math/tex; mode=display">\alpha = \text{Learning Rate}</script><p>To mitigate the impact of trading fee charges, you can also add a buffer when updating the <em>Base Value</em> to make sure you don’t update it too frequently, causing unnecessary loss on the trading fee.</p><h1 id="Backtesting-and-result"><a href="#Backtesting-and-result" class="headerlink" title="Backtesting and result"></a>Backtesting and result</h1><p>Now we have three ways to update our floor value: <code>basic floor</code>, <code>new high floor</code>, <code>smart floor</code>, and two ways to decide our multiplier: <code>fixed multiplier</code> and <code>dynamic multiplier</code>. Including the <code>buy and hold</code> strategy as the benchmark, let’s mashup these conditions and start conducting backtest against each of the scenarios.</p><h2 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h2><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h2 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h2><ul><li>Using <code>SPY</code> as the portfolio benchmark</li><li><code>SHV</code> as risk-free asset</li><li><code>SSO</code> as the risky asset</li></ul><h2 id="Rebalancing-strategy"><a href="#Rebalancing-strategy" class="headerlink" title="Rebalancing strategy"></a>Rebalancing strategy</h2><p>We update the CPPI and floor value every week, and then we adjust the proportion of risky and risk-free assets accordingly.</p><h2 id="Backtest-time-frame"><a href="#Backtest-time-frame" class="headerlink" title="Backtest time frame"></a>Backtest time frame</h2><p>Three time periods we’re going to test against with:</p><ol><li>Full period: <em>2010, 1, 1 - 2022, 11, 1</em><ul><li>To backtest the complete period and evaluate the overall performance</li></ul></li><li>Bear market period: <em>2007, 1, 1 - 2012, 1, 1</em><ul><li>To backtest the bear market scenario and evaluate accordingly</li></ul></li><li>Bull market period: <em>2015, 1, 1 - 2019, 1, 1</em><ul><li>To backtest the slow bull market and evaluate its performance</li></ul></li></ol><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/backtest_period.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Benchmark backtest full period: 2010/01/01 - 2022/11/01</i></p><h2 id="Execution-and-backtest"><a href="#Execution-and-backtest" class="headerlink" title="Execution and backtest"></a>Execution and backtest</h2><p>Here we go!</p><h3 id="Scenarios"><a href="#Scenarios" class="headerlink" title="Scenarios"></a>Scenarios</h3><p>We’re going to run the following backtest scenarios against three time periods:</p><ul><li>SPY, Buy-and-hold</li><li>SSO, Buy-and-hold</li><li>SSO, Basic floor, Fixed Multiplier</li><li>SSO, Basic floor, Dynamic Multiplier</li><li>SSO, Newhigh floor, Fixed Multiplier</li><li>SSO, Newhigh floor, Dynamic Multiplier</li><li>SSO, Learning floor, Fixed Multiplier</li><li>SSO, Learning floor, Dynamic Multiplier</li></ul><h3 id="Backtesting-results"><a href="#Backtesting-results" class="headerlink" title="Backtesting results"></a>Backtesting results</h3><h4 id="Full-period"><a href="#Full-period" class="headerlink" title="Full period"></a>Full period</h4><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/fulltime_backtest.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Backtest full period: 2010/01/01 - 2022/11/01</i></p><p>The backtest results on the right-hand side have the highest max drawdown 59.3% among all scenarios. We can see that the scenarios <code>SSO, Learning floor, Fixed Multiplier</code> and <code>SSO, Learning floor, Dynamic Multiplier</code> both have similar annual returns as the <code>SPY benchmark</code> scenario, but have lower and better MMD and variance. At the first glance, the <code>Smart (learning) floor</code> seems to have a great capability to keep to upward potential and limit the downward risks. Now let’s look at the other two scenarios.</p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/fulltime_chart.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Scatter chart of full period: 2010/01/01 - 2022/11/01</i></p><h4 id="Bear-market-period"><a href="#Bear-market-period" class="headerlink" title="Bear market period"></a>Bear market period</h4><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/bear_backtest.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Backtest bear period: 2007/01/01 - 2012/01/01</i></p><p>It’s very obvious that the scenario <code>SSO, Learning floor, Fixed Multiplier</code> and <code>SSO, Learning floor, Dynamic Multiplier</code> has the highest returns among all the backtests including the benchmark buy-and-hold backtest. The Sharpe ratio, MDD, and annual variance of these two scenarios are also improved compared to the benchmark scenario. Seems <code>CPPI with learning floor</code> does have the capability to limit the downward loss.</p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/bear_chart.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Scatter chart of bear period: 2007/01/01 - 2012/01/01</i></p><h4 id="Bull-market-period"><a href="#Bull-market-period" class="headerlink" title="Bull market period"></a>Bull market period</h4><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/bull_backtest.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Backtest bull period: 2015/01/01 - 2019/01/01</i></p><p>The distribution of the backtests looks similar to the full-time period chart. The three right-most scenarios <code>SSO-buy-and-hold</code>, <code>SSO-basic-fixed</code>, and <code>SSO-basic-dynamic</code> have the highest MDD, which is the outcome that we’re trying to avoid from the beginning. In the meantime, the scenario <code>SSO, Learning floor, Fixed Multiplier</code> and <code>SSO, Learning floor, Dynamic Multiplier</code> still outperform the other scenarios in terms of overall returns and MDD.</p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/bull_chart.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Scatter chart of bull period: 2015/01/01 - 2019/01/01</i></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Here’s my report card of my winning candidate strategy: <code>SSO, learning floor, fixed multiplier</code>:<br><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/my_winning_candidate.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>SSO; Smart Floor; Fixed multiplier</i></p><p>It seems that all the scenarios are able to limit their downside risk due to the fact that we added risk-free assets into our portfolio, achieving the goal to diversify the risk. Even though the returns are diluted, some of the scenarios still show promising outcomes by keeping proportional profit in the book (especially the scenarios using <code>Smart Floor</code>). As for the impact of whether adopting either dynamic multiplier or fixed multiplier is not yet significant, there would be more research needed to make a statistical decision on which method works better than the other.</p><hr><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/">Introduction to CPPI – Constant Proportion Portfolio Insurance</a></li><li><a href="https://wiki.mbalib.com/wiki/%E5%9B%BA%E5%AE%9A%E6%AF%94%E4%BE%8B%E6%8A%95%E8%B5%84%E7%BB%84%E5%90%88%E4%BF%9D%E9%99%A9%E7%AD%96%E7%95%A5">MBA Lib: Constant Proportion Portfolio Insurance Strategy</a></li><li><a href="http://www.scienpress.com/Upload/JFIA/Vol%207_3_2.pdf">Portfolio insurance strategies in a low interest rate environment: A simulation based study</a></li><li><a href="https://medium.com/swlh/protect-your-portfolio-using-cppi-strategy-in-python-c3184c2b6767">If you can’t beat the market at least you can protect from it using Python</a></li></ul><h2 id="Backtest-code"><a href="#Backtest-code" class="headerlink" title="Backtest code"></a>Backtest code</h2><script src='https://www.quantconnect.com/terminal/backtest.js?sid=b67dea595ad0a269ac788f35379b8971'></script>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/11/04/2022-11-10-advanced-cppi-strategy/cover.jpg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
  &lt;i&gt;Photo by &lt;a href=&#39;https://medium.com/r?url=https%3A%2F%2Funsplash.com%2F%40sasun1990%3Futm_source%3Dmedium%26utm_medium%3Dreferral&#39;&gt;Sasun Bughdaryan&lt;/a&gt; on &lt;a href=&#39;https://unsplash.com/?utm_source=medium&amp;utm_medium=referral&#39;&gt;Unsplash&lt;/a&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;We’ve been talking too much about the attack side of quantitative trading, such as momentum, mean reversion, and ML. These strategies aim to outperform the benchmark/index by adding your personal points of view to the trading strategies. Beating the benchmark becomes the only goal when playing the offense. What about defense? After reading &lt;a href=&quot;https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/&quot;&gt;Introduction to CPPI – Constant Proportion Portfolio Insurance&lt;/a&gt;, I started to feel that I can’t agree more with the idea of “The best defense is a good offense” once said by Sun Tzu, a Chinese military general, a strategist, and a philosopher. What does defense mean in the field of quantitative trading? Does defense mean we strive not to lose money and then nothing else worth doing? Maybe talking about the CPPI strategy would give us a better picture of what actually defense means to the traders. Let’s now have a look at how to approach the other side of trading.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Momentum" scheme="http://mikelhsia.github.io/tags/Momentum/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
    <category term="Fundamental Analysis" scheme="http://mikelhsia.github.io/tags/Fundamental-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>【Momentum Trading】Use machine learning to boost your day trading skill - meta-labeling</title>
    <link href="http://mikelhsia.github.io/2022/10/21/2022-10-15-meta-label/"/>
    <id>http://mikelhsia.github.io/2022/10/21/2022-10-15-meta-label/</id>
    <published>2022-10-21T06:59:59.000Z</published>
    <updated>2022-10-22T17:20:35.140Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/10/21/2022-10-15-meta-label/cover.jpeg" class="" width="600"><p>The Triple barrier method and meta-labeling technique were together introduced in the book <strong><em>Advances in Financial Machine Learning</em></strong> by <em>Marcos Lopez De Prado</em>. It seems that the combination of these two tools makes a great pair to either stabilize or further increase your portfolio growth. In this post, I’m going to quote my old research result (<a href="https://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/">here</a>) from last time as the fundamental strategy benchmark, and apply these two techniques to see what beneficial impact we could bring to this strategy.</p><a id="more"></a><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2022/03/18/2022-03-22-supertrend-indicator/">【Momentum Trading】Yes or No? Adopting the Supertrend indicator in your trading strategies?</a></li><li><a href="https://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/">【Momentum Trading】Four strategies of using RSI indicator to better time your market entry</a></li><li><a href="https://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/">【Momentum Trading】Optimize your MACD strategies with advanced indicators</a></li></ul><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>After researching the combination of several technical indicators as buy-in signals, I feel the research framework is missing a robust method to mitigate the subjective impact of the technical indicators. Theoretically speaking, stock prices and other statistics represent the current market overview. Using this information to predict future stock price movements would be irrational. However, standing from the behavioral finance point of view, the historic stock prices and statistics could be used to summarize the standard behavior of general investors’ actions when certain critical points were reached. That’s where the momentum trading strategy begins to thrive. Traders/Investors combine several effective indicators and define the fixed or dynamic threshold to find the group of stocks that possess the momentum (uptrend or downtrend) in them. Then the problem comes back to, how do we define the threshold in a more objective method.</p><p>In the book <strong><em>Advances in Financial Machine Learning</em></strong> by <em>Marcos Lopez De Prado</em>, the Triple barrier method <em>(Chapter 3.4)</em> and the meta-labeling technique <em>(Chapter 3.6)</em> were introduced with his quote <em>“In that case, meta-labeling will help us figure out when we should pursue or dismiss a discretionary PM’s call” (Page 54).</em> These two tools could be adopted and leverage the power of machine learning to mitigate the subjectiveness in the technical-indicator-oriented momentum strategy.</p><p>As usual, I’m not going to introduce these two ideas from ground zero. The article <a href="http://www.sefidian.com/2021/06/26/labeling-financial-data-for-machine-learning/"><em>What is Triple Barrier Method(TBM) and Meta-labeling</em></a> breaks down the definitions of these two terms and attaches the code snippet for easier comprehension. See below for you to understand what they are.</p><h2 id="The-definition-of-the-Triple-Barrier-Method-TBM"><a href="#The-definition-of-the-Triple-Barrier-Method-TBM" class="headerlink" title="The definition of the Triple Barrier Method (TBM)"></a>The definition of the Triple Barrier Method (TBM)</h2><p>TBM adopts two horizontal lines and one vertical line to form a box, which is used for deciding the next move depending on the relative position of the stock price inside the box. There are three potential scenarios would be produced:</p><ul><li>If the upper barrier (profit-take) is hit first. Label “buy” or “1”.</li><li>If the lower barrier (stop-loss) is hit first. Label “sell” or “-1”.</li><li>If the vertical barrier (expiration) is hit first. Label = “return in this period” or “0”.</li></ul><img data-src="/2022/10/21/2022-10-15-meta-label/triple_barrier.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Triple Barrier Method Scenario 3 - hitting the vertical barrier</i></p><img data-src="/2022/10/21/2022-10-15-meta-label/triple_barrier2.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Triple Barrier Method Scenario 1 - hitting the horizontal barrier</i></p><h2 id="The-definition-of-the-meta-Labeling"><a href="#The-definition-of-the-meta-Labeling" class="headerlink" title="The definition of the meta-Labeling"></a>The definition of the meta-Labeling</h2><p>The meta-Labeling sounds like simply an extra label, but it is actually a term that indicates a series of actions for getting the final prediction at the end. <a href="https://www.youtube.com/watch?v=ZCFmZFBtqsQ">This Youtube video</a> by <a href="https://hudsonthames.org/">Hudson &amp; Thames</a> successfully summarizes the core idea of Meta-labeling:</p><blockquote><p><em>Meta-labeling is a machine learning (ML) layer that sits on top of any base primary strategy to help size positions, filter out false-positive signals, and improve metrics such as the Sharpe ratio and maximum drawdown.</em></p></blockquote><p>The steps to implement the meta-labeling can be summarized in the followings:</p><ol><li>Build the primary fundamental model and get the fundamental prediction.</li><li>Use a fixed value to filter the prediction.</li><li>Combine the prediction into your <code>x_train</code> as your new training data.</li><li>Combine the prediction into your <code>y_train</code> to form the new <code>y_train</code> data.</li><li>Construct the secondary model, and use your new <code>x_train</code> and <code>y_train</code> to train your secondary model.</li><li>Feed your <code>test_data</code> into both your primary and secondary model, and produce the predictions respectively.</li><li>Combine the predictions of both the primary and secondary models in order to acquire your final prediction.</li></ol><img data-src="/2022/10/21/2022-10-15-meta-label/meta_label_process.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Meta-Labeling process</i></p><p>You might have questions right now as you just read my <a href="https://mikelhsia.github.io/2022/08/20/2022-08-20-votingclassifier/">previous post</a> and ask <em>“weren’t the Meta-labeling and the ensemble learning referring to the same thing?”</em> The fundamental difference between these two is that ensemble learning (especially the stacking method) solely adds its prediction into the original training set as a new feature. On the other hand, the meta-labeling not only adds its own prediction into the training set, but also modifies the <code>y_label</code> in the training set in accordance with the signal generation logic from the primary model. By having general ideas of what these two are, we can start strategizing how to achieve our goal from zero to one.</p><h1 id="Train-of-thought-from-zero-to-one"><a href="#Train-of-thought-from-zero-to-one" class="headerlink" title="Train of thought - from zero to one"></a>Train of thought - from zero to one</h1><p>To accomplish this backtest, I’ve summarized five steps below to give you a big picture of what we’re going to do:</p><ol><li>Construct our primary model and generate meta label using our primary model</li><li>Use our <strong>modified</strong> Triple-Barrier Method to generate training data for training our secondary model</li><li>Construct the secondary machine learning model</li><li>Train the secondary model</li><li>Execute and place orders with the combined signals.</li></ol><h2 id="1-Construct-our-primary-model"><a href="#1-Construct-our-primary-model" class="headerlink" title="1. Construct our primary model"></a>1. Construct our primary model</h2><p>First of all, we use the strategy left from <a href="https://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/">here</a> and use the buy/sell signals generated from it as the Meta-label. We used MACD, Awesome Oscillator, and RSI indicator to generate our trading (buy/sell) signals. Other than this, we also prepare the following factors for later use:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FEATURES = [</span><br><span class="line">  <span class="string">&#x27;_1d_rtn&#x27;</span>, <span class="string">&#x27;_3d_rtn&#x27;</span>, <span class="string">&#x27;_5d_rtn&#x27;</span>, <span class="string">&#x27;_10d_rtn&#x27;</span>, <span class="string">&#x27;_20d_rtn&#x27;</span>, <span class="string">&#x27;_60d_rtn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;_1d_volume_change&#x27;</span>, <span class="string">&#x27;_3d_volume_change&#x27;</span>, <span class="string">&#x27;_5d_volume_change&#x27;</span>, <span class="string">&#x27;_10d_volume_change&#x27;</span>, <span class="string">&#x27;_20d_volume_change&#x27;</span>, <span class="string">&#x27;_60d_volume_change&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;_macd&#x27;</span>, <span class="string">&#x27;_macd_histo&#x27;</span>, <span class="string">&#x27;_macd_change_3&#x27;</span>, <span class="string">&#x27;_macd_change_5&#x27;</span>, <span class="string">&#x27;_macd_change_10&#x27;</span>, <span class="string">&#x27;_macd_change_15&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;_macd_signal_change_3&#x27;</span>, <span class="string">&#x27;_macd_signal_change_5&#x27;</span>, <span class="string">&#x27;_macd_signal_change_10&#x27;</span>, <span class="string">&#x27;_macd_signal_change_15&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;_macd_histo_change_3&#x27;</span>, <span class="string">&#x27;_macd_histo_change_5&#x27;</span>, <span class="string">&#x27;_macd_histo_change_10&#x27;</span>, <span class="string">&#x27;_macd_histo_change_15&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;_rsi&#x27;</span>, <span class="string">&#x27;_rsi_change_3&#x27;</span>, <span class="string">&#x27;_rsi_change_5&#x27;</span>, <span class="string">&#x27;_rsi_change_10&#x27;</span>, <span class="string">&#x27;_rsi_change_15&#x27;</span>, <span class="string">&#x27;_awesome_oscillator&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Factors to be used in the second machine learning model</i></p><h2 id="2-Modified-Triple-Barrier-Method"><a href="#2-Modified-Triple-Barrier-Method" class="headerlink" title="2. Modified Triple-Barrier Method"></a>2. Modified Triple-Barrier Method</h2><p>In the original Triple-Barrier Method, the difference between the first and second vertical barriers indicates the expiration time that is a fixed number. However, the sell signal generated from our primary model could happen before reaching the expiration time. Secondly, we’re not able to predict the exact time between the buy signal and sell signal as each stock would have its own cycle and price movement velocity. Therefore, we need to slightly twist the definition of <strong>expiration time</strong> in Triple-Barrier Method by defining different expiration times for each stock base on the time between the time of generating the buy signal and the time of generating the sell signal.</p><img data-src="/2022/10/21/2022-10-15-meta-label/modified_triple_barrier.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Modified Triple-Barrier Method using buy/sell signals to form a close period</i></p><p>Since we have defined the expiration time, then we need to resample the original training data into a usable and meaningful format. For example, if we have a time series data that includes ‘price’, ‘1d_rtn’, ‘3d_rtn’, ‘1d_vol’, and ‘3d_vol’ as follows:</p><img data-src="/2022/10/21/2022-10-15-meta-label/data_process_1.png" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Example data - 1</i></p><p>Once we have the original data, now let’s generate the buy and sell signal with it and attach the signals generated to its own row. You can easily mark the row that has one buy signal and one sell signal.<br><img data-src="/2022/10/21/2022-10-15-meta-label/data_process_2.png" class="" width="500"></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Example data - 2</i></p><p>Lastly, just as we will do when resampling the data, we keep all the factors in the row that has buy signal equal to <code>True</code>. We calculate return gain/loss between the buy and sell signals. Then we remove the column ‘price’, ‘buy signal’, and ‘sell signal’. In the end, we will have our training data that is used for training our secondary model.</p><img data-src="/2022/10/21/2022-10-15-meta-label/data_process_3.png" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Example data - 3</i></p><h2 id="3-Construct-our-secondary-machine-learning-model"><a href="#3-Construct-our-secondary-machine-learning-model" class="headerlink" title="3. Construct our secondary machine learning model"></a>3. Construct our secondary machine learning model</h2><p>Here I use the basic neural network machine learning model to predict the winning stocks. There are two hidden layers in the model. Second, we use <code>Leaky ReLU</code> as the activation function of the hidden layers as I want the negative values to be able to update our model weights instead of doing nothing. I found <a href="https://mlfromscratch.com/activation-functions-explained/#/">this post</a> very useful to understand the differences among various activation functions such as GELU, SELU, ELU, ReLU, and Leaky ReLU. Also, since it’s going to be a binary classification to predict whether the trades we made are profitable or not, we’re using <code>binary_crossentropy</code> as our loss function.</p><p>See below for the summary of my neural network setup:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.model = tf.keras.Sequential()</span><br><span class="line">self.model.add(tf.keras.layers.Dense(len(FEATURES), activation=tf.keras.layers.LeakyReLU(alpha=<span class="number">0.01</span>), input_shape=(len(FEATURES), ), name=<span class="string">&quot;dense_1&quot;</span>))</span><br><span class="line">self.model.add(tf.keras.layers.Dropout(<span class="number">0.1</span>),)</span><br><span class="line">self.model.add(tf.keras.layers.Dense(len(FEATURES), activation=tf.keras.layers.LeakyReLU(alpha=<span class="number">0.01</span>), name=<span class="string">&quot;dense_2&quot;</span>))</span><br><span class="line">self.model.add(tf.keras.layers.Dropout(<span class="number">0.1</span>)),</span><br><span class="line">self.model.add(tf.keras.layers.Dense(<span class="number">1</span>, activation=<span class="string">&quot;sigmoid&quot;</span>, name=<span class="string">&quot;predictions&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compile model</span></span><br><span class="line">self.model.compile(</span><br><span class="line">    optimizer=<span class="string">&#x27;Adam&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="4-Training-and-predicting"><a href="#4-Training-and-predicting" class="headerlink" title="4. Training and predicting"></a>4. Training and predicting</h2><p>Since having our training data and our secondary model ready in steps 2 and 3, we are now going to feed the data into our machine-learning model and start training. Before that, do remember that our data is raw and could have many outliers and missing data that could potentially contaminate the results of the prediction. Feature engineering is a must-take step. Here are a few things I did before throwing data into the black box:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrepareData</span>(<span class="params">self, data</span>):</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;Prepares the data for a format friendly for our model&#x27;&#x27;&#x27;</span></span><br><span class="line">  target_column = <span class="string">&#x27;rtn_bin&#x27;</span></span><br><span class="line">  data = self.__LabelYData(data, <span class="string">&#x27;_y_trade_rtn&#x27;</span>, target_column)</span><br><span class="line"></span><br><span class="line">  data_tmp = data.dropna()</span><br><span class="line"></span><br><span class="line">  X_train = data_tmp.loc[:, FEATURES]</span><br><span class="line">  y_train = (data_tmp.loc[:, target_column]).astype(int)</span><br><span class="line"></span><br><span class="line">  X_train = self.__WinsorizeCustom(X_train, FEATURES)</span><br><span class="line">  X_train = self.__LogCustom(X_train, LOGNORMAL_FEATURE)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> X_train, y_train</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__LabelYData</span>(<span class="params">self, df, source=<span class="string">&#x27;_y_trade_rtn&#x27;</span>, rtn_bin=<span class="string">&#x27;rtn_bin&#x27;</span></span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__WinsorizeCustom</span>(<span class="params">self, df, cols: list</span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__LogCustom</span>(<span class="params">self, df, cols: list</span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="4-1-Create-y-label-to-train-our-model"><a href="#4-1-Create-y-label-to-train-our-model" class="headerlink" title="4.1. Create y_label to train our model"></a>4.1. Create y_label to train our model</h3><p>We need our dependent variable, the so-called <code>y label</code>, to train our secondary machine learning model. There are various ways to achieve this. I pick the easiest method to create the <code>y label</code> by assigning <code>True</code> to the stock that its return is greater than <strong>3.0%</strong> after we sell it. You can pick other methods and see which better suits your scenarios and models.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__LabelYData</span>(<span class="params">self, df, source=<span class="string">&#x27;_y_trade_rtn&#x27;</span>, rtn_bin=<span class="string">&#x27;rtn_bin&#x27;</span></span>):</span></span><br><span class="line">  df[rtn_bin] = np.nan</span><br><span class="line"></span><br><span class="line">  df[rtn_bin] = df[source] &gt; <span class="number">0.03</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><h3 id="4-2-Winsorize-the-outliers"><a href="#4-2-Winsorize-the-outliers" class="headerlink" title="4.2. Winsorize the outliers"></a>4.2. Winsorize the outliers</h3><p>Winsorization is the process of replacing the values of outliers with the less impactful smaller values. Here in order to reduce the impact of extreme values, we use the 5 percentile value to replace the extremely small value, and use the 95 percentile value to replace the extremely large value.</p><img data-src="/2022/10/21/2022-10-15-meta-label/winsorize.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Winsorization</i></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__WinsorizeCustom</span>(<span class="params">self, df, cols: list</span>):</span></span><br><span class="line">  <span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">    quantiles = df.loc[:, col].quantile([<span class="number">0.05</span>, <span class="number">0.95</span>])</span><br><span class="line">    q_05 = quantiles.loc[<span class="number">0.05</span>]</span><br><span class="line">    q_95 = quantiles.loc[<span class="number">0.95</span>]</span><br><span class="line"></span><br><span class="line">    df.loc[:, col] = np.where(</span><br><span class="line">      df.loc[:, col].values &lt;= q_05,</span><br><span class="line">      q_05,</span><br><span class="line">      np.where(</span><br><span class="line">        df.loc[:, col].values &gt;= q_95,</span><br><span class="line">        q_95,</span><br><span class="line">        df.loc[:, col].values</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><h3 id="4-3-Transform-our-data-to-the-log-normal-distribution"><a href="#4-3-Transform-our-data-to-the-log-normal-distribution" class="headerlink" title="4.3. Transform our data to the log-normal distribution"></a>4.3. Transform our data to the log-normal distribution</h3><p>It’s a well-known fact in financial machine learning, that having our data normally distributed is the prerequisite of an effective machine learning model. After plotting each of the factors in the histogram, you can easily tell which feature is skewed, then you apply log transform to make it less skewed. One thing that is worth bringing up again, is that some features could contain a <code>0</code> value. Since log 0 doesn’t exist and will return <code>NaN</code>, causing model training to fail, make sure you add <code>1</code> before you log transform the feature values.</p><img data-src="/2022/10/21/2022-10-15-meta-label/log_transform.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Transform the right-skewed distribution to normal distribution</i></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__LogCustom</span>(<span class="params">self, df, cols: list</span>):</span></span><br><span class="line">  <span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">    df.loc[:, col] = np.log(df.loc[:, col] + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><h3 id="4-4-Drop-the-null-data"><a href="#4-4-Drop-the-null-data" class="headerlink" title="4.4. Drop the null data"></a>4.4. Drop the null data</h3><p>Don’t forget to trim the null data. Otherwise, your model is going to fail while training and predicting.</p><h2 id="5-Execute-and-place-orders-with-the-combined-signal"><a href="#5-Execute-and-place-orders-with-the-combined-signal" class="headerlink" title="5. Execute and place orders with the combined signal"></a>5. Execute and place orders with the combined signal</h2><p>Lastly, to summarize, our trading strategy would be that when we receive the signal from the primary model, we send the data on the day as the testing data for predicting with the secondary model. Once the secondary model confirms the signal with the prediction higher than 0.5 possibility to be a winning trade, then we place the buy order. As for selling the stock, we don’t need confirmation from the secondary model. As long as the primary model confirms and generates the sell signal, we sell the related holding stock.</p><h1 id="Backtesting-and-result"><a href="#Backtesting-and-result" class="headerlink" title="Backtesting and result"></a>Backtesting and result</h1><p>Ok. Let’s see what the backtesting results look like following the strategy that we describe above. I will start by describing the backtesting scenarios that we’re going to perform, and then demonstrate the results.</p><h2 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h2><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h2 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h2><ul><li>Sort stocks by <code>PERatio</code>, <code>EPS</code>, <code>ROE</code>, <code>NetIncome</code> and take top 60%</li><li>Sort stocks by <code>PBRatio</code>, from high to low</li><li>Focus on <code>technology</code> industry</li><li>Using QQQ as the portfolio benchmark</li></ul><h2 id="Rebalancing-Strategy"><a href="#Rebalancing-Strategy" class="headerlink" title="Rebalancing Strategy"></a>Rebalancing Strategy</h2><ul><li>Recalculate our universe and indicators to search for the buy and sell signals every day.</li><li>We keep 10 stocks that have buy-in signals and with the highest PBRatio.</li><li>We assign weight to each position evenly.</li><li>We don’t adjust the weight of each stock until we close these positions.</li><li>The secondary model will be re-trained monthly, weekly, and daily.</li></ul><h2 id="Backtest-time-frame"><a href="#Backtest-time-frame" class="headerlink" title="Backtest time frame"></a>Backtest time frame</h2><p>Backtest Date: <code>2018, 12 ,29</code> ~ <code>2022, 09, 24</code></p><h2 id="Execution-and-backtest"><a href="#Execution-and-backtest" class="headerlink" title="Execution and backtest"></a>Execution and backtest</h2><h3 id="Scenarios"><a href="#Scenarios" class="headerlink" title="Scenarios"></a>Scenarios</h3><p>There are two strategies in our arsenal and I’m going to try them out. I’m also going to take the frequency of updating our model into consideration by retraining the model with the up-to-date data every month, week, and day. Therefore, there are going to be six scenarios and two basic scenarios as our benchmark strategy in our backtests.</p><p><strong><em>1. MACD strategy benchmark</em></strong><br><strong><em>2. MACD strategy + Update monthly</em></strong><br><strong><em>3. MACD strategy + Update weekly</em></strong><br><strong><em>4. MACD strategy + Update daily</em></strong><br><strong><em>5. MACD+RSI strategy benchmark</em></strong><br><strong><em>6. MACD+RSI strategy + Update monthly</em></strong><br><strong><em>7. MACD+RSI strategy + Update weekly</em></strong><br><strong><em>8. MACD+RSI strategy + Update daily</em></strong></p><h3 id="Backtesting-results"><a href="#Backtesting-results" class="headerlink" title="Backtesting results"></a>Backtesting results</h3><div class="table-container"><table><thead><tr><th>Strategy</th><th>Total Trades</th><th>PSR</th><th>Unrealized</th><th>Fee</th><th>Return</th><th>Sharpe</th><th>MDD</th><th>Win rate</th><th>Alpha</th><th>Beta</th><th>Annual variance</th></tr></thead><tbody><tr><td>MACD Benchmark</td><td>838</td><td>23.299%</td><td>-$29,616.40</td><td>-$4,091.44</td><td><strong>146.89%</strong></td><td>0.787</td><td>42.300%</td><td><strong>67%</strong></td><td>0.119</td><td>1.053</td><td>0.087</td></tr><tr><td>MACD Monthly</td><td>928</td><td>14.622%</td><td>-$30,950.28</td><td>-$4,372.03</td><td><font color="scarlet">79.55%</font></td><td>0.587</td><td>44.700%</td><td><font color="scarlet">66%</font></td><td>0.038</td><td>1.067</td><td>0.068</td></tr><tr><td>MACD Weekly</td><td>834</td><td>21.410%</td><td>$-25,909.75</td><td>-$3,761.04</td><td><font color="green">150.54%</font></td><td>0.773</td><td>41.200%</td><td><font color="green">68%</font></td><td>0.125</td><td>1.074</td><td>0.096</td></tr><tr><td>MACD Daily</td><td>832</td><td>28.575%</td><td>$-36,755.89</td><td>-$4,177.46</td><td><font color="green">182.07%</font></td><td>0.88</td><td>42.500%</td><td><font color="green">68%</font></td><td>0.154</td><td>1.02</td><td>0.09</td></tr><tr><td>MACD+RSI Benchmark</td><td>1270</td><td>18.732%</td><td>$-14,361.51</td><td>-$6,592.32</td><td><strong>96.85%</strong></td><td>0.665</td><td>43.200%</td><td><strong>58%</strong></td><td>0.063</td><td>1.014</td><td>0.067</td></tr><tr><td>MACD+RSI Monthly</td><td>941</td><td>14.348%</td><td>$-7,308.52</td><td>-$4,382.58</td><td><font color="scarlet">72.05%</font></td><td>0.575</td><td>46.900%</td><td><font color="scarlet">56%</font></td><td>0.036</td><td>0.946</td><td>0.057</td></tr><tr><td>MACD+RSI Weekly</td><td>829</td><td>1.204%</td><td>$-436.44</td><td>-$3,535.95</td><td><font color="scarlet">-7.91%</font></td><td>0.03</td><td>56.000%</td><td><font color="scarlet">54%</font></td><td>-0.077</td><td>0.771</td><td>0.042</td></tr><tr><td>MACD+RSI Daily</td><td>898</td><td>19.534%</td><td>$-7,414.81</td><td>-$4,494.80</td><td><font color="green">92.44%</font></td><td>0.679</td><td>43.000%</td><td><font color="scarlet">56%</font></td><td>0.065</td><td>0.89</td><td>0.056</td></tr></tbody></table></div><h1 id="Beyond-and-next"><a href="#Beyond-and-next" class="headerlink" title="Beyond and next"></a>Beyond and next</h1><p>The purpose of Meta-labeling is not just for correcting the false-positive prediction, but also for raising the F1 score of the model. By adding another machine learning layer beyond the primary non-machine learning model, Meta-labeling enables the capability of processing quantitative fundamental data, technical indicators, and even arbitrary data in a more systematic way. This combines human intuition/experience and the power of machines, enhancing the interpretability and robustness of the model.</p><p>Even though the backtesting results failed to demonstrate the overwhelming power of the meta-labeling, there are still a few other thoughts and ideas to extend our backtesting and to further optimize our Meta-labeling trading algorithm:</p><ul><li>Add company-wise fundamental data into our training data to let our secondary machine learning model know more about the conditions and hence make better decisions.</li><li>In our backtest scenario, we round the prediction result and make it either True or False. That means the threshold is 0.5 that prediction lower than 0.5 would be deemed as a potentially losing trade, and the number above 0.5 would have a higher chance to become a winning trade. One thing we can do is to raise the threshold bar from 0.5 to a higher number to make sure you have an even higher chance to win in this trade. But keep this in mind, it’s going to be a trade-off between the number of trades and you could let the winning opportunities slip through your fingers.</li><li>Find a better method to label your y-label in order to distinguish the stocks that are going to soar or decline. You could either raise the original <strong>3.0%</strong> to a bigger number or mark the top 20% winning stocks so that our y-label will not be restricted to only the winning stocks during the bear market.</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>The book <strong><em>Advances in Financial Machine Learning</em></strong> by <em>Marcos Lopes De Prado</em></li><li><a href="http://www.sefidian.com/2021/06/26/labeling-financial-data-for-machine-learning/">Labeling financial data for Machine Learning</a> by <em>Amir Masoud Sefidian</em></li><li><a href="https://www.youtube.com/watch?v=ZCFmZFBtqsQ">Meta-Labeling: Theory and Framework - Youtube video</a> by <a href="https://hudsonthames.org/"><em>Hudson &amp; Thames</em></a></li></ul><hr><blockquote><p>If you enjoy reading this, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/10/21/2022-10-15-meta-label/cover.jpeg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p&gt;The Triple barrier method and meta-labeling technique were together introduced in the book &lt;strong&gt;&lt;em&gt;Advances in Financial Machine Learning&lt;/em&gt;&lt;/strong&gt; by &lt;em&gt;Marcos Lopez De Prado&lt;/em&gt;. It seems that the combination of these two tools makes a great pair to either stabilize or further increase your portfolio growth. In this post, I’m going to quote my old research result (&lt;a href=&quot;https://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/&quot;&gt;here&lt;/a&gt;) from last time as the fundamental strategy benchmark, and apply these two techniques to see what beneficial impact we could bring to this strategy.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    <category term="Machine Learning" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/Machine-Learning/"/>
    
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>【ML algo trading】 VI - Employ the power of ensemble learning to increase your portfolio return</title>
    <link href="http://mikelhsia.github.io/2022/08/20/2022-08-20-votingclassifier/"/>
    <id>http://mikelhsia.github.io/2022/08/20/2022-08-20-votingclassifier/</id>
    <published>2022-08-20T03:45:58.000Z</published>
    <updated>2022-08-25T02:21:08.673Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/08/20/2022-08-20-votingclassifier/cover.jpg" class="" width="800"><p>When it comes to using machine learning algorithm to pick the stocks that are most likely to produce a good return, it is similar to seeking the opinion of an investment consultant. However, it can be unsettling to make your investment decision after listening to just one consultant. Now is the moment to get second opinions and hire more investment advisors to make sure the investment concept is reliable, doable, and profitable.</p><p>The same principle that you consult other machine learning algorithms to confirm the predictions made by these models are applied in ensemble learning. When you have collected all of the final data from these models, you may take your time relaxing in your nice chair like a big boss, analyzing the results, and making your important and sacred decision.</p><a id="more"></a><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>In the previous articles <a href="https://mikelhsia.github.io/2021/04/22/2021-04-22-machine-learning-intro/">1</a> <a href="https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/">2</a> <a href="https://mikelhsia.github.io/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/">3</a> <a href="https://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/">4</a> and <a href="https://mikelhsia.github.io/2022/06/10/2022-06-10-adcanced-optimization/">5</a>, we have built the machine learning script to predict the winners in the stock market using only the XGBoost model. Nevertheless, there are many algorithms out there for us to try and evaluate. So the most important question for us becomes much more complex. We need to build multiple machine learning models, use <code>GridSearch</code> to find the best hyperparameters, train/fit many different machine learning models, evaluate each model with the same metrics, pick the best-performing model for us to use, and …….</p><img data-src="/2022/08/20/2022-08-20-votingclassifier/or_do_we.png" class="" width="600"><h1 id="How-are-we-going-to-do-this"><a href="#How-are-we-going-to-do-this" class="headerlink" title="How are we going to do this?"></a>How are we going to do this?</h1><h2 id="Ensemble-learning"><a href="#Ensemble-learning" class="headerlink" title="Ensemble learning"></a>Ensemble learning</h2><p>Ensemble learning is a method to combine the predictions from different machine learning models. We gave these machine learning models the name <code>weak learners</code>, as compared to our finalize machine learning model, these <code>weak learners</code> contribute only a part of their efforts to produce the final predictions. By saying that, the ensemble learning model is a more powerful predictor by using a <code>strong learner</code> to assemble the results from many <code>weak learners</code>, so that our final predictor is able to waive the variances from some of the machine learning models and also prevent the overfitting of a singular model. Below is the list of the ensemble learning techniques:</p><img data-src="/2022/08/20/2022-08-20-votingclassifier/ensemble_types.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Different types of ensemble learning techniques</i></p><h2 id="Pause-Let’s-narrow-it-down"><a href="#Pause-Let’s-narrow-it-down" class="headerlink" title="Pause!! Let’s narrow it down"></a>Pause!! Let’s narrow it down</h2><p>Among these ensemble learning techniques, Bagging and Boosting are the most commonly known techniques. They are even used in the modern machine learning algorithm such as the Adaboost model or the XGBoost model that we used in our previous articles. However, to cover all these techniques would probably bore you to death. Therefore, we’re going to introduce two techniques in this article, <strong>Average Voting</strong> and <strong>Stacking</strong>. Also, as explaining the basic theory is not my strength, I’ll put less effort into explaining and more effort into describing the details of the backtests and coding details.</p><h3 id="Average-Voting"><a href="#Average-Voting" class="headerlink" title="Average Voting"></a>Average Voting</h3><p>As the name implies, average voting is to average the predicted scores/probabilities from your <code>weak learners</code> and output the final scores/probabilities. For example, you have three <code>weak learners</code> classifier models trained and produced the final predicted probabilities of getting the positive return tomorrow.</p><div class="table-container"><table><thead><tr><th>Classifier Model</th><th>Stock 1</th><th>Stock 2</th><th>Stock 3</th></tr></thead><tbody><tr><td>A</td><td>0.9</td><td>0.9</td><td>0.7</td></tr><tr><td>B</td><td>0.7</td><td>0.3</td><td>0.7</td></tr><tr><td>C</td><td>0.6</td><td>0.7</td><td>0.7</td></tr><tr><td><strong>Averaged possibility</strong></td><td><strong>0.73</strong></td><td><strong>0.63</strong></td><td><strong>0.7</strong></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Possibilities of getting the positive return tomorrow (Soft voting)</i></p><p>If we look at models A, B, and C respectively, we probably end up buying Stock 2 as it has a relatively high probability to receive a positive return from models A and C. After employing the average voting technique, the probability of Stock 2 now drops to 66% and Stock 1 probability would top Stock 2, indicating that Stock 1 would actually have a higher probability to receive a positive return than the other two stocks. This is so-called <strong>Soft Voting</strong>.</p><p>There is also <strong>Hard Voting</strong>, which takes binary inputs, True or False, into account instead of the probabilities. Taking the same example as above, we add one more condition that the output would be 1 (True) only when the possibility is over 0.7. The final result would be quite different.</p><div class="table-container"><table><thead><tr><th>Classifier Model</th><th>Stock 1</th><th>Stock 2</th><th>Stock 3</th></tr></thead><tbody><tr><td>A</td><td>0.9 (1)</td><td>0.9 (1)</td><td>0.7 (1)</td></tr><tr><td>B</td><td>0.7 (1)</td><td>0.3 (0)</td><td>0.7 (1)</td></tr><tr><td>C</td><td>0.6 (0)</td><td>0.7 (1)</td><td>0.7 (1)</td></tr><tr><td><strong>Voter</strong></td><td><strong>2 Positives &amp; 1 Negative</strong></td><td><strong>2 Positives &amp; 1 Negative</strong></td><td><strong><em>3 Positives</em></strong></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Possibilities of getting the positive return tomorrow (Hard voting)</i></p><p>By looking at the total number of the voters who vote positive, the final winner would be Stock 3 as it has 3 people who think it’s going to receive a positive return tomorrow. Therefore the <strong>Hard Voting</strong> would recommend Stock 3, yet the <strong>Soft Voting</strong> would recommend Stock 2. The concept is quite straightforward, but this technique does help the model to mitigate the impact of the high variance of one single model.</p><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><p>Other than average voting, <strong>Stacking</strong> processes the predictions from the <code>weak learners</code> in a more advanced way. <strong>Stacking</strong> treats the outputs of its <code>weak learners</code> as features and stacks them together into secondary training data. The secondary training data will be used as the inputs for the final estimator (a.k.a. meta-model), and then computes the final prediction.</p><img data-src="/2022/08/20/2022-08-20-votingclassifier/stacking.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Stacking technique illustration</i></p><p>As illustrated above, classification models A, B, and C use the same training data to train the model and then produce predictions A, predictions B, and predictions C. The final estimator treats these predictions as new features to compute the final prediction.</p><h1 id="Walk-through-the-strategies"><a href="#Walk-through-the-strategies" class="headerlink" title="Walk through the strategies"></a>Walk through the strategies</h1><p>We now have the general idea of these two ensemble learning techniques, let’s move on to the backtest so that we can understand the power of ensemble learning. In this series of backtests, we are going to use the same dataset to train 1. XGBoost, 2. LogisticRegression, 3. SVM, and 4. Deep Learning with 2 layers of hidden layers. After conducting the backtests using these models respectively, we will combine these models together and apply <strong>Average Voting</strong> and <strong>Stacking</strong> techniques respectively to see whether the performances are improved or not.</p><h2 id="Universe-and-training-data"><a href="#Universe-and-training-data" class="headerlink" title="Universe and training data"></a>Universe and training data</h2><p>I’m still using <code>ZZ500</code> as our universe and the same set of features as the training data. If you are interested in knowing how to define the universe and what features I’ve been using, you can check out my previous articles regarding machine learning and factor analysis.</p><h2 id="Backtest-timeframe"><a href="#Backtest-timeframe" class="headerlink" title="Backtest timeframe"></a>Backtest timeframe</h2><p>My backtest timeframe is from <code>2020-04 ~ 2022-07</code>. For each month, I would need 60 months’ data as the training data to train the model. Therefore, it would require 27 (validation data) + 60 (training data) = 87 months = ~ 8 years of stock data.</p><h2 id="Backtest-scenarios"><a href="#Backtest-scenarios" class="headerlink" title="Backtest scenarios"></a>Backtest scenarios</h2><p>Here are the four models that I employed in this backtest. Again, I’m not the professor of the machine learning algorithm that can turn you into a machine learning expert with what I know. Instead, I’m going to put some quick descriptions and the materials that help me understand the basics of these ML models.</p><p><strong><em>1. XGBoost</em></strong><br>This is the decision-tree-base model that I’ve been using since the first article. The advantage of this algorithm is it’s <strong><em>extremely fast</em></strong>. This model took 1/5 of the time to train compared to other models. Below are the <a href="https://www.youtube.com/c/joshstarmer/videos">StatQuest</a> videos that help me to understand what XGBoost is about:</p><ul><li><a href="https://www.youtube.com/watch?v=3CC4N4z3GJc">Gradient Boost Part 1 (of 4): Regression Main Ideas</a></li><li><a href="https://www.youtube.com/watch?v=2xudPOBz-vs">Gradient Boost Part 2 (of 4): Regression Details</a></li><li><a href="https://www.youtube.com/watch?v=jxuNLH5dXCs">Gradient Boost Part 3 (of 4): Classification</a></li><li><a href="https://www.youtube.com/watch?v=StWY5QWMXCw">Gradient Boost Part 4 (of 4): Classification Details</a></li><li><a href="https://www.youtube.com/watch?v=OtD8wVaFm6E&amp;t=12s">XGBoost Part 1 (of 4): Regression</a></li><li><a href="https://www.youtube.com/watch?v=8b1JEDvenQU&amp;t=1153s">XGBoost Part 2 (of 4): Classification</a></li><li><a href="https://www.youtube.com/watch?v=ZVFeW798-2I">XGBoost Part 3 (of 4): Mathematical Details</a></li><li><a href="https://www.youtube.com/watch?v=oRrKeUCEbq8">XGBoost Part 4 (of 4): Crazy Cool Optimizations</a></li></ul><p><strong><em>2. LogisticRegression</em></strong><br>Logistic Regression is very much like the Linear regression that I talked about in <a href="https://mikelhsia.github.io/2021/01/31/2021-01-31-factor-analysis/">【Factor analysis】 Vol. 1. Introduction the idea of factor analysis</a>. It uses various ordinal features to predict the probability of whether a thing will happen or not. To transform the probability into a Boolean value that stands for whether a certain incidence will happen or not, an activation function (such as Sigmoid or Softmax) will be applied. Here are the materials for you to know more about logistic regression:</p><ul><li><a href="https://www.youtube.com/watch?v=yIYKR4sgzI8">StatQuest: Logistic Regression</a></li><li><a href="https://www.youtube.com/watch?v=vN5cNN2-HWE">Logistic Regression Details Pt1: Coefficients</a></li><li><a href="https://www.youtube.com/watch?v=BfKanl1aSG0">Logistic Regression Details Pt 2: Maximum Likelihood</a></li><li><a href="https://www.youtube.com/watch?v=M59JElEPgIg&amp;t=355s">The SoftMax Derivative, Step-by-Step!!!</a></li></ul><p><strong><em>3. SVM</em></strong><br>I have introduced the concept of SVM <a href="https://mikelhsia.github.io/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/">here</a>. SVM is a variant of logistic regression. Instead of finding the exact line to separate all the 0’s and the 1’s, we include an extra hyperplane into the model. We hope that by adding this hyperplane,  we will be able to clearly separate the data into different groups. The method for inserting this hyperplane is referred to as a ‘kernel.’</p><ul><li><a href="https://www.youtube.com/watch?v=efR1C6CvhmE">Support Vector Machines Part 1 (of 3): Main Ideas!!!</a></li><li><a href="https://www.youtube.com/watch?v=Toet3EiSFcM">Support Vector Machines Part 2: The Polynomial Kernel (Part 2 of 3)</a></li><li><a href="https://www.youtube.com/watch?v=Qc5IyLW_hns">Support Vector Machines Part 3: The Radial (RBF) Kernel (Part 3 of 3)</a></li></ul><p><strong><em>4. Neural Networks</em></strong><br>The neural network is a type of deep learning algorithm. It uses numerous nodes to simulate the neuron in a neural system of a person, that each neuron makes individual solution and combine these solutions to make the final solution. Below are the related articles to talk about the NN model:</p><ul><li><a href="https://www.TensorFlow.org/guide">TensorFlow Guide</a></li><li><a href="https://www.youtube.com/watch?v=L35fFDpwIM4">Tensors for Neural Networks, Clearly Explained!!!</a></li><li><a href="https://www.youtube.com/watch?v=CqOfi41LfDw&amp;t=34s">Neural Networks Pt. 1: Inside the Black Box</a></li><li><a href="https://www.youtube.com/watch?v=IN2XmBhILt4">Neural Networks Pt. 2: Backpropagation Main Ideas</a></li><li><a href="https://www.youtube.com/watch?v=68BZ5f7P94E">Neural Networks Pt. 3: ReLU In Action!!!</a></li><li><a href="https://www.youtube.com/watch?v=83LYR-1IcjA">Neural Networks Pt. 4: Multiple Inputs and Outputs</a></li><li><a href="https://www.youtube.com/watch?v=KpKog-L9veg">Neural Networks Part 5: ArgMax and SoftMax</a></li><li><a href="https://www.youtube.com/watch?v=6ArSys5qHAU">Neural Networks Part 6: Cross Entropy</a></li><li><a href="https://www.youtube.com/watch?v=xBEh66V9gZo">Neural Networks Part 7: Cross Entropy Derivatives and Backpropagation</a></li><li><a href="https://www.youtube.com/watch?v=HGwBXDKFk9I">Neural Networks Part 8: Image Classification with Convolutional Neural Networks (CNNs)</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span>():</span></span><br><span class="line">  model = tf.keras.Sequential()</span><br><span class="line">  model.add(tf.keras.layers.Dense(<span class="number">256</span>, activation=<span class="string">&quot;relu&quot;</span>, input_shape=(<span class="number">179</span>, ), name=<span class="string">&quot;dense_1&quot;</span>))</span><br><span class="line">  model.add(tf.keras.layers.Dropout(<span class="number">0.1</span>),)</span><br><span class="line">  model.add(tf.keras.layers.Dense(<span class="number">256</span>, activation=<span class="string">&quot;relu&quot;</span>, name=<span class="string">&quot;dense_2&quot;</span>))</span><br><span class="line">  model.add(tf.keras.layers.Dropout(<span class="number">0.1</span>)),</span><br><span class="line">  model.add(tf.keras.layers.Dense(<span class="number">1</span>, activation=<span class="string">&quot;sigmoid&quot;</span>, name=<span class="string">&quot;predictions&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Compile model</span></span><br><span class="line">  model.compile(</span><br><span class="line">    optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">    metrics=[</span><br><span class="line">      tf.keras.metrics.AUC(),</span><br><span class="line">      tf.keras.metrics.BinaryAccuracy(),</span><br><span class="line">    ],</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p style="text-align:center; color: grey;">  <i>My neural network model set up</i></p><p><strong><em>5. Average Voting Algorithm</em></strong><br>As previously explained, <strong>Average Voting</strong> essentially averages out the predicted scores/possibilities participated in machine learning models. Therefore, it’s relatively easy to implement the average voting model by putting your model into a list as an <code>estimator</code> parameter. The tricky part is, that the TensorFlow library that the neural network model uses is originally developed by <em>Google</em>, and the scikit-learn library that built the <code>VotingClassifier</code> is not. These two models are not naturally compatible and your neural network model can’t be tucked into the <code>estimator</code> parameter directly. Fortunately, TensorFlow also provides the function to wrap our NN model into a format that the scikit-learn library can understand. Hence, remember to wrap your NN model before you start building your <strong>Average Voting Algorithm</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TensorFlow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">nn_model = tf.keras.wrappers.scikit_learn.KerasClassifier(</span><br><span class="line">    build_fn=get_model,</span><br><span class="line">    epochs=<span class="number">40</span>,</span><br><span class="line">    verbose=<span class="literal">False</span>,</span><br><span class="line">)</span><br><span class="line">nn_model._estimator_type = <span class="string">&#x27;classifier&#x27;</span></span><br><span class="line"></span><br><span class="line">scaled_nn_model = make_pipeline(</span><br><span class="line">    RobustScaler(),</span><br><span class="line">    nn_model</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p style="text-align:center; color: grey;">  <i>Use `tf.keras.wrapper.scikit_learn` to wrap our NN model</i></p><p>Once you have your models ready, you simply need to put them together into a list and add the wrapper to the <code>VotingClassifier</code> function. Here we use <code>voting=&#39;soft&#39;</code> to smooth the variance of the model predictions.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate the VotingClassifier class</span></span><br><span class="line">voting_model = VotingClassifier(estimators=[</span><br><span class="line">    (<span class="string">&#x27;xgboost_model&#x27;</span>, xgb_model),</span><br><span class="line">    (<span class="string">&#x27;scaled_lr&#x27;</span>, scaled_lr_model),</span><br><span class="line">    (<span class="string">&#x27;scaled_svm&#x27;</span>, scaled_svm_model),</span><br><span class="line">    (<span class="string">&#x27;scaled_nn&#x27;</span>, scaled_nn_model),</span><br><span class="line">  ],</span><br><span class="line">  voting=<span class="string">&#x27;soft&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train the voting model</span></span><br><span class="line">voting_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the prediction</span></span><br><span class="line">y_predict = voting_model.predict(X_test)</span><br></pre></td></tr></table></figure><p style="text-align:center; color: grey;">  <i>VotingClassifier basic instruction</i></p><p><strong><em>6. Stacking</em></strong><br>In our <strong>StackingClassifier</strong>, we use the XGBoost model,  the Support Vector Machine model, and Neural Network models as our base estimators. As for the final estimator to produce the final prediction, we use the Logistic Regression model with the parameters needed. Once the model is instantiated, we can use this instance as the rest of scikit-learn model to <code>fit</code> and to <code>predict</code>. Make sure you include the hyperparameters before you build your base learner models.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> StackingClassifier</span><br><span class="line">base_learners = [</span><br><span class="line">  (<span class="string">&#x27;xgboost_model&#x27;</span>, xgb_model),</span><br><span class="line">  (<span class="string">&#x27;scaled_svm&#x27;</span>, scaled_svm_model),</span><br><span class="line">  (<span class="string">&#x27;scaled_nn&#x27;</span>, scaled_nn_model),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">model = StackingClassifier(</span><br><span class="line">  estimators=base_learners,</span><br><span class="line">  final_estimator=LogisticRegression()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_predict = model.predict(X_test)</span><br></pre></td></tr></table></figure><p style="text-align:center; color: grey;">  <i>Basic set up of StackingClassifier</i></p><h2 id="Backtest-results"><a href="#Backtest-results" class="headerlink" title="Backtest results"></a>Backtest results</h2><h3 id="Backtest-results-summary"><a href="#Backtest-results-summary" class="headerlink" title="Backtest results summary"></a>Backtest results summary</h3><img data-src="/2022/08/20/2022-08-20-votingclassifier/backtest_results.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Backtest results summary</i></p><p>Even though the annual returns of both VotingClassifier and StackingClassifier are not higher than the other machine learning model, the Sharpe Ratio and the Maximum Drawdown are relatively lower. The win rate of the VotingClassifier scenario even increases to 61%, indicating our model is more powerful in its predictability to pick the stocks that are more possible to gain positive returns. To gain a more intuitive sense of how the ensemble learning method impacts our model, let’s look at the stratified and the return diagrams.</p><div class="table-container"><table><thead><tr><th>Scenario</th><th>Stratified Diagram</th><th>Return Diagram</th></tr></thead><tbody><tr><td>XGBoost</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/1-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/1-return.png" class="" width="300"></td></tr><tr><td>Logistic Regression</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/2-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/2-return.png" class="" width="300"></td></tr><tr><td>SVM</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/3-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/3-return.png" class="" width="300"></td></tr><tr><td>Neural Network</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/4-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/4-return.png" class="" width="300"></td></tr><tr><td>Average Voting</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/5-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/5-return.png" class="" width="300"></td></tr><tr><td>Stacking</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/6-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/6-return.png" class="" width="300"></td></tr></tbody></table></div><p>It’s quite clear that our ensemble learning methods (<strong><em>Average Voting</em></strong> and <strong><em>Stacking</em></strong>) less fluctuate than the rest of the models. By comparing the same bear market period from <code>2022-02</code>~<code>2022-04</code>, our loss appears a lot less than the non-ensemble learning methods.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>For the <strong><em>Average Voting</em></strong> ensemble learning method, it seems to produce a better result and improve the predictability of our model. However, there are a lot fewer places we can step in to better fine-tune the model. On the contrary, there is much more room for us to find out the best combination of the base estimators when we look at the <strong><em>Stacking</em></strong> ensemble learning method. Hence, one thing we can try is using the result from <strong><em>Average Voting</em></strong> as a benchmark and using <strong><em>Stacking</em></strong> as a tool to see whether we can build a much more powerful model to better predict the market.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://neptune.ai/blog/ensemble-learning-guide">A Comprehensive Guide to Ensemble Learning: What Exactly Do You Need to Know?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/08/20/2022-08-20-votingclassifier/cover.jpg&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;p&gt;When it comes to using machine learning algorithm to pick the stocks that are most likely to produce a good return, it is similar to seeking the opinion of an investment consultant. However, it can be unsettling to make your investment decision after listening to just one consultant. Now is the moment to get second opinions and hire more investment advisors to make sure the investment concept is reliable, doable, and profitable.&lt;/p&gt;
&lt;p&gt;The same principle that you consult other machine learning algorithms to confirm the predictions made by these models are applied in ensemble learning. When you have collected all of the final data from these models, you may take your time relaxing in your nice chair like a big boss, analyzing the results, and making your important and sacred decision.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    <category term="Machine Learning" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/Machine-Learning/"/>
    
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>【ML algo trading】 V - Raise your trading win rate through feature engineering</title>
    <link href="http://mikelhsia.github.io/2022/06/10/2022-06-10-adcanced-optimization/"/>
    <id>http://mikelhsia.github.io/2022/06/10/2022-06-10-adcanced-optimization/</id>
    <published>2022-06-10T08:21:42.000Z</published>
    <updated>2022-08-24T18:00:02.298Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/06/10/2022-06-10-adcanced-optimization/cover.jpeg" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Photo by <a href="https://medium.com/r?url=https%3A%2F%2Funsplash.com%2F%40brett_jordan%3Futm_source%3Dmedium%26utm_medium%3Dreferral">Brett Jordan</a> on <a href="https://medium.com/r/?url=https%3A%2F%2Funsplash.com%3Futm_source%3Dmedium%26utm_medium%3Dreferral">Unsplash</a></i></p><p>From the <a href="https://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/">previous article</a>, we’ve learned several indicators that we can calculate and use to evaluate the performances of your algorithm trading strategies. Given these indicators, we’re able to see how we can further polish our strategy and make it more seemingly profitable. Therefore, let’s work on our features to see how we can improve our machine learning trading strategy.</p><a id="more"></a><p>There are a few feature engineering techniques that we’re going to use in this series of backtests and it is beneficial to get a big picture of how to apply these techniques. I’m not going to go through these techniques in detail as there are too many capable persons who have done so. Therefore, I’ll be only focusing on backtesting the trading strategies using these techniques and how they can impact the performance of the strategy.</p><ul><li><a href="https://www.geeksforgeeks.org/feature-encoding-techniques-machine-learning/">Encoding</a></li><li><a href="https://towardsdatascience.com/6-different-ways-to-compensate-for-missing-values-data-imputation-with-examples-6022d9ca0779">Imputing</a></li><li><a href="https://towardsdatascience.com/a-data-scientists-practical-guide-to-using-kmeans-ff180878e13b">Kmean</a></li></ul><p>Also, I’m using the algorithm trading script that I built from my previous articles below. So we don’t need to build everything from the scratch.</p><blockquote><p><strong>Previous articles</strong></p><ul><li><a href="https://mikelhsia.github.io/2021/04/22/2021-04-22-machine-learning-intro/">【Machine Learning】 Part I - 10 minutes to learn what I know about machine learning in quantitative trading</a></li><li><a href="https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/">【Machine Learning】 Part II - How to build a machine learning boilerplate?</a></li><li><a href="https://mikelhsia.github.io/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/">【Machine Learning】 Part III - 5 myths about practicing quant trading with machine learning</a></li><li><a href="https://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/">【Machine Learning】 Part IV - How to analyze how good my machine learning strategy is?</a></li></ul></blockquote><h1 id="Train-of-thought"><a href="#Train-of-thought" class="headerlink" title="Train of thought"></a>Train of thought</h1><p>There are three scenarios that we’re going to use as the benchmark performances:</p><ol><li>Using XGBoost as ML model and 30-month data as training data</li><li>Using XGBoost as ML model and 60-month data as training data</li><li>Using AdaBoost as ML model and 60-month data as training data</li></ol><p>Here’s a quick but complete <a href="https://towardsdatascience.com/the-ultimate-guide-to-adaboost-random-forests-and-xgboost-7f9327061c4f">guide</a> to both XGBoost and AdaBoost. XGBoost is famous for its speed of processing and high accuracy. On the other hand, AdaBoost is slower than XGBoost, but is capable of mitigating the chances of overfitting. So we will adopt both of these models to reach a justifiable performance evaluation.</p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/summary.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Stats benchmark summary of three scenarios</i></p><div class="table-container"><table><thead><tr><th>XGBoost, 30 months</th><th>XGBoost, 60 months</th><th>AdaBoost, 60 months</th></tr></thead><tbody><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario1_benchmark.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario2_benchmark.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario3_benchmark.png" class="" width="200"></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Stratified plotting of base scenarios return by probability to win</i></p><p>From the above table and charts, <strong>XGBoost with a 30-month data</strong> scenario is apparently the most lucrative scenario, and the scenario of using <strong>AdaBoost with 60-month data</strong> seems to work poorly compared to other scenarios. Now let’s first look at what could bring by adding <code>industry</code> feature to our feature set.</p><h2 id="Adding-industry-feature-Encoding"><a href="#Adding-industry-feature-Encoding" class="headerlink" title="Adding industry feature - Encoding"></a>Adding <code>industry</code> feature - Encoding</h2><h3 id="Why-adding-industry-feature"><a href="#Why-adding-industry-feature" class="headerlink" title="Why adding industry feature"></a>Why adding <code>industry</code> feature</h3><p>It’s a well-known fact that stocks in the same industry have similar wax and wane due to the reason that they are running a similar business, using similar materials, producing similar products, and providing similar services. It’s a common belief that this cyclical characteristic of stocks needs to be factored into our machine learning prediction model in order to reflect this phenomenon.</p><p><code>industry</code> feature contains string-like data such as ‘Technology’, ‘Utilities’, or ‘Manufacturing’. However, both XGBoost and AdaBoost are tree-based classifiers that only accept ordinal numbers as features in training data. Therefore, we need to transform these string-like data into numbers so that our classifiers can understand the data.</p><h3 id="One-hot-encoding"><a href="#One-hot-encoding" class="headerlink" title="One-hot encoding"></a>One-hot encoding</h3><p>The technique to transform string-like data into ordinal data is called <strong>encoding</strong>. Typically we apply <strong>Label Encoding</strong>, in which we use one number to label one string in the <code>Industry</code> column. One implicit drawback of it is that <strong>Label Encoding</strong> might suggest that the bigger number is more important than the smaller number. Taking the below table as an example, is <code>&#123;&#39;Electric&#39; = 4&#125;</code> really more important than <code>&#123;&#39;Technology&#39; = 1&#125;</code> in the transformed training data set?</p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/wrong_encoding.png" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Label encoding doesn't work in this case</i></p><p>Here’s where <strong>One-hot Encoding</strong> comes into play. <strong>One-hot Encoding</strong> is a labeling technique that essentially uses one full column to present one single value in the original <code>Industry</code> column. The transformed data would have <em>N</em> new columns when there is <em>N</em> unique value in the <code>Industry</code> column. By doing this, we can remove the ordinal implication from <strong>Label Encoding</strong>.</p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/right_encoding.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>One-hot encoding transformation</i></p><h3 id="Backtest-results"><a href="#Backtest-results" class="headerlink" title="Backtest results"></a>Backtest results</h3><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/one_hot_summary.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i> Performance summary of three base scenarios with one-hot transformed industry feature</i></p><div class="table-container"><table><thead><tr><th>XGBoost, 30 months</th><th>XGBoost, 60 months</th><th>AdaBoost, 60 months</th></tr></thead><tbody><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario1_benchmark.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario2_benchmark.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario3_benchmark.png" class="" width="200"></td></tr><tr><td><div style="text-align: center;">One-hot encoded</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">One-hot encoded</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">One-hot encoded</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td></tr><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/30_one_hot.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/60_one_hot.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/60_ada_one_hot.png" class="" width="200"></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Stratified plotting of one-hot encoded enhanced scenario returns by probability to win</i></p><p>The performance of the two scenarios using XGBoost actually improved quite a bit in terms of the portfolio return, win rate, and even the Machine Learning score like F1, AUC, and MCC. These backtest results possibly suggest that accounting <code>industry</code> feature into our machine learning model does help generate a better-trained model.</p><h2 id="Dealing-with-missing-data-NA-Imputer"><a href="#Dealing-with-missing-data-NA-Imputer" class="headerlink" title="Dealing with missing data (NA) - Imputer"></a>Dealing with missing data (NA) - Imputer</h2><p>Previously in the post <a href="https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/">【Machine Learning】 Part II - How to build a machine learning boilerplate?</a>, the way we deal with the missing data is to drop all of them to avoid adding human-biased data. This is actually a luxury move for data scientists as the amount of the data is usually quite limited. If we can gently cast some fairy dust and revive those dumped data, the amount of data could be doubled or even tripled, and then train our model to be more accurate.</p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/fairy_dust.png" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><h3 id="Imputer-What-is-it"><a href="#Imputer-What-is-it" class="headerlink" title="Imputer? What is it?"></a>Imputer? What is it?</h3><p>Imputer is a word actually found in <code>sklearn</code> machine learning python package, and the meaning of the word hardly tells me what it does. Imputer in <code>sklearn</code> is a sub-package to fill the missing data in various ways. There are <strong>SimpleImputer</strong> that fills the missing data with the mean of all the numbers, <strong>KNNImputer</strong> that separate data into different groups and fills the missing data with the mean of numbers in the same group, and also <strong>IterativeImputer</strong> that fills the missing data by estimation instead of the mean. In this post, <strong>SimpleImputer</strong> would be the tool that we’re using to fill the missing data.</p><h3 id="Three-scenarios-to-fill-the-missing-data"><a href="#Three-scenarios-to-fill-the-missing-data" class="headerlink" title="Three scenarios to fill the missing data"></a>Three scenarios to fill the missing data</h3><p>Even though we’re using the simple <strong>SimpleImputer</strong>, there are still ways we can fill the missing data in a more sensible way.</p><ul><li>Drop all the columns that have missing data<ul><li>This is the original method how we deal with the missing data in our machine learning model. The missing data is dropped instead of filling any arbitrary number so that we don’t add any personal bias to the dataset.</li></ul></li><li>Fill all the data by column<ul><li>We fill every the missing data together so that all the missing numbers of the same feature will be filled in the mean of all available numbers.</li></ul></li><li>Fill the missing data by symbol<ul><li>In our training data, we have features such as company quarterly sales, gross profit, and cash/debt ratio(refer to <a href="https://mikelhsia.github.io/2021/02/23/2021-02-11-factor-analysis-3/">Factor analysis Part III</a>). These company-specific fundamental numbers can be very different from one company to another due to the nature of the industry or company itself. For example, company A quarterly sales are 1M, 1.5M, 2M in Q1, Q2, and Q3 respectively. On the other hand, the quarterly sales of company B could be 20B in Q1, 21B in Q2, but Q3 data is missing. It won’t make any sense if we fill the missing Q3 of company B with the mean of (1M, 1.5M, 2M, 20B, 21B), right? That’s why it is better we fill the missing data according to the existing data of the company itself.</li></ul></li></ul><h3 id="Backtest-results-1"><a href="#Backtest-results-1" class="headerlink" title="Backtest results"></a>Backtest results</h3><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/impute_summary.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i> Performance summary of three base scenarios with imputed data</i></p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/impute0.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>XGBoost, 30-month data performance stratified plot</i></p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/impute1.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>XGBoost, 60-month data performance stratified plot</i></p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/impute2.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>AdaBoost, 60-month data performance stratified plot</i></p><p>From the first summary table, it’s quite clear that the performances of the data-imputed scenarios are worse than the performance of the drop-missing-data scenario. Not only the annual return dropped 20~30%, and also the win rate, MDD, MCC score, and other figures drop significantly compared to the benchmark scenario. Then we move on to the stratified plot of our three base scenarios. Either the fill-everything scenario or the fill-missing-data-by-company scenario has greatly contributed to the ability to effectively separate the most probable winning group (group 1, red line) from the other groups. We might now be able to extract and form our preliminary conclusion that <code>&quot;SimpleImputer&quot; might not work in these scenarios but add more noises to the model, further decreasing the precision and accuracy of our model.</code> You can also try out the <strong>KNNImputer</strong> or <strong>IterativeImputer</strong> to see whether can achieve a better outcome.</p><h2 id="Combine-features-gt-Kmean"><a href="#Combine-features-gt-Kmean" class="headerlink" title="Combine features -&gt; Kmean"></a>Combine features -&gt; Kmean</h2><h3 id="What-is-Kmean-and-how-to-decide-“K”"><a href="#What-is-Kmean-and-how-to-decide-“K”" class="headerlink" title="What is Kmean and how to decide “K”"></a>What is Kmean and how to decide “K”</h3><p><a href="https://en.wikipedia.org/wiki/K-means_clustering">K-mean</a> is a method/technique that aims to cluster all the data into <em>K</em> groups by analyzing the given features. I’m not going to go through the details and how to conduct your own k-mean clustering, as there are so many people doing so on <a href="https://medium.com/">medium</a> and other ML platforms. I’m only going to reveal and illustrate the backtest outcomes to you.</p><p> What’s the benefit of conducting k-mean clustering? In the financial ML model, there are so many fundamental data such as sales, gross profit, and cash-to-debt ratio of every individual company. However, it’s a bit too complicated to take all these fundamental figures into account while training our ML model. Therefore, instead of using these fundamental figures as they were, it would be easier, more meaningful, and more effective if we can categorize them into several groups before we feed the data into the machine learning model.</p><h3 id="Combining-features"><a href="#Combining-features" class="headerlink" title="Combining features"></a>Combining features</h3><p>Let’s take the example that we used in our backtest, that we combine features <code>ROA</code>, <code>asset turnover</code>, <code>Sharpe ratio since the last 20 days</code>, and <code>Sharpe ratio since the last 60 days</code>. Instead of feeding these figures right into the machine learning model, we use the k-mean clustering method to categorize them into <em>K</em> groups and name the group feature <code>profitability_of_the_company</code>. Wouldn’t that make more sense for the model to know how profitable the company is rather than knowing the fundamental figures of the company? But remember, that the ordinal number is not suitable for the category type of data. Make sure you use <strong>One-hot encoding</strong> to separate the profitability type into features so that you’ll be able to feed these data into the model in a correct way.</p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/kmean.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Using Kmean to produce meaningful features</i></p><h3 id="Backtest-results-2"><a href="#Backtest-results-2" class="headerlink" title="Backtest results"></a>Backtest results</h3><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/kmean_summary.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i> Performance summary of three base scenarios with imputed data and additional kmean clustering</i></p><div class="table-container"><table><thead><tr><th>Drop missing data</th><th>Impute everything</th><th>Impute missing data by company</th></tr></thead><tbody><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/1-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/1-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/1-2.png" class="" width="200"></td></tr><tr><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td></tr><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-1-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-1-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-1-2.png" class="" width="200"></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>XGBoost, 30-month data performance stratified plot</i></p><div class="table-container"><table><thead><tr><th>Drop missing data</th><th>Impute everything</th><th>Impute missing data by company</th></tr></thead><tbody><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/2-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/2-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/2-2.png" class="" width="200"></td></tr><tr><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td></tr><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-2-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-2-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-2-2.png" class="" width="200"></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>XGBoost, 60-month data performance stratified plot</i></p><div class="table-container"><table><thead><tr><th>Drop missing data</th><th>Impute everything</th><th>Impute missing data by company</th></tr></thead><tbody><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/3-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/3-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/3-2.png" class="" width="200"></td></tr><tr><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td></tr><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-3-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-3-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-3-2.png" class="" width="200"></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>AdaBoost, 60-month data performance stratified plot</i></p><p>Again, let’s first look at the summary table. There are only two out of nine scenarios that have better annual returns after adopting the kmean clustering method. Our <code>profitability_of_the_company</code> factor doesn’t seem to be an effective way to raise the probability of win rate in the trading strategy. Fortunately, the experiment doesn’t have to stop right here. There are hundreds of features that we can test and try to see how to produce an effective, explainable feature that corresponds to our trading idea.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Among all three feature engineering techniques that we have adopted into our strategy, it seems that <strong>One-hot encodes</strong> the <code>industry</code> feature does enhance the predicting ability in our trading model. On the other hand, we can use <strong>KNNImputer</strong> as an alternative for <strong>SimpleImputer</strong>, and maybe try more combinations to create our new feature from the existing features.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/06/10/2022-06-10-adcanced-optimization/cover.jpeg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;Photo by &lt;a href=&quot;https://medium.com/r?url=https%3A%2F%2Funsplash.com%2F%40brett_jordan%3Futm_source%3Dmedium%26utm_medium%3Dreferral&quot;&gt;Brett Jordan&lt;/a&gt; on &lt;a href=&quot;https://medium.com/r/?url=https%3A%2F%2Funsplash.com%3Futm_source%3Dmedium%26utm_medium%3Dreferral&quot;&gt;Unsplash&lt;/a&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;From the &lt;a href=&quot;https://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/&quot;&gt;previous article&lt;/a&gt;, we’ve learned several indicators that we can calculate and use to evaluate the performances of your algorithm trading strategies. Given these indicators, we’re able to see how we can further polish our strategy and make it more seemingly profitable. Therefore, let’s work on our features to see how we can improve our machine learning trading strategy.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    <category term="Machine Learning" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/Machine-Learning/"/>
    
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>Looking for no-loss trading strategy? Here&#39;s the strategy that you should look at.</title>
    <link href="http://mikelhsia.github.io/2022/04/18/2022-04-20-forex-grid-trading-system/"/>
    <id>http://mikelhsia.github.io/2022/04/18/2022-04-20-forex-grid-trading-system/</id>
    <published>2022-04-18T04:03:36.000Z</published>
    <updated>2022-04-21T07:47:00.621Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/grid_system.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><p>Grid trading strategy is famous for its simplicity and ease of execution, and you don’t even have to guess where the market is going. No technical analysis and indicators are needed or recognize any patterns among endless candlesticks. It was once known as the <em>‘no-loss strategy’</em>.</p><p>But, is this true that there is a strategy that causes you no risk?</p><p>Today we’re going to look at what grid trading strategy is about, and we will conduct a series of backtesting against the Forex market to see whether it is the holy grail of our trading strategies.</p><a id="more"></a><hr><h1 id="Talking"><a href="#Talking" class="headerlink" title="Talking"></a>Talking</h1><h2 id="Forex-FX-and-Forex-trading"><a href="#Forex-FX-and-Forex-trading" class="headerlink" title="Forex (FX) and Forex trading"></a>Forex (FX) and Forex trading</h2><p><strong>Forex (FX)</strong> is short for Foreign Exchange, which is the global electronic marketplace for proprietary institutions or public companies/individuals to trade international currencies and currency derivatives. Prior to the Internet age, trading in the forex market is exclusive to large financial institutions, corporations, central banks, hedge funds, and extremely wealthy individuals as the information isn’t public and timely enough for the rest of the people. Once the internet emerged, the availability of the information empowers any individual to trade the foreign currency at a fair price whenever they need to. For example, if you’re living in the UK and you would like to buy a piece of furniture from the states, you want the furniture to be received in China and then pay the money to the US dealers. Hence, you need to convert your GBP to USD on the Forex market so that you can pay USD to the US dealers.</p><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/exchange.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. I. International tradings require foreign currency exchange</i></p><p>There are a few things that the Forex market differs from the stock markets:</p><ol><li>Forex opens 24/7, therefore the exchange rate changes even during weekends.</li><li>The Forex brokerages open only within a specific timeframe, meaning your investment could variate drastically and you cannot do anything about it if you own the overnight positions.</li><li>The currencies traded on the market in pairs, such as EUR/USD, AUD/JPY, GBP/CAD, …. For example, EUR/USD’s current quote is at 1.0791, meaning you would be able to buy 1 Euro with 1.0791 USD.</li><li>As the Forex rate volatility is relatively way smaller than the equity stocks, most of the Forex agencies provide a leveraged account that allows you to play leveraged trade in the Forex market.</li></ol><p>As the example illustrated above, there will be people or institutions who demand specific currencies to fulfill their personal or business needs. Therefore, as an individual investor, you are able to offer your capital there with an exchange rate $r_{Today}$ for anyone who needs your capital. By the time you need your capital back into your pocket, you then go to the market and recall your investment with the exchange rate $r_{Later}$. What’s in for you? When the invested currency goes higher, you will be able to earn the difference between $r_{Today}$ and $r_{Later}$ while converting that currency back to the currency you own. The loss would also incur if the exchange rate goes in the opposite direction.</p><p>That being said, trading foreign exchange is actually pretty similar to trading equity in the stock market. You always try to buy low and sell high.</p><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/Forex_trading.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. II. The historical candlesticks diagram of GBP/CHF</i></p><h2 id="Forex-grid-trading-strategy"><a href="#Forex-grid-trading-strategy" class="headerlink" title="Forex grid trading strategy"></a>Forex grid trading strategy</h2><p>The grid trading system’s central idea is to build a <em>“price grid”</em> around the reference quote price, usually yesterday’s close price, and buy (long/short) when the price trigger one of the bars in your grid and closes the position when you have gained a small piece of the profit. You trade like that when the price moves up and down over and over again. In the end, you’ll be able to accumulate small pieces into a big chunk of profit. This essentially is an extended version of the <em>“mean-reversion trading strategy”</em>. <a href="https://quantpedia.com/">Quantpedia</a> has a very nice piece to articulate what a grid trading system is about <a href="https://quantpedia.com/a-primer-on-grid-trading-strategy/">here</a>.</p><p>Let’s visualize the grid trading system so that it’s easier to understand:</p><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/grid_system.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. III. The grid trading system</i></p><p>The above trading system deploys three bars above the reference price and three below. Each bar has the same distance from the other. If the price first goes bearish and hit the bottom of the day, by that time we will have already three long positions purchased at prices <em>b1, b2, and b3</em>. Once the market starts reversing and the price goes above the reference price bar, three orders will be sold at prices <em>s1, s2, and s3</em> respectively. In this case, you will make $\text{(s1-b1) + (s2-b2) + (s3-b3)}$ as your total return.</p><p>The uptrend continues, you’ll build another three short positions <em>b’1, b’2, and b’3</em> when the price reaches today’s high. These three positions will be closed when the price drop below the reference price.</p><p>I believe you now get the idea. The two essential ideas of this trading strategy are:</p><ol><li>The more fluctuation in price, the more we profit.</li><li>The average price should stay relatively stable without soaring or plummeting too fast.</li></ol><p>The below chart is extracted from one of my backtest, and it perfectly illustrates what kind of trend we’re looking for to profit from implementing the grid trading strategy.<br><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/desire_trend.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. IV. The grid trading system</i></p><p>Most people believe the foreign exchange market is the best place that fit the two conditions we describe above. That’s why we’re going to backtest the grid trading strategy using Forex. Also, since the rules are relatively clear and simple, that makes the grid trading strategy is the best candidate to run/trade automatically with several of the conditions in place beforehand.</p><hr><h1 id="Doing"><a href="#Doing" class="headerlink" title="Doing"></a>Doing</h1><h2 id="Strategy-implementation"><a href="#Strategy-implementation" class="headerlink" title="Strategy implementation"></a>Strategy implementation</h2><h3 id="Strategy-setups-for-our-backtests"><a href="#Strategy-setups-for-our-backtests" class="headerlink" title="Strategy setups for our backtests"></a>Strategy setups for our backtests</h3><p>Let’s first start with identifying the parameters we need in this strategy:</p><ul><li><strong>Reference price</strong><ul><li>We use the close price before the previous market closed.</li></ul></li><li><strong>Grid number</strong><ul><li>10 bars above the reference price bar, and 10 bars below the reference price bar</li></ul></li><li><strong>Grid range</strong><ul><li>Grid range indicates the price range that we’re monitoring. We deploy the 20 bars across this price range. Therefore, setting a proper range would be critical to the system. If you have a pretty wide gap between bars, you’ll get fewer triggers when the price moves. On the contrary, if you have a fairly narrow gap, the price could easily penetrate your grid range and never fall back to where it was, causing a huge cost to your portfolio.</li><li>Here we use 2 times the standard deviation of the close price in the past three months as our grid range.</li></ul></li><li><strong>Leverage ratio</strong><ul><li>Most of the Forex brokerages offer N<em> leveraged accounts, meaning you’ll be able to deposit 1 dollar in your account and invest 1 </em> N dollars in the Forex market. For example, <a href="https://www.oanda.com/apply/?lang=zh-tw">Oanda</a> offers 100x leveraged account type to premium customers. In this example, let’s set it to 50x for now.</li></ul></li><li><strong>Position allocation</strong><ul><li>We have set up two different methods to allocate your assets in each bar:<ul><li><strong>Average</strong>: We allocate the same amount of capital to each order on every bar.</li><li><strong>Double down</strong>: As the current quote price goes further away from the reference price, we double down the amount of the position in each order. Let’s take <strong><em>Ill. III. The grid trading system</em></strong> for example, in limit order b1 and b’1, we placed 1 hand, in b2 and b’2 we place 2 hands, and in b3 and b’3 we place 4 hands. [1, 2, 4, 8, 16, ….]</li></ul></li></ul></li></ul><h3 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h3><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h3 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h3><p>I’m not going to use the concept of the <code>universe</code> in the backtesting of this strategy. Instead, I’m going to backtest the following foreign currency pair to see which currency pair best fits the nature of the grid trading strategy.</p><ul><li>GBP/CHF</li><li>AUD/CAD</li><li>GBP/CAD</li><li>USD/JPY</li><li>AUD/JPY</li><li>EUR/GBP</li><li>GBP/USD</li></ul><h3 id="Backtest-time-frame"><a href="#Backtest-time-frame" class="headerlink" title="Backtest time frame"></a>Backtest time frame</h3><p><strong>Backtest Date:</strong> <code>2021, 1 ,1</code> ~ <code>2022, 4, 16</code></p><h3 id="Signal-generation"><a href="#Signal-generation" class="headerlink" title="Signal generation"></a>Signal generation</h3><p>The triggering signal is very straightforward. As I mentioned in the <strong>Forex grid trading strategy</strong> section, the long/short limit order will be automatically triggered when the current close price touches the grid bar. However, in order to simplify the logic and to make everything automated so that the order can be generated in a timely manner, I’ve added my own tweaks to this grid trading system.</p><p>Referring to chart in <strong><em>Ill. III. The grid trading system</em></strong>, we see [b1, s1], [b2, s2], …, [b’1, s’1], [b’2, s’2], … as order pair. The first one in the pair is the long/short limit orders that we will place before the market starts. As long as any of the limit orders is fulfilled, the second one in the pair will be automatically triggered and generate another limit order waiting to close that position in order to gain profit. Vice versa, the fulfillment of the second limit order in the pair will also trigger the system to generate another open limit order waiting to catch the next opportunity. By doing this, we just need to set up 10 pairs of these on the long side and 10 pairs of these on the short side. See the following image for a quick illustration.</p><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/system_detail.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. V. The grid trading system - system detail</i></p><p>On the monthly basis, we will create 20 pairs of these to catch any movement. By the end of the month, we cancel all these open orders and close all the positions we hold. Then the next day before the market open, we readjust our reference price and recalculate the standard deviation of the past 90 days again as our grid range. By doing this, we’re going to make sure the current price won’t drift too far away from our grid if there’s a bull or bear market in the currency we’re trading against.</p><p>Stop-loss control is also a crucial part to be installed in every trading system. I’m placing three different scenarios of stop loss to see how they work out:</p><ul><li><strong>Don’t stop loss at all</strong>: <code>Let the profit fly</code>. We don’t set up any stop-loss point.</li><li><strong>Normal top loss</strong>: We monitor the distance between the current price and the reference price. If the current price deviates away from the reference price by over 20%, then we can reckon that there’s either an uptrend or downtrend that happens, which could cause a huge loss to our portfolio. If this happens, we liquidate all holding positions and close the rest of the opening limit orders. We’re not going to do any trade that month.</li><li><strong>Stop loss and rescale</strong>: In this scenario, right after we liquidate all existing positions and cancel open orders, we readjust all the parameters, including reference price and grid range, and deploy the grid again using the updated parameters instead of ceasing all the trading activities. We hope doing this would help us capture the new opportunities as soon as possible after the momentum of price rising/dropping ends.</li></ul><h2 id="Backtest-result"><a href="#Backtest-result" class="headerlink" title="Backtest result"></a>Backtest result</h2><div class="table-container"><table><thead><tr><th><strong>Currency</strong></th><th><strong>Level_method</strong></th><th><strong>Vol_method</strong></th><th><strong>Stop_loss</strong></th><th><strong>Rescale</strong></th><th><strong>Return</strong></th><th><strong>PSR</strong></th><th><strong>MDD</strong></th><th><strong>Total_trades</strong></th><th><strong>Sharpe_ratio</strong></th><th><strong>Win_rate</strong></th></tr></thead><tbody><tr><td>GBPCHF</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>83.33%</td><td>42.549%</td><td>80%</td><td>1446</td><td>1.264</td><td>74%</td></tr><tr><td>GBPCHF</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>18.68%</td><td>22.167%</td><td>72%</td><td>1104</td><td>0.478</td><td>72%</td></tr><tr><td>GBPCHF</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-6.34%</td><td>13.999%</td><td>74.3%</td><td>1531</td><td>0.218</td><td>71%</td></tr><tr><td>GBPCHF</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-76.1%</td><td>24.781%</td><td>99.5%</td><td>5574</td><td>0.856</td><td>71%</td></tr><tr><td>GBPCHF</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-16.05%</td><td>6.052%</td><td>39.7%</td><td>2087</td><td>-0.129</td><td>71%</td></tr><tr><td>GBPCHF</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-91.48%</td><td>0.027%</td><td>94.2%</td><td>8288</td><td>-0.928</td><td>70%</td></tr><tr><td>GBPCHF</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>11.72%</td><td>24.113%</td><td>70.4%</td><td>1442</td><td>0.587</td><td>97%</td></tr><tr><td>GBPCHF</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-24.58%</td><td>0.686%</td><td>35%</td><td>1104</td><td>-0.635</td><td>98%</td></tr><tr><td>GBPCHF</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-33.25%</td><td>0.323%</td><td>43.1%</td><td>1531</td><td>-0.763</td><td>97%</td></tr><tr><td>GBPCHF</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-61.84%</td><td>19.401%</td><td>98.6%</td><td>5573</td><td>0.477</td><td>94%</td></tr><tr><td>GBPCHF</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>11.68%</td><td>19.159%</td><td>21.1%</td><td>2087</td><td>0.38</td><td>96%</td></tr><tr><td>GBPCHF</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-62.32%</td><td>0.883%</td><td>96%</td><td>8288</td><td>-0.755</td><td>96%</td></tr><tr><td>AUDCAD</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>16.9%</td><td>21.526%</td><td>42.4%</td><td>959</td><td>0.473</td><td>66%</td></tr><tr><td>AUDCAD</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-24.29%</td><td>5.07%</td><td>49.1%</td><td>814</td><td>-0.187</td><td>68%</td></tr><tr><td>AUDCAD</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-24.44%</td><td>5.904%</td><td>56.2%</td><td>1056</td><td>-0.138</td><td>69%</td></tr><tr><td>AUDCAD</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-41.20%</td><td>10.311%</td><td>74.3%</td><td>4368</td><td>0.074</td><td>73%</td></tr><tr><td>AUDCAD</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-40.6%</td><td>0.005%</td><td>43.2%</td><td>1467</td><td>-1.261</td><td>69%</td></tr><tr><td>AUDCAD</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-78.65%</td><td>0.041%</td><td>88.9%</td><td>8324</td><td>-1.105</td><td>71%</td></tr><tr><td>AUDCAD</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>41.58%</td><td>32.301%</td><td>34.1%</td><td>959</td><td>0.764</td><td>98%</td></tr><tr><td>AUDCAD</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-4.95%</td><td>8.28%</td><td>21.7%</td><td>814</td><td>-0.017</td><td>98%</td></tr><tr><td>AUDCAD</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-8.17%</td><td>6.912%</td><td>32.1%</td><td>1096</td><td>-0.082</td><td>98%</td></tr><tr><td>AUDCAD</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>35.42%</td><td>28.118%</td><td>67.7%</td><td>4368</td><td>0.704</td><td>96%</td></tr><tr><td>AUDCAD</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-21.32%</td><td>0.265%</td><td>28.5%</td><td>1467</td><td>-0.934</td><td>98%</td></tr><tr><td>AUDCAD</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-49.27%</td><td>0.509%</td><td>65.8%</td><td>8324</td><td>-0.931</td><td>97%</td></tr><tr><td>GBPCAD</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>97.54%</td><td>49.78%</td><td>43.5%</td><td>1250</td><td>1.278</td><td>74%</td></tr><tr><td>GBPCAD</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>109.54%</td><td>65.971%</td><td>19.7%</td><td>1203</td><td>1.661</td><td>75%</td></tr><tr><td>GBPCAD</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>156%</td><td>78.098%</td><td>24.1%</td><td>1382</td><td>2.131</td><td>75%</td></tr><tr><td>GBPCAD</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>137.75%</td><td>49.858%</td><td>52.5%</td><td>5632</td><td>1.473</td><td>73%</td></tr><tr><td>GBPCAD</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-17.27%</td><td>2.41%%</td><td>30.2%</td><td>1913</td><td>-0.394</td><td>71%</td></tr><tr><td>GBPCAD</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-65.19%</td><td>0.226%</td><td>71.2%</td><td>8459</td><td>-0.971</td><td>73%</td></tr><tr><td>GBPCAD</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>25.43%</td><td>24.555%</td><td>39.1%</td><td>1250</td><td>0.564</td><td>99%</td></tr><tr><td>GBPCAD</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>28.3%</td><td>39.133%</td><td>12.2%</td><td>1203</td><td>0.865%</td><td>99%</td></tr><tr><td>GBPCAD</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>48.86%</td><td>58.341</td><td>10.7%</td><td>1382</td><td>1.296</td><td>99%</td></tr><tr><td>GBPCAD</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>255.36%</td><td>69.083%</td><td>55.7%</td><td>5632</td><td>2.202</td><td>97%</td></tr><tr><td>GBPCAD</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-8.46%</td><td>3.877%</td><td>20.6%</td><td>1913</td><td>-0.276</td><td>98%</td></tr><tr><td>GBPCAD</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-45.97%</td><td>0.601%</td><td>55%</td><td>8459</td><td>-0.982</td><td>98%</td></tr><tr><td>USDJPY</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-1.72%</td><td>0.014%</td><td>2.1%</td><td>805</td><td>-1.603</td><td>71%</td></tr><tr><td>USDJPY</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-0.22%</td><td>2.848%</td><td>0.6%</td><td>785</td><td>-0.373</td><td>72%</td></tr><tr><td>USDJPY</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-0.42%</td><td>1.26%</td><td>0.7%</td><td>1135</td><td>-0.596</td><td>72%</td></tr><tr><td>USDJPY</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-2.13%</td><td>0.062%</td><td>2.3%</td><td>4548</td><td>-1.347</td><td>72%</td></tr><tr><td>USDJPY</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-0.41%</td><td>0.020%</td><td>0.4%</td><td>1455</td><td>-1.242</td><td>72%</td></tr><tr><td>USDJPY</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-1.56%</td><td>0.001%</td><td>1.7%</td><td>8251</td><td>-2.611</td><td>71%</td></tr><tr><td>USDJPY</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-1.68%</td><td>0.006%</td><td>2%</td><td>805</td><td>-1.76%</td><td>98%</td></tr><tr><td>USDJPY</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-0.22%</td><td>0.74%</td><td>0.4%</td><td>785</td><td>-0.65</td><td>97%</td></tr><tr><td>USDJPY</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-0.37%</td><td>0.169%</td><td>0.5%</td><td>1135</td><td>-0.931</td><td>97%</td></tr><tr><td>USDJPY</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-1.91%</td><td>0.057%</td><td>2.3%</td><td>4548</td><td>-1.355</td><td>94%</td></tr><tr><td>USDJPY</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-0.24%</td><td>0.17%</td><td>0.3%</td><td>1455</td><td>-1.081</td><td>98%</td></tr><tr><td>USDJPY</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-0.58%</td><td>0.512%</td><td>0.8%</td><td>8251</td><td>-1.342</td><td>96%</td></tr><tr><td>AUDJPY</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-2.51%</td><td>0.048%</td><td>3.4%</td><td>621</td><td>-1.314</td><td>67%</td></tr><tr><td>AUDJPY</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-0.78%</td><td>1.384%</td><td>1.5%</td><td>573</td><td>-0.597</td><td>67%</td></tr><tr><td>AUDJPY</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-1.55%</td><td>0.23%</td><td>2.3%</td><td>898</td><td>-1.013</td><td>67%</td></tr><tr><td>AUDJPY</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-4.13%</td><td>0.032%</td><td>5%</td><td>3883</td><td>-1.45</td><td>71%</td></tr><tr><td>AUDJPY</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-0.78%</td><td>0.003%</td><td>0.9%</td><td>1303</td><td>-1.446</td><td>67%</td></tr><tr><td>AUDJPY</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-2.56%</td><td>0.001%</td><td>3%</td><td>8211</td><td>-2.624</td><td>70%</td></tr><tr><td>AUDJPY</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-2.05%</td><td>0.048%</td><td>2.9%</td><td>621</td><td>-1.287</td><td>97%</td></tr><tr><td>AUDJPY</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-0.33%</td><td>2.78%</td><td>0.7%</td><td>573</td><td>-0.415</td><td>96%</td></tr><tr><td>AUDJPY</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-0.71%</td><td>0.632%</td><td>1.1%</td><td>898</td><td>-0.8</td><td>96%</td></tr><tr><td>AUDJPY</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-3.47%</td><td>0.057%</td><td>4.4%</td><td>3883</td><td>-1.334</td><td>93%</td></tr><tr><td>AUDJPY</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-0.41%</td><td>0.174%</td><td>0.6%</td><td>1303</td><td>-1.09</td><td>97%</td></tr><tr><td>AUDJPY</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-1%</td><td>0.263%</td><td>1.6%</td><td>8211</td><td>-1.495</td><td>97%</td></tr><tr><td>EURGBP</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>193.48%</td><td>55.86%</td><td>59.3%</td><td>1342</td><td>1.777</td><td>69%</td></tr><tr><td>EURGBP</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>184.33%</td><td>64.133%</td><td>53.2%</td><td>1325</td><td>1.84</td><td>70%</td></tr><tr><td>EURGBP</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>236.89%</td><td>71.59%</td><td>50.1%</td><td>1451</td><td>2.168%</td><td>71%</td></tr><tr><td>EURGBP</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-73.2%</td><td>14.02%</td><td>94.5%</td><td>4041</td><td>0.244</td><td>69%</td></tr><tr><td>EURGBP</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-66.65%</td><td>0%</td><td>67.4%</td><td>1120</td><td>-1.394</td><td>63%</td></tr><tr><td>EURGBP</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-91.09%</td><td>0.013%</td><td>91.2%</td><td>8343</td><td>-0.948</td><td>70%</td></tr><tr><td>EURGBP</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>255.97%</td><td>71.420%</td><td>42.5%</td><td>1339</td><td>2.178</td><td>98%</td></tr><tr><td>EURGBP</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>216.28%</td><td>93.866%</td><td>19.4%</td><td>1325</td><td>2.811</td><td>98%</td></tr><tr><td>EURGBP</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>226.02%</td><td>94.772%</td><td>19.4%</td><td>1451</td><td>2.905</td><td>98%</td></tr><tr><td>EURGBP</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-36.14%</td><td>20.836%</td><td>91.2%</td><td>4037</td><td>0.53</td><td>96%</td></tr><tr><td>EURGBP</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-48.93%</td><td>0%</td><td>49.4%</td><td>1120</td><td>-1.949</td><td>97%</td></tr><tr><td>EURGBP</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-73.37%</td><td>0.084%</td><td>73.4%</td><td>8343</td><td>-1.016</td><td>96%</td></tr><tr><td>GBPUSD</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-21.81%</td><td>13.698%</td><td>75.7%</td><td>814</td><td>0.223</td><td>72%</td></tr><tr><td>GBPUSD</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-0.3%</td><td>15.694%</td><td>63.5%</td><td>783</td><td>0.301</td><td>74%</td></tr><tr><td>GBPUSD</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>37.20%</td><td>27.093%</td><td>52.8%</td><td>1016</td><td>0.678</td><td>76%</td></tr><tr><td>GBPUSD</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-60.85%</td><td>12.303%</td><td>91.1%</td><td>5090</td><td>0.169</td><td>73%</td></tr><tr><td>GBPUSD</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-39.26%</td><td>0.47%</td><td>47.2%</td><td>1651</td><td>-0.744</td><td>71%</td></tr><tr><td>GBPUSD</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-90.26%</td><td>0.002%</td><td>93.4%</td><td>8325</td><td>-1.192</td><td>70%</td></tr><tr><td>GBPUSD</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-2.78%</td><td>15.241%</td><td>55.2%</td><td>814</td><td>0.276%</td><td>98%</td></tr><tr><td>GBPUSD</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>11.13%</td><td>17.60%</td><td>40%</td><td>785</td><td>0.355</td><td>98%</td></tr><tr><td>GBPUSD</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>13.85%</td><td>18.86%</td><td>38.6%</td><td>1018</td><td>0.395</td><td>98%</td></tr><tr><td>GBPUSD</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-15.88%</td><td>20.194%</td><td>89.3%</td><td>5090</td><td>0.472</td><td>93%</td></tr><tr><td>GBPUSD</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-19.0%</td><td>2.947%</td><td>38.5%</td><td>1651</td><td>-0.378</td><td>97%</td></tr><tr><td>GBPUSD</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-71.33%</td><td>0.1%</td><td>83.4%</td><td>8325</td><td>-1.181</td><td>98%</td></tr></tbody></table></div><h2 id="Post-analysis"><a href="#Post-analysis" class="headerlink" title="Post-analysis"></a>Post-analysis</h2><p>Across all scenarios and all foreign currency pairs, we can see that the strategy returns range from <font color='green'>230%</font> to <font color='red'>-90%</font>. The Sharpe ratios range from <font color='green'>2.2</font> to <font color='red'>-2.6</font>. It seems that the grid trading strategy is not very stable in terms of capturing profit. On the other hand, not surprising that the win rate is as high as 70% to 97%. These stats can clearly infer that our strategy can efficiently capture the profit when the price fluctuates. Sadly those trades that didn’t win actually cause us humongous losses.</p><p>Let’s do another round of analysis to look into the details of all the scenarios.</p><p>First, let’s look at the difference between using standard deviation and using <a href="https://www.investopedia.com/terms/a/atr.asp">ATR (Average True Range)</a> indicator as our grid range. Apparently, the standard deviation is more outstanding in terms of predicting the proper range of price change.<br><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/std_vs_atr.png" class="" width="400"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. VI. STD v.s. ATR on Returns (%)</i></p><p>We don’t see much difference between using average allocation and double down allocation to control our position allocation on each bar.<br><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/ave_vs_dou.png" class="" width="400"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. VII. Average allocation v.s. double down allocation on Returns (%)</i></p><p>Lastly, let’s take a look at whether the stop-loss mechanism will help improve the quality of our trades. The strategy returns in all scenarios unanimously reduced a great certain percentage. In the meantime, the MDD (Max Drop Down) was also greatly reduced when applying the stop loss method. Unexpectedly, the stop loss and rescale method even deteriorate both the strategy return and MDD compared to the scenarios applying the stop-loss method.<br><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/stoploss.png" class="" width="400"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. VIII. Stoploss on Returns (%)</i></p><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/stoploss_mdd.png" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. VIII. Stoploss on MDD (%)</i></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In short, the grid trading strategy has done what we ask it to capture all the profitable opportunities when the price fluctuates among our monitoring grid range. However, when the price moves in one direction in a short period of time, the potential cost could cost us the entire portfolio. The global economy and international politics are the origins of this sudden price change which we cannot predict. Unless we’re able to produce a stop loss method or hedge instrument to help us mitigate the risk and endure the sudden price movement, the grid trading strategy wouldn’t be able to help us consistently capture the <strong>risk-free</strong> profit.</p><p>To do that, here are a few topics that we can explore to further optimize our grid trading strategy:</p><ul><li>Better stop loss method</li><li>Using technical indicators to help identify and avoid the upward/downward trends.</li><li>Try to experiment with different foreign currency pairs, as each currency pair has its own characteristic. Some possess high volatility, and some are relatively stable.</li></ul><p>That’ll be all for this post. Cheers.</p><hr><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://quantpedia.com/a-primer-on-grid-trading-strategy/">A primer on grid trading strategy</a></li><li><a href="https://quantpedia.com/whats-the-relation-between-grid-trading-and-delta-hedging/">What’s the relation between grid trading and delta hedging</a></li><li><a href="http://blog.sina.com.cn/s/blog_69e73f710100kd6x.html">Fundamental of grid trading strategy</a></li><li><a href="https://forexwithanedge.com/grid-trading/">Grid trading</a></li><li><a href="https://baijiahao.baidu.com/s?id=1703235910517684547&amp;wfr=spider&amp;for=pc">How to pick the right currency pair to trade as a Forex beginners?</a></li><li><a href="https://www.youtube.com/watch?v=fHPPnZcsDEo">Grid trading bot Part 2</a></li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from datetime import datetime</span><br><span class="line">import re</span><br><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">class ReferenceType(Enum):</span><br><span class="line">    AVERAGE &#x3D; 1</span><br><span class="line">    PREVIOUS_CLOSE &#x3D; 2</span><br><span class="line"></span><br><span class="line">class VolatilityType(Enum):</span><br><span class="line">    STANDARD_DEVIATION &#x3D; 1</span><br><span class="line">    HIGH_LOW &#x3D; 2    # This trigger very little orders, ineffective.</span><br><span class="line">    ATR &#x3D; 3</span><br><span class="line"></span><br><span class="line">class PositionAmountType(Enum):</span><br><span class="line">    AVERAGE &#x3D; 1</span><br><span class="line">    INCREMENTAL &#x3D; 2</span><br><span class="line">    DOUBLEUP &#x3D; 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FXMomentumAlgorithm(QCAlgorithm):</span><br><span class="line">    def Initialize(self):</span><br><span class="line">        self.SetStartDate(2020, 12, 28)</span><br><span class="line">        # self.SetStartDate(2017, 12, 28)</span><br><span class="line">        self.SetEndDate(datetime.now())</span><br><span class="line">        self.SetCash(100000)</span><br><span class="line">        self.resolution &#x3D; Resolution.Minute</span><br><span class="line">        self._grid_number &#x3D; 10</span><br><span class="line">        self._leverage_ratio &#x3D; 50</span><br><span class="line">        self._reference_price &#x3D; None</span><br><span class="line">        self._std &#x3D; None</span><br><span class="line">        self._stop_loss &#x3D; None</span><br><span class="line">        self._cash_preserve_ratio &#x3D; 0.99</span><br><span class="line">        self._cash_per_position &#x3D; None</span><br><span class="line"></span><br><span class="line">        self.IS_READY &#x3D; False</span><br><span class="line">        self.REFERENCE_PRICE_METHOD &#x3D; ReferenceType.PREVIOUS_CLOSE</span><br><span class="line">        self.POSITION_AMOUNT_METHOD &#x3D; PositionAmountType.AVERAGE</span><br><span class="line">        self.VOLATILITY_METHOD &#x3D; VolatilityType.STANDARD_DEVIATION</span><br><span class="line">        self.VOLATILITY_MULTIPLIER &#x3D; 2</span><br><span class="line">        self.STOP_LOSS_MODE &#x3D; False</span><br><span class="line">        self.STOP_LOSS_RESCALE &#x3D; False</span><br><span class="line">        self.STOP_LOSS_MULTIPLIER &#x3D; 1.2 # 10% more on upper side and 10% less on lower side</span><br><span class="line"></span><br><span class="line">        # self.pair &#x3D; &#39;GBPCHF&#39;</span><br><span class="line">        # self.pair &#x3D; &#39;AUDCAD&#39;</span><br><span class="line">        # self.pair &#x3D; &#39;GBPCAD&#39;</span><br><span class="line">        # self.pair &#x3D; &#39;USDJPY&#39;</span><br><span class="line">        # self.pair &#x3D; &#39;AUDJPY&#39;</span><br><span class="line">        self.pair &#x3D; &#39;EURGBP&#39;</span><br><span class="line">        # self.pair &#x3D; &#39;GBPUSD&#39;</span><br><span class="line"></span><br><span class="line">        self.forex &#x3D; self.AddForex(</span><br><span class="line">            self.pair,</span><br><span class="line">            self.resolution,</span><br><span class="line">            Market.Oanda,</span><br><span class="line">            True,</span><br><span class="line">            self._leverage_ratio</span><br><span class="line">        )</span><br><span class="line">        # self.Debug(f&#39;Our Leverage: &#123;self.forex.MarginModel.GetLeverage(self.forex)&#125;&#39;)</span><br><span class="line"></span><br><span class="line">        ################################################</span><br><span class="line">        # Adding Schedule event</span><br><span class="line">        self.Schedule.On(</span><br><span class="line">            self.DateRules.MonthStart(self.pair),</span><br><span class="line">            self.TimeRules.AfterMarketOpen(self.pair, 0),</span><br><span class="line">            self.openMarket</span><br><span class="line">        )</span><br><span class="line">        self.Schedule.On(</span><br><span class="line">            self.DateRules.MonthEnd(self.pair),</span><br><span class="line">            self.TimeRules.BeforeMarketClose(self.pair, 5),</span><br><span class="line">            self.closeMarket</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def OnData(self, data):</span><br><span class="line">        if not self.IS_READY or self.pair not in data:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        if not self.STOP_LOSS_MODE:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # Stop loss</span><br><span class="line">        if data[self.pair].Close &lt; (self._reference_price - self._stop_loss) or data[self.pair].Close &gt; (self._reference_price + self._stop_loss):</span><br><span class="line">            # self.Debug(f&#39;&#123;self.Time&#125;: Break out and clean the open orders&#39;)</span><br><span class="line">            # Liquidate all positions and close all open orders</span><br><span class="line">            self.Liquidate(self.pair)</span><br><span class="line">            if self.STOP_LOSS_RESCALE:</span><br><span class="line">                self.openMarket()</span><br><span class="line"></span><br><span class="line">    def setParameters(self):</span><br><span class="line">        history &#x3D; self.History([self.pair], 93, Resolution.Daily)</span><br><span class="line">        history &#x3D; history.droplevel(0)</span><br><span class="line"></span><br><span class="line">        # Set up reference price</span><br><span class="line">        if self.REFERENCE_PRICE_METHOD &#x3D;&#x3D; ReferenceType.PREVIOUS_CLOSE:</span><br><span class="line">            # Get close of previous day</span><br><span class="line">            self._reference_price &#x3D; self.History(</span><br><span class="line">                [self.pair],</span><br><span class="line">                2880,</span><br><span class="line">                Resolution.Minute</span><br><span class="line">            ).droplevel(0).close[-1]</span><br><span class="line">        elif self.REFERENCE_PRICE_METHOD &#x3D;&#x3D; ReferenceType.AVERAGE:</span><br><span class="line">            # Daily moving average</span><br><span class="line">            self.Debug(&#39;Average mean&#39;)</span><br><span class="line">            self._reference_price &#x3D; history.close[-20:].mean()</span><br><span class="line"></span><br><span class="line">        # Cash amount per position</span><br><span class="line">        if self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.AVERAGE:</span><br><span class="line">            # Leveraged Equal weighted</span><br><span class="line">            self._cash_per_position &#x3D; (self.Portfolio.MarginRemaining * self._leverage_ratio * self._cash_preserve_ratio) &#x2F; (self._grid_number * 2)</span><br><span class="line">        elif self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.INCREMENTAL:</span><br><span class="line">            # Leveraged incremental weighted</span><br><span class="line">            self._cash_per_position &#x3D; (self.Portfolio.MarginRemaining * self._leverage_ratio * self._cash_preserve_ratio) &#x2F; (sum(range(1, self._grid_number+1)) * 2)</span><br><span class="line">        elif self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.DOUBLEUP:</span><br><span class="line">            # Leveraged double up weighted</span><br><span class="line">            self._cash_per_position &#x3D; (self.Portfolio.MarginRemaining * self._leverage_ratio * self._cash_preserve_ratio) &#x2F; ((2**self._grid_number - 1) * 2)</span><br><span class="line"></span><br><span class="line">        # Get volatility of previous day</span><br><span class="line">        if self.VOLATILITY_METHOD &#x3D;&#x3D; VolatilityType.STANDARD_DEVIATION:</span><br><span class="line">            # The 2 * Standardization &#x3D; 95%</span><br><span class="line">            self._std &#x3D; history.close.std() * self.VOLATILITY_MULTIPLIER</span><br><span class="line">        elif self.VOLATILITY_METHOD &#x3D;&#x3D; VolatilityType.HIGH_LOW:</span><br><span class="line">            # The high and low of the previous market open day</span><br><span class="line">            self._std &#x3D; abs(history.high.max() - history.low.min())</span><br><span class="line">        elif self.VOLATILITY_METHOD &#x3D;&#x3D; VolatilityType.ATR:</span><br><span class="line">            # ATR</span><br><span class="line">            self._std &#x3D; ta.ATR(history.high, history.low, history.close, timeperiod&#x3D;60)[-1]</span><br><span class="line"></span><br><span class="line">        self._stop_loss &#x3D; self._std * self.STOP_LOSS_MULTIPLIER</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def openMarket(self):</span><br><span class="line">        # self.Debug(f&#39;&#123;self.Time&#125; Market open. Order number (&#123;len(self.Transactions.GetOpenOrders(self.pair))&#125;)&#39;)</span><br><span class="line">        self.setParameters()</span><br><span class="line"></span><br><span class="line">        # Cancel all open orders before creating new orders</span><br><span class="line">        self.Liquidate(self.pair)</span><br><span class="line"></span><br><span class="line">        # Set up the grid limit order</span><br><span class="line"></span><br><span class="line">        for i in range(1, self._grid_number + 1):</span><br><span class="line">            qty &#x3D; int(self._cash_per_position * self.get_qty_multiplier(i) &#x2F; (self._reference_price - self._std &#x2F; self._grid_number * i))</span><br><span class="line">            order &#x3D; self.LimitOrder(</span><br><span class="line">                self.pair,</span><br><span class="line">                qty,</span><br><span class="line">                round(self._reference_price - self._std &#x2F; self._grid_number * i, 5),</span><br><span class="line">                f&#39;Long&#123;i&#125;&#39;</span><br><span class="line">            )</span><br><span class="line">            qty &#x3D; int(self._cash_per_position * self.get_qty_multiplier(i) &#x2F; (self._reference_price + self._std &#x2F; self._grid_number * i))</span><br><span class="line">            order &#x3D; self.LimitOrder(</span><br><span class="line">                self.pair,</span><br><span class="line">                -qty,</span><br><span class="line">                round(self._reference_price + self._std &#x2F; self._grid_number * i, 5),</span><br><span class="line">                f&#39;Short&#123;i&#125;&#39;</span><br><span class="line">            )</span><br><span class="line">        self.IS_READY &#x3D; True</span><br><span class="line"></span><br><span class="line">    def closeMarket(self):</span><br><span class="line">        # self.Debug(f&#39;&#123;self.Time&#125; Market close&#39;)</span><br><span class="line"></span><br><span class="line">        # Liquidate all positions by the end of the day</span><br><span class="line">        self.Liquidate(self.pair)</span><br><span class="line"></span><br><span class="line">        # self.Debug(f&#39;&#123;self.Time&#125; Market close. Order number (&#123;len(self.Transactions.GetOpenOrders(self.pair))&#125;)&#39;)</span><br><span class="line"></span><br><span class="line">    def OnOrderEvent(self, orderEvent):</span><br><span class="line">        order &#x3D; self.Transactions.GetOrderById(orderEvent.OrderId)</span><br><span class="line">        if orderEvent.Status &#x3D;&#x3D; OrderStatus.Filled:</span><br><span class="line">            # self.Debug(</span><br><span class="line">            #     &quot;&#123;0&#125;: &#123;1&#125; (&#123;2&#125;)&quot;.format(</span><br><span class="line">            #         self.Time,</span><br><span class="line">            #         orderEvent,</span><br><span class="line">            #         order.Tag</span><br><span class="line">            #     )</span><br><span class="line">            # )</span><br><span class="line"></span><br><span class="line">            match &#x3D; re.match(r&#39;(.*)(\d+)(.*)$&#39;, order.Tag)</span><br><span class="line"></span><br><span class="line">            if not match:</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            if match.group(1) &#x3D;&#x3D; &#39;Long&#39;:</span><br><span class="line">                i &#x3D; int(match.group(2))</span><br><span class="line">                if match.group(3) &#x3D;&#x3D; &#39;-Liquidate&#39;:</span><br><span class="line">                    qty &#x3D; int(self._cash_per_position * self.get_qty_multiplier(i) &#x2F; (self._reference_price - self._std &#x2F; self._grid_number * i))</span><br><span class="line">                    self.LimitOrder(</span><br><span class="line">                        self.pair,</span><br><span class="line">                        qty,</span><br><span class="line">                        round(self._reference_price - self._std &#x2F; self._grid_number * i, 5),</span><br><span class="line">                        f&#39;Long&#123;match.group(2)&#125;&#39;</span><br><span class="line">                    )</span><br><span class="line">                else:</span><br><span class="line">                    if (i - 1) &#x3D;&#x3D; 0:</span><br><span class="line">                        self.LimitOrder(</span><br><span class="line">                            self.pair,</span><br><span class="line">                            -abs(order.Quantity),</span><br><span class="line">                            round(self._reference_price, 5),</span><br><span class="line">                            f&#39;Long&#123;match.group(2)&#125;-Liquidate&#39;</span><br><span class="line">                        )</span><br><span class="line">                    elif i &gt; 1:</span><br><span class="line">                        self.LimitOrder(</span><br><span class="line">                            self.pair,</span><br><span class="line">                            -abs(order.Quantity),</span><br><span class="line">                            round(self._reference_price - self._std &#x2F; self._grid_number * (i - 1), 5),</span><br><span class="line">                            f&#39;Long&#123;match.group(2)&#125;-Liquidate&#39;</span><br><span class="line">                        )</span><br><span class="line">            elif match.group(1) &#x3D;&#x3D; &#39;Short&#39;:</span><br><span class="line">                i &#x3D; int(match.group(2))</span><br><span class="line">                if match.group(3) &#x3D;&#x3D; &#39;-Liquidate&#39;:</span><br><span class="line">                    qty &#x3D; int(self._cash_per_position * self.get_qty_multiplier(i) &#x2F; (self._reference_price + self._std &#x2F; self._grid_number * i))</span><br><span class="line">                    self.LimitOrder(</span><br><span class="line">                        self.pair,</span><br><span class="line">                        -qty,</span><br><span class="line">                        round(self._reference_price + self._std &#x2F; self._grid_number * i, 5),</span><br><span class="line">                        f&#39;Short&#123;match.group(2)&#125;&#39;</span><br><span class="line">                    )</span><br><span class="line">                    openOrders &#x3D; self.Transactions.GetOpenOrders(self.pair)</span><br><span class="line">                    for order in openOrders:</span><br><span class="line">                        if order.Tag in [f&#39;Short&#123;match.group(2)&#125;-Liquidate&#39;, f&#39;Short&#123;match.group(2)&#125;-Stoploss&#39;]:</span><br><span class="line">                            self.Transactions.CancelOrder(order.Id)</span><br><span class="line">                else:</span><br><span class="line">                    if (i - 1) &#x3D;&#x3D; 0:</span><br><span class="line">                        self.LimitOrder(</span><br><span class="line">                            self.pair,</span><br><span class="line">                            abs(order.Quantity),</span><br><span class="line">                            round(self._reference_price, 5),</span><br><span class="line">                            f&#39;Short&#123;match.group(2)&#125;-Liquidate&#39;</span><br><span class="line">                        )</span><br><span class="line">                    else:</span><br><span class="line">                        self.LimitOrder(</span><br><span class="line">                            self.pair,</span><br><span class="line">                            abs(order.Quantity),</span><br><span class="line">                            round(self._reference_price + self._std &#x2F; self._grid_number * (i - 1), 5),</span><br><span class="line">                            f&#39;Short&#123;match.group(2)&#125;-Liquidate&#39;</span><br><span class="line">                        )</span><br><span class="line">        self.IS_READY &#x3D; False</span><br><span class="line"></span><br><span class="line">    def get_qty_multiplier(self, grid_number):</span><br><span class="line">        if self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.AVERAGE:</span><br><span class="line">            # Even weighted</span><br><span class="line">            return 1</span><br><span class="line">        elif self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.INCREMENTAL:</span><br><span class="line">            # Incremental</span><br><span class="line">            return grid_number</span><br><span class="line">        elif self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.DOUBLEUP:</span><br><span class="line">            # Double up weighted</span><br><span class="line">            if not isinstance(grid_number, (int)):</span><br><span class="line">                grid_number &#x3D; int(grid_number)</span><br><span class="line">            return 2**(grid_number - 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/04/18/2022-04-20-forex-grid-trading-system/grid_system.png&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;Grid trading strategy is famous for its simplicity and ease of execution, and you don’t even have to guess where the market is going. No technical analysis and indicators are needed or recognize any patterns among endless candlesticks. It was once known as the &lt;em&gt;‘no-loss strategy’&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But, is this true that there is a strategy that causes you no risk?&lt;/p&gt;
&lt;p&gt;Today we’re going to look at what grid trading strategy is about, and we will conduct a series of backtesting against the Forex market to see whether it is the holy grail of our trading strategies.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
    <category term="Grid trading" scheme="http://mikelhsia.github.io/tags/Grid-trading/"/>
    
    <category term="Forex" scheme="http://mikelhsia.github.io/tags/Forex/"/>
    
  </entry>
  
  <entry>
    <title>Yes or No? Adopting the Supertrend indicator in your trading strategies?</title>
    <link href="http://mikelhsia.github.io/2022/03/18/2022-03-22-supertrend-indicator/"/>
    <id>http://mikelhsia.github.io/2022/03/18/2022-03-22-supertrend-indicator/</id>
    <published>2022-03-17T17:20:43.000Z</published>
    <updated>2022-03-18T18:40:10.596Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/03/18/2022-03-22-supertrend-indicator/cover.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><p>I have to admit that my attention was drawn by the name of this indicator at the first glance. Therefore my interest in implementing a series of backtesting against this indicator was unavoidable. In today’s article, we’re going to introduce what Supertrend indicator is about and how to produce one yourself. After that, I will show you a series of backtest that I have performed and see what we can get out of them.</p><a id="more"></a><h1 id="Introduce-Supertrend-indicator"><a href="#Introduce-Supertrend-indicator" class="headerlink" title="Introduce Supertrend indicator"></a>Introduce Supertrend indicator</h1><h2 id="What-is-Supertrend"><a href="#What-is-Supertrend" class="headerlink" title="What is Supertrend"></a>What is Supertrend</h2><p>Supertrend indicator was created by Olivier Seban to help identify trends and to know when to buy or sell a financial asset. Similar to Bollinger Bands, Supertrend involves an upper band and a lower band that is derived from the close price in order to find out the signals to show the trend of prices. Essentially, it is a trend-following (lagging) indicator.</p><p>When we construct the Supertrend indicator strategy, the default parameters involve using Average True Range (ATR) with the period of 14 and another parameter of 2 as its multiplier. The average true range (ATR) plays a key role in Supertrend as the indicator uses ATR to compute its upper- and lower- band values in results triggering the buy and sell signals.</p><h2 id="Pros-and-cons-of-Supertrend"><a href="#Pros-and-cons-of-Supertrend" class="headerlink" title="Pros and cons of Supertrend"></a>Pros and cons of Supertrend</h2><p>However, Super Trend needs to be used in conjunction with other indicators like RSI, MACD, and any other technical indicators in order to produce more accurate and confirmed signals.  Moreover, Supertrend also works best with a trailing stop-loss for the existing trades and acts as strong support or resistance.to use in combination with other indicators like MACD and RSI. We can list its pros and cons below to quickly understand Supertrend:</p><ul><li>Advantages of SuperTrend Indicator<ul><li>The best thing about Supertrend is it sends out accurate signals.</li><li>The indicator offers a quick technical analysis to intraday traders.</li><li>It is easy to use and understand.</li></ul></li><li>Disadvantages<ul><li>The Supertrend is not appropriate for all situations, which works when the market is trending.</li><li>Supertrend is best for singling out the trend, but it needs to cooperate with other indicators to decide the best timing to trade.</li><li>Supertrend uses only the two parameters of ATR and multiplier. They are not sufficient under certain conditions to predict the accurate direction of the market.</li></ul></li></ul><h2 id="How-to-calculate-Supertrend-indicator"><a href="#How-to-calculate-Supertrend-indicator" class="headerlink" title="How to calculate Supertrend indicator"></a>How to calculate Supertrend indicator</h2><p>Here I’m using the research book from <a href="https://www.quantconnect.com/">QuantConnect</a> to demonstrate the calculation of Supertrend indicator.</p><h3 id="1-Retrieve-close-and-ATR-data"><a href="#1-Retrieve-close-and-ATR-data" class="headerlink" title="1. Retrieve close and ATR data"></a>1. Retrieve close and ATR data</h3><p>First of all, we need to retrieve the close price and the ATR indicator from historical data:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qb &#x3D; QuantBook()</span><br><span class="line">stock &#x3D; qb.AddEquity(&quot;AAPL&quot;)</span><br><span class="line">history &#x3D; qb.History(qb.Securities.Keys, 720, Resolution.Daily)</span><br><span class="line">atr &#x3D; qb.Indicator(AverageTrueRange(14), stock.Symbol, 720, Resolution.Daily)</span><br><span class="line"></span><br><span class="line">his &#x3D; history.swaplevel().droplevel(1)</span><br><span class="line">his[&#39;atr&#39;] &#x3D; atr[&#39;averagetruerange&#39;]</span><br><span class="line">his.dropna(inplace&#x3D;True)</span><br><span class="line"></span><br><span class="line">his[[&#39;close&#39;, &#39;atr&#39;]].head()</span><br></pre></td></tr></table></figure></p><img data-src="/2022/03/18/2022-03-22-supertrend-indicator/data.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><h3 id="2-The-basic-upper-and-lower-bands"><a href="#2-The-basic-upper-and-lower-bands" class="headerlink" title="2. The basic upper- and lower- bands"></a>2. The basic upper- and lower- bands</h3><p>Then we need to calculate the basic upperband and lowerband utilizing the daily 14-period ATR. These basic bands fundamentally are the volatility through using the ATR indicator to see the possible fluctuation against current close price. The formulas are as follows:</p><script type="math/tex; mode=display">\text{Basic upperband} = \frac{\text{High + Low}}{2} + \text{Multiplier} \times \text{ATR}</script><script type="math/tex; mode=display">\text{Basic lowerband} = \frac{\text{High + Low}}{2} - \text{Multiplier} \times \text{ATR}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">his[&#39;hl2&#39;] &#x3D; (his[&#39;high&#39;] + his[&#39;low&#39;])&#x2F;2</span><br><span class="line">his[&#39;basic_upper&#39;] &#x3D; his[&#39;hl2&#39;] + his[&#39;atr&#39;] * 2</span><br><span class="line">his[&#39;basic_lower&#39;] &#x3D; his[&#39;hl2&#39;] - his[&#39;atr&#39;] * 2</span><br><span class="line"></span><br><span class="line">his[[&#39;basic_upper&#39;, &#39;basic_lower&#39;, &#39;close&#39;]].plot(figsize&#x3D;(15,10))</span><br></pre></td></tr></table></figure><img data-src="/2022/03/18/2022-03-22-supertrend-indicator/close_atr_data.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><h3 id="3-Calculate-the-final-upper-and-lower-bands"><a href="#3-Calculate-the-final-upper-and-lower-bands" class="headerlink" title="3. Calculate the final upper- and lower- bands"></a>3. Calculate the final upper- and lower- bands</h3><p>This step is to smooth the basic upperband and lowerband. In many indicators, we use moving average or other techniques to smooth the bands. Here we’re trying to use a different way to smooth them.</p><script type="math/tex; mode=display">If\ \text{(Basic upperband < Previous final upperband)}\ or \ \text{(Previous close > Previous final upperband)}</script><script type="math/tex; mode=display">\text{Final upperband} = \text{Basic upperband}</script><script type="math/tex; mode=display">else</script><script type="math/tex; mode=display">\text{Final upperband} = \text{Previous final upperband}</script><script type="math/tex; mode=display">If\ \text{(Basic lowerband > Previous final lowerband)}\ or \ \text{(Previous close < Previous final lowerband)}</script><script type="math/tex; mode=display">\text{Final lowerband} = \text{Basic lowerband}</script><script type="math/tex; mode=display">else</script><script type="math/tex; mode=display">\text{Final upperband} = \text{Previous final lowerband}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">his[&#39;final_upper&#39;] &#x3D; his[&#39;basic_upper&#39;] - his[&#39;basic_upper&#39;]</span><br><span class="line">his[&#39;final_lower&#39;] &#x3D; his[&#39;basic_upper&#39;] - his[&#39;basic_upper&#39;]</span><br><span class="line"></span><br><span class="line">for i in range(len(his)):</span><br><span class="line">    if i &#x3D;&#x3D; 0:</span><br><span class="line">        his.loc[his.index.values[i], &#39;final_upper&#39;] &#x3D; 0</span><br><span class="line">    else:</span><br><span class="line">        if (his.loc[his.index.values[i], &#39;basic_upper&#39;] &lt; his.loc[his.index.values[i-1], &#39;final_upper&#39;]) | (his.loc[his.index.values[i-1], &#39;close&#39;] &gt; his.loc[his.index.values[i-1], &#39;final_upper&#39;]):</span><br><span class="line">            his.loc[his.index.values[i], &#39;final_upper&#39;] &#x3D; his.loc[his.index.values[i], &#39;basic_upper&#39;]</span><br><span class="line">        else:</span><br><span class="line">            his.loc[his.index.values[i], &#39;final_upper&#39;] &#x3D; his.loc[his.index.values[i-1], &#39;final_upper&#39;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(len(his)):</span><br><span class="line">    if i &#x3D;&#x3D; 0:</span><br><span class="line">        his.loc[his.index.values[i], &#39;final_lower&#39;] &#x3D; 0</span><br><span class="line">    else:</span><br><span class="line">        if (his.loc[his.index.values[i], &#39;basic_lower&#39;] &gt; his.loc[his.index.values[i-1], &#39;final_lower&#39;]) | (his.loc[his.index.values[i-1], &#39;close&#39;] &lt; his.loc[his.index.values[i-1], &#39;final_lower&#39;]):</span><br><span class="line">            his.loc[his.index.values[i], &#39;final_lower&#39;] &#x3D; his.loc[his.index.values[i], &#39;basic_lower&#39;]</span><br><span class="line">        else:</span><br><span class="line">            his.loc[his.index.values[i], &#39;final_lower&#39;] &#x3D; his.loc[his.index.values[i-1], &#39;final_lower&#39;]</span><br></pre></td></tr></table></figure><img data-src="/2022/03/18/2022-03-22-supertrend-indicator/final_data.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><h3 id="4-Define-the-Superband-indicator"><a href="#4-Define-the-Superband-indicator" class="headerlink" title="4. Define the Superband indicator"></a>4. Define the Superband indicator</h3><p>Lastly, we’re going to assemble the Superband with all the components that we have constructed above.</p><script type="math/tex; mode=display">If\ \text{(Close price < Final upperband)}\ and\ \text{(Previous Supertrend == Previous final upperband)}</script><script type="math/tex; mode=display">ext{Supertrend} = \text{Final upperband}</script><script type="math/tex; mode=display">If\ \text{(Close price > Final upperband)}\ and\ \text{(Previous Supertrend == Previous final upperband)}</script><script type="math/tex; mode=display">\text{Supertrend} = \text{Final lowerband}</script><script type="math/tex; mode=display">If\ \text{(Close price > Final lowerband)}\ and\ \text{(Previous Supertrend == Previous final lowerband)}</script><script type="math/tex; mode=display">\text{Supertrend} = \text{Final lowerband}</script><script type="math/tex; mode=display">If\ \text{(Close price < Final upperband)}\ and\ \text{(Previous Supertrend == Previous final lowerband)}</script><script type="math/tex; mode=display">\text{Supertrend} = \text{Final upperband}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">his[&#39;supertrend&#39;] &#x3D; his[&#39;basic_upper&#39;] - his[&#39;basic_upper&#39;]</span><br><span class="line"></span><br><span class="line">for i in range(len(his[&#39;supertrend&#39;])):</span><br><span class="line">    if i &#x3D;&#x3D; 0:</span><br><span class="line">        his.loc[his.index.values[i], &#39;supertrend&#39;] &#x3D; 0</span><br><span class="line">    elif (his.loc[his.index.values[i-1], &#39;supertrend&#39;] &#x3D;&#x3D; his.loc[his.index.values[i-1], &#39;final_upper&#39;]) and (his.loc[his.index.values[i], &#39;close&#39;] &lt; his.loc[his.index.values[i], &#39;final_upper&#39;]):</span><br><span class="line">        his.loc[his.index.values[i], &#39;supertrend&#39;] &#x3D; his.loc[his.index.values[i], &#39;final_upper&#39;]</span><br><span class="line">    elif (his.loc[his.index.values[i-1], &#39;supertrend&#39;] &#x3D;&#x3D; his.loc[his.index.values[i-1], &#39;final_upper&#39;]) and (his.loc[his.index.values[i], &#39;close&#39;] &gt; his.loc[his.index.values[i], &#39;final_upper&#39;]):</span><br><span class="line">        his.loc[his.index.values[i], &#39;supertrend&#39;] &#x3D; his.loc[his.index.values[i], &#39;final_lower&#39;]</span><br><span class="line">    elif (his.loc[his.index.values[i-1], &#39;supertrend&#39;] &#x3D;&#x3D; his.loc[his.index.values[i-1], &#39;final_lower&#39;]) and (his.loc[his.index.values[i], &#39;close&#39;] &gt; his.loc[his.index.values[i], &#39;final_lower&#39;]):</span><br><span class="line">        his.loc[his.index.values[i], &#39;supertrend&#39;] &#x3D; his.loc[his.index.values[i], &#39;final_lower&#39;]</span><br><span class="line">    elif (his.loc[his.index.values[i-1], &#39;supertrend&#39;] &#x3D;&#x3D; his.loc[his.index.values[i-1], &#39;final_lower&#39;]) and (his.loc[his.index.values[i], &#39;close&#39;] &lt; his.loc[his.index.values[i], &#39;final_lower&#39;]):</span><br><span class="line">        his.loc[his.index.values[i], &#39;supertrend&#39;] &#x3D; his.loc[his.index.values[i], &#39;final_upper&#39;]</span><br><span class="line"></span><br><span class="line">his[[&#39;close&#39;, &#39;supertrend&#39;]].plot(figsize&#x3D;(15,10))</span><br></pre></td></tr></table></figure><img data-src="/2022/03/18/2022-03-22-supertrend-indicator/supertrend.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><h1 id="Strategy-setups-for-our-backtests"><a href="#Strategy-setups-for-our-backtests" class="headerlink" title="Strategy setups for our backtests"></a>Strategy setups for our backtests</h1><p>After introducing what Superband is and how to calculate it, we’re now going to backtest this indicator in conjunction with other indicators and see how they perform.</p><h2 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h2><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h2 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h2><ol><li>Sort stocks by <code>PERatio</code>, <code>EPS</code>, <code>ROE</code>, <code>NetIncome</code> and take top 60%</li><li>Sort stocks by <code>PBRatio</code>, from high to low</li></ol><h2 id="Rebalancing-strategy"><a href="#Rebalancing-strategy" class="headerlink" title="Rebalancing strategy"></a>Rebalancing strategy</h2><ol><li>Recalculate our universe and indicators every day.</li><li>We keep 10 stocks that have buy-in signals and with the highest <code>PBRatio</code>.</li><li>We assign weight to each position evenly.</li><li>We don’t adjust the weight of each stock until we close these positions.</li></ol><h2 id="Backtest-time-frame"><a href="#Backtest-time-frame" class="headerlink" title="Backtest time frame"></a>Backtest time frame</h2><p><strong>Backtest Date:</strong> <code>2019, 1 ,10</code> ~ <code>2022, 2, 14</code></p><h2 id="Signal-generation"><a href="#Signal-generation" class="headerlink" title="Signal generation"></a>Signal generation</h2><p>There’s no technical indicator that can be 100% accurate and so is Supertrend. Therefore we are going to backtest the performance of it combining other famous indicators.</p><h3 id="1-Supertrend-momentum-strategy"><a href="#1-Supertrend-momentum-strategy" class="headerlink" title="1. Supertrend momentum strategy"></a>1. Supertrend momentum strategy</h3><p>In this strategy, we buy when the close breaks through the Supertrend indicator, and sell when the close price falls below the Supertrend indicator.</p><h3 id="2-Supertrend-mean-reversion-strategy"><a href="#2-Supertrend-mean-reversion-strategy" class="headerlink" title="2. Supertrend mean-reversion strategy"></a>2. Supertrend mean-reversion strategy</h3><p>Compared to the above strategy, we do everything in reverse. We buy when the close price falls below the Supertrend, and sell when the close price goes above the Supertrend.</p><h3 id="3-Supertrend-with-RSI-indicator"><a href="#3-Supertrend-with-RSI-indicator" class="headerlink" title="3. Supertrend with RSI indicator"></a>3. Supertrend with RSI indicator</h3><p>We buy when the close price goes above the Supertrend also when RSI is above 50, and sell when the close price is under Supertrend and when RSI is below 50.</p><h3 id="4-Supertrend-with-EMA20-indicator"><a href="#4-Supertrend-with-EMA20-indicator" class="headerlink" title="4. Supertrend with EMA20 indicator"></a>4. Supertrend with EMA20 indicator</h3><p>We buy when the close price goes above the Supertrend also when 20-day EMA is above the close price, and sell when 20-day EMA is below the close price.</p><h3 id="5-Supertrend-with-EMA200-indicator"><a href="#5-Supertrend-with-EMA200-indicator" class="headerlink" title="5. Supertrend with EMA200 indicator"></a>5. Supertrend with EMA200 indicator</h3><p>We buy when the close price goes above the Supertrend also when 200-day EMA is above the close price, and sell when 200-day EMA is below the close price.</p><h3 id="6-Supertrend-with-William-R-indicator"><a href="#6-Supertrend-with-William-R-indicator" class="headerlink" title="6. Supertrend with William R indicator"></a>6. Supertrend with William R indicator</h3><p>We buy when the close price goes above the Supertrend also when the <a href="https://www.investopedia.com/terms/w/williamsr.asp">William R indicator</a> is below -50, and sell when the close price is under Supertrend and when the William R indicator is above -50.</p><h3 id="7-Supertrend-with-Chande-momentum-oscillator"><a href="#7-Supertrend-with-Chande-momentum-oscillator" class="headerlink" title="7. Supertrend with Chande momentum oscillator"></a>7. Supertrend with Chande momentum oscillator</h3><p>We buy when the close price goes above the Supertrend also when the <a href="https://www.investopedia.com/terms/c/chandemomentumoscillator.asp">Chande momentum oscillator</a> is below -50, and sell when the close price is under Supertrend and when the Chande momentum oscillator is above 50.</p><h3 id="8-Supertrend-with-10-trailing-stop-loss"><a href="#8-Supertrend-with-10-trailing-stop-loss" class="headerlink" title="8. Supertrend with 10% trailing stop loss"></a>8. Supertrend with 10% trailing stop loss</h3><p>In addition to the setup of the first momentum strategy, we add a trail stop loss if the close price falls 10% in two consecutive days.</p><h2 id="Backtest-result"><a href="#Backtest-result" class="headerlink" title="Backtest result"></a>Backtest result</h2><div class="table-container"><table><thead><tr><th>Strategy</th><th>Total Trades</th><th>PSR</th><th>Unrealized</th><th>Fee</th><th>Net profit</th><th>Return</th><th>Sharpe</th><th>Average Win</th><th>Average Loss</th><th>Compounding annual return</th><th>MDD</th><th>Profit-loss ratio</th><th>Win rate</th><th>Alpha</th><th>Beta</th><th>Annual variance</th></tr></thead><tbody><tr><td>momentum</td><td>607</td><td>41.256%</td><td>$12622.29</td><td>-$2470.65</td><td>$132108.37</td><td>142.34%</td><td>1.007</td><td>1,83%</td><td>-0.75%</td><td>32.7%</td><td>32.9%</td><td>2.43</td><td>42%</td><td>0.152</td><td>0.684</td><td>0.064</td></tr><tr><td>momentum_trailing_loss</td><td>635</td><td>22.944%</td><td>$9576.2</td><td>-$2201</td><td>$59980.43</td><td>67.39%</td><td>0.698</td><td>1.32%</td><td>-0.69%</td><td>17.898%</td><td>30.2%</td><td>1.91</td><td>42%</td><td>0.017</td><td>0.603</td><td>0.042  </td></tr><tr><td>mean-reversion</td><td>366</td><td>21.47%</td><td>-$17538.55</td><td>-$1295.34</td><td>$83620</td><td>64.81%</td><td>0.665</td><td>1.09%</td><td>-1.33%</td><td>17.315%</td><td>35.2%</td><td>0.82</td><td>70%</td><td>0.013</td><td>0.873</td><td>0.046</td></tr><tr><td>rsi</td><td>607</td><td>41.256%</td><td>$12622.29</td><td>-$2470.65</td><td>$132108.37</td><td>142.34%</td><td>1.007</td><td>1,83%</td><td>-0.75%</td><td>32.7%</td><td>32.9%</td><td>2.43</td><td>42%</td><td>0.152</td><td>0.684</td><td>0.064</td></tr><tr><td>ema20</td><td>970</td><td>10.581%</td><td>$3031.88</td><td>-$3230.26</td><td>$32780.4</td><td>34.6%</td><td>0.433</td><td>1.05%</td><td>-0.46%</td><td>9.437%</td><td>30.6%</td><td>2.26</td><td>35%</td><td>0.01</td><td>0.496</td><td>0.037</td></tr><tr><td>ema200</td><td>164</td><td>33.474%</td><td>-$3699</td><td>-$640.42</td><td>$161398.96</td><td>157.22%</td><td>0.913</td><td>6.00%</td><td>-1.20%</td><td>35.251%</td><td>38.5%</td><td>4.98</td><td>36%</td><td>0.087</td><td>1.013</td><td>0.108</td></tr><tr><td>william_r</td><td>28</td><td>24.792%</td><td>$63412</td><td>-$68</td><td>$19756</td><td>83.14%</td><td>0.733</td><td>4.90%</td><td>-1.44%</td><td>21.336%</td><td>41.00%</td><td>3.39</td><td>56%</td><td>-0.011</td><td>0.891</td><td>0.058</td></tr><tr><td>chande_momentum</td><td>0</td><td>0</td><td>$0</td><td>$0</td><td>$0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0   </td></tr></tbody></table></div><h2 id="Takeout-from-the-backtest-results"><a href="#Takeout-from-the-backtest-results" class="headerlink" title="Takeout from the backtest results"></a>Takeout from the backtest results</h2><p>The SPY return in our backtest period is around 74%. By looking at the statistics above, all the backtests seem very promising. But all the PSR (Probabilistic Sharpe Ratio) are fairly low (<em>See <a href="https://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/">here</a> if you don’t know what PSR stands for</em>). Also, the win rate in every backtest scenario is hardly over 50%. All these facts indicate that our Supertrend strategies don’t work really well.</p><p>There are other things that we can try to add to optimize our strategies:</p><ul><li>Find the appropriate universe that fit the nature of the Supertrend indicator.</li><li>Fine-tune the parameters used in our indicators</li><li>Combine the Supertrend indicator with other indicators.</li></ul><p>Of course, exploring the combination of different indicators could be a good way to level up your backtest score. But make sure you don’t go too extreme and go overfitting. Remember, history won’t repeat itself in the stock market. What we’re doing here is simply trying to find a way that can help us better confirm the time when the trend changes.</p><hr><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://wire.insiderfinance.io/backtest-supertrend-crossover-strategy-with-elasticsearch-ab048a3c6b8">Backtest supertrend crossover strategy</a></li><li><a href="https://www.elearnmarkets.com/blog/supertrend-indicator-strategy-trading/">Supertrend Indicator : How to use for Intraday trading?</a></li><li><a href="https://www.tradingfuel.com/supertrend-indicator-formula-and-calculation/">What is the SuperTrend Indicator</a></li><li><a href="https://medium.com/codex/step-by-step-implementation-of-the-supertrend-indicator-in-python-656aa678c111">A Step-By-Step Guide to Implementing the SuperTrend Indicator in Python</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/03/18/2022-03-22-supertrend-indicator/cover.png&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;I have to admit that my attention was drawn by the name of this indicator at the first glance. Therefore my interest in implementing a series of backtesting against this indicator was unavoidable. In today’s article, we’re going to introduce what Supertrend indicator is about and how to produce one yourself. After that, I will show you a series of backtest that I have performed and see what we can get out of them.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Momentum" scheme="http://mikelhsia.github.io/tags/Momentum/"/>
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>【ML algo trading】 IV - How to analyze how good my machine learning strategy is?</title>
    <link href="http://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/"/>
    <id>http://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/</id>
    <published>2022-02-19T06:51:12.000Z</published>
    <updated>2022-08-24T18:00:02.297Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/02/19/2022-02-17-machine-learning-performance-evaluation/cover.jpeg" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><p>Phew! With all the hard work of fetching data, processing factors, splitting training and testing datasets, selecting the right model to train, you finally have your machine learning model trained and be able to test how powerful it is. You’re very excited to feed a bunch of test data and got a 100%+ rate of return. What a success! But be careful, <code>rate of return</code> is not the sole factor to evaluate the quality of your trading strategy. There are other metrics that help you to understand the strengths and weaknesses of your trading strategy, and you can improve your trading behavior based on these metrics.</p><a id="more"></a><p>Here are a group of metrics that I would like to recommend to you as I’ve calculated and adopted them in my own quantitative trading projects. These metrics are objective enough for you to evaluate the quality of your strategy, and they are relatively easy enough to calculate in your own framework. So, bear with me and hear me out.</p><blockquote><p>Previous reading:</p><ul><li><a href="https://mikelhsia.github.io/2021/04/22/2021-04-22-machine-learning-intro/">【Machine Learning】 Part I - 10 minutes to learn what I know about machine learning in quantitative trading</a></li><li><a href="https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/">【Machine Learning】 Part II - How to build a machine learning boilerplate?</a></li><li><a href="https://mikelhsia.github.io/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/">【Machine Learning】 Part III - 5 myths about practicing quant trading with machine learning</a></li></ul></blockquote><h2 id="General-Characteristics-of-your-strategy"><a href="#General-Characteristics-of-your-strategy" class="headerlink" title="General Characteristics of your strategy"></a>General Characteristics of your strategy</h2><ul><li><strong>Average Capacity</strong> is the maximum number of stocks that you would like to be included in your portfolio. This is actually not a metric to evaluate the quality of your performance, but it’s very likely to influence the performance of your strategy, considering holding more stocks in your portfolio potentially increases the diversity.</li><li><strong>Average AUM</strong> stands for <em>Asset Under Management</em>. This indicates how much money is currently available for trading stocks.</li><li><strong>Average holding period</strong> could range from minutes to years, depending on the nature of your trading strategy and on the observing window length. If your strategy is observing daily MACD cross, the minimum average holding period of your strategy is 1 day.</li></ul><h2 id="Performance-related-metrics"><a href="#Performance-related-metrics" class="headerlink" title="Performance-related metrics"></a>Performance-related metrics</h2><ul><li><strong>Annualized rate of return</strong> is the most common metric to evaluate your strategy. It’s an obvious decision to make to choose between a strategy that produces 30% and a strategy that makes 300% annually. However, how do we prioritize the strategies that one makes 30% and the other one makes 33%? There we need other metrics to come into play to help us differentiate good and bad strategies.<script type="math/tex; mode=display">\text{Annualized rate of return} = \frac{\text{Money made annually}}{\text{Total amount of money invested initially}}</script></li><li><strong>Win rate</strong>. Simple as that. It means how many trades made you profit among all the trades you made.<script type="math/tex; mode=display">\text{Win rate} = \frac{\text{The number of trades that make positive return}}{\text{The number of total trades made}}</script></li></ul><h2 id="Risk-related-metrics"><a href="#Risk-related-metrics" class="headerlink" title="Risk related metrics"></a>Risk related metrics</h2><ul><li><strong>Annualized volatility</strong> is a traditional method to evaluate the risk of your portfolio. This essentially evaluated how volatile your portfolio value was. The higher the volatility, the more likely your portfolio value will be influenced by the market or the macroeconomic. This risk can be mitigated by adding stocks from different industries to diversify your portfolio.</li><li><strong>Max Drawdown</strong> indicates the maximum percentage loss during the observation periods.<script type="math/tex; mode=display">\text{Max Drawdown} = \frac{\text{Through Value} - \text{Peak Value}}{\text{Peak Value}}</script></li></ul><img data-src="/2022/02/19/2022-02-17-machine-learning-performance-evaluation/maxdrawdown.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Code snippet to calculate the Max Drawdown</i></p><h2 id="Efficiency-related-metrics"><a href="#Efficiency-related-metrics" class="headerlink" title="Efficiency related metrics"></a>Efficiency related metrics</h2><ul><li><strong>Sharpe Ratio</strong>‘s calculation is relatively easy as dividing the portfolio excess return by the standard deviation of the portfolio excess return. However, it is probably the first metric you’re going to look at when evaluating the strategy. It stands for the excess return that you’re going to get by taking each unit of risk, which is volatility.<script type="math/tex; mode=display">\text{Sharpe Ratio} = \frac{\text{Portfolio's excess return}}{\text{Standard deviation of the portfolio's excess return}}</script>$\text{where Portfolio’s excess return} = \text{Portfolio return} - \text{Risk-free rate}$</li><li><strong>Information Ratio</strong> is similar to the Sharpe ratio, but it is used to evaluate the ability to outperform the selected benchmark.<script type="math/tex; mode=display">\text{Information ratio} = \frac{\text{Portfolio return} - \text{Benchmark return}}{\text{Standard deviation of difference between portfolio and benchmark return}}</script></li><li><strong>Sortino Ratio</strong> is a variant of the Sharpe ratio. It evaluates the portfolio’s return given solely the downside risk, as the upside volatility is beneficial and we don’t worry about the upside volatility.<script type="math/tex; mode=display">\text{Sortino Ratio} = \frac{\text{Portfolio's excess return}}{\text{Standard deviation of the downside}}</script></li><li><strong>Calmar Ratio</strong> is a useful way to evaluate the portfolio return against the maximum risk within the given time period. If the maximum drawdown is huge, you will get a relatively small Calmar ratio. This could potentially mean that your portfolio is relatively vulnerable when black swan incidents.<script type="math/tex; mode=display">\text{Calmar Ratio} = \frac{\text{Average Annual Rate of Return}}{\text{Maximum Drawdown}}</script></li><li><strong>Probabilistic Sharpe Ratio (PSR)</strong> is kind of an improvement version of the Sharpe ratio based on the statistical theory. Instead of calculating the Sharpe ratio using the given time series of return, PSR uses the skewness and kurtosis to generate an estimated normal distribution of the rate of return. Therefore, you are able to know the probability of your portfolio getting the estimated rate of return. You can check <a href="https://quantdare.com/probabilistic-sharpe-ratio/">here</a> for more details.<img data-src="/2022/02/19/2022-02-17-machine-learning-performance-evaluation/psr.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Code snippet to calculate the PSR</i></p></li></ul><h2 id="Classification-scores-Machine-learning-strategy-specific"><a href="#Classification-scores-Machine-learning-strategy-specific" class="headerlink" title="Classification scores (Machine learning strategy specific)"></a>Classification scores (Machine learning strategy specific)</h2><ul><li><strong>Accuracy</strong> is the ratio of correctly predicted positive observations to the total positive observations.<script type="math/tex; mode=display">Accuracy = \frac{TP+TN}{TP+TN+FP+FN}</script></li><li><strong>Precision</strong> is the ratio of correctly predicted positive observation and total predicted positive observation. It shows how precise our model is.<script type="math/tex; mode=display">Precision = \frac{TP}{TP+FP}</script></li><li><strong>Recall</strong> is the ratio of the correct predicted positive observation and the total observation in the class.<script type="math/tex; mode=display">Recall = \frac{TP}{TP+FN}</script></li><li><strong>F1-Score</strong> is the weighted average of recall and precision.<script type="math/tex; mode=display">\text{F1-Score} = \frac{2*(Recall * Precision)}{Recall + Precision}</script></li><li><strong>AUC(Area Under roc Curve)</strong> is a metric that represents the classification ability of a machine learning model. An excellent model has AUC near to the 1 which means it has a good measure of separability. A model has an AUC near 0 which means it predicts the positive as the negative and vice versa. But it doesn’t necessary mean this model is poor. It still tells us that this model is able to separate the right and wrong samples. If a model has AUC equal to 0.5, that means this model is useless as it has no ability to predict the outcome. See more details <a href="https://towardsdatascience.com/understanding-auc-roc-curve-68b2303cc9c5">here</a></li><li><strong>Matthews correlation coefficient (MCC)</strong> is a relatively general measure of “accuracy” of a predictive model that can give insights about how much we can rely on the model.<script type="math/tex; mode=display">\text{MCC} = \frac{(TP \times TN) - (FP \times FN)}{\sqrt{(TP+FP)(TP+FN)(TN+FP)(TN+FN)}}</script></li><li><strong>Average return from hits</strong> is the average rate of return from bets that generate profit.</li><li><strong>Average return from misses</strong> is the average rate of return from bets that generate loss.</li></ul><h2 id="Others-metrics"><a href="#Others-metrics" class="headerlink" title="Others metrics"></a>Others metrics</h2><ul><li><strong>Stratified Analysis</strong> to me is avery important steps in my research process. It tells me whether my model is capable of picking the stocks that have the highest return among all stocks.<img data-src="/2022/02/19/2022-02-17-machine-learning-performance-evaluation/stratified.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Stratified analysis diagram</i></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">group_number &#x3D; 6</span><br><span class="line">group_label &#x3D; [f&#39;R&#123;x&#125;&#39; for x in range(group_number, 0, -1)]</span><br><span class="line"></span><br><span class="line">data[&#39;rate&#39;] &#x3D; data.groupby(&#39;date&#39;)[&#39;score&#39;].apply(lambda x : pd.cut(x, bins&#x3D;group_number, labels&#x3D;group_label))</span><br><span class="line">data[&#39;log_rtn&#39;] &#x3D; np.log(test[&#39;rtn&#39;] + 1)</span><br><span class="line"></span><br><span class="line">x &#x3D; data.groupby([&#39;date&#39;, &#39;rate&#39;])[&#39;log_rtn&#39;].apply(lambda x: x.sum()&#x2F;len(x)).reset_index().set_index([&#39;rate&#39;, &#39;date&#39;])</span><br><span class="line">z &#x3D; pd.DataFrame(index&#x3D;x.loc[&#39;R1&#39;].index)</span><br><span class="line"></span><br><span class="line">for i in range(1,group_number+1):</span><br><span class="line">    try:</span><br><span class="line">        z[f&#39;R&#123;i&#125;&#39;] &#x3D; x.loc[f&#39;R&#123;i&#125;&#39;,:].cumsum()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">plt.figure(figsize&#x3D;(15, 10))</span><br><span class="line">plt.xticks(rotation&#x3D;90)</span><br><span class="line">plt.yticks(rotation&#x3D;45)</span><br><span class="line"></span><br><span class="line">sns.lineplot(data&#x3D;z, dashes&#x3D;False)</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Code snippet to generate stratified analysis diagram</i></p><ul><li><p><strong>Benchmark performance diagram</strong> is simply to put your portfolio return on the chart against your selected benchmark return. In fact, there are a lot of things that can be found in this comparison. It tells whether you’re portfolio still grows when the benchmark return decline, whether your portfolio can grow faster in the bull market period, and many other things.</p><img data-src="/2022/02/19/2022-02-17-machine-learning-performance-evaluation/benchmark.png" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Portfolio return v.s. benchmark return</i></p></li><li><p><strong>PnL</strong> is the profit and loss during the entire observation period.</p></li><li><strong>Turnover fee</strong> is the sum of the transaction fees that costs you while trading with this strategy. If you’re trading too frequently, your profit could be offset by this seemingly insignificant cost. The turnover fee could be calculated by the product of the number of total trades and the transaction fees per trade.</li><li><strong>Beta and Alpha</strong> both derive from the CAPM model. Alpha stands for the excess return of your strategy, and beta represents the systematic return.<script type="math/tex; mode=display">Return_{Portfolio} - Return_{Riskfree} = \beta \times (Return_{Market} - Return_{Riskfree}) + \alpha</script></li></ul><p>These are the metrics that I’ve been using while evaluating my trading strategy. Please do tell me what other metrics you think are useful.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/02/19/2022-02-17-machine-learning-performance-evaluation/cover.jpeg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;Phew! With all the hard work of fetching data, processing factors, splitting training and testing datasets, selecting the right model to train, you finally have your machine learning model trained and be able to test how powerful it is. You’re very excited to feed a bunch of test data and got a 100%+ rate of return. What a success! But be careful, &lt;code&gt;rate of return&lt;/code&gt; is not the sole factor to evaluate the quality of your trading strategy. There are other metrics that help you to understand the strengths and weaknesses of your trading strategy, and you can improve your trading behavior based on these metrics.&lt;/p&gt;</summary>
    
    
    
    <category term="Machine Learning" scheme="http://mikelhsia.github.io/categories/Machine-Learning/"/>
    
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>Quants! Learn from your foe - &quot;Value Investing&quot;</title>
    <link href="http://mikelhsia.github.io/2022/01/03/2022-01-10-value-investing-part1/"/>
    <id>http://mikelhsia.github.io/2022/01/03/2022-01-10-value-investing-part1/</id>
    <published>2022-01-03T14:57:10.000Z</published>
    <updated>2022-01-04T14:37:17.183Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/01/03/2022-01-10-value-investing-part1/cover.jpg" class="" width="600"><p>Value investing is an investing strategy that has been popular for decades. The main idea involves picking quality stocks among distressed companies, buying and holding them for the long-term (over several years), and expecting the good quality stocks to remain good and rebound from the valley. In short, value investing is to <b><i>buy good companies at a good price</i></b>. In this post, we’re going to go through the framework that some of the value investors use to evaluate the company value.</p><a id="more"></a><h1 id="What-exactly-is-Value-Investing"><a href="#What-exactly-is-Value-Investing" class="headerlink" title="What exactly is Value Investing?"></a>What exactly is Value Investing?</h1><p>Warren Buffett is probably the most well-known value investor today, but there are also many other value investors in the field, such as Benjamin Graham (Buffett’s mentor), Charlie Munger (Buffett’s business partner), and Joel Greenblatt. Among them, Benjamin Graham is highly praised as the “<em>Father of Value Investing</em>“ and has a significant place in the field. There are also famous case studies such as Buffett’s bet on Coca-Cola in 1988 and Geico in 1951, which both generate a massive return. In addition, the previous post of <a href="https://mikelhsia.github.io/2020/08/21/2020-08-21-magic-formula-vs-Acquirer-Multiples/">An investment strategy that takes you three days a year</a> was also derived from the <a href="https://www.thebalance.com/what-is-magic-formula-investing-4150688">magic formula</a> that was created by <em>Joel Greenblatt</em>.</p><img data-src="/2022/01/03/2022-01-10-value-investing-part1/coca.png" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>The stock price of Coca-Cola since 1988</i></p><p>Value investors advocate the idea of finding the stocks whose market value (stock price) are traded way lower than their company intrinsic value. By using the data from fundamental analysis and company annual reports every year, value investors would use their framework to calculate the company intrinsic value with assuming growth rate for the upcoming years. If the gap (which was so called “<em>safety margin</em>“) between the market value and the calculated intrinsic value is larger enough, it is believed that the discounted market value is simply due to public opinions and emotions. The company itself is still healthy enough to generate positive net income to grow continuously, pumping its stock price back to where it should be or even higher.</p><p>In recent years, analysts and investors are saying that the value stocks are no longer attractive and throwing themselves into growth stocks’ arms such as FAANG, Tesla, Roku, and so on. However, there are still others who believe that the value investing was still profitable because:</p><ol><li>The economic cycle is extended. So the stocks you invested simply need more time to rebound. See <a href="https://www.schroders.com/en/uk/the-value-perspective/blog/all-blogs/why-we-still-believe-in-value-investing/">here</a></li><li>The profit was diluted because the value investing strategy is too well-known and was adopted by too many investors and investing institutions. See <a href="https://www.forbes.com/sites/simonmoore/2021/01/03/is-value-investing-dead-not-so-fast-says-a-recent-study/?sh=38edf83e1cd4">here</a></li></ol><img data-src="/2022/01/03/2022-01-10-value-investing-part1/value_vs_growth.png" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Value stocks v.s. growth stocks in recent years</i></p><p>Either way, I believe that there are some ideas inheres within the value investing strategy itself which are still valuable and beneficial in adopting them into the quantitative strategies. So now, let’s have a look.</p><h1 id="The-evaluation-framework-of-Value-Investing"><a href="#The-evaluation-framework-of-Value-Investing" class="headerlink" title="The evaluation framework of Value Investing"></a>The evaluation framework of Value Investing</h1><p>There are a lot of methodologies and frameworks that were developed within Value Investing. The book “<strong><em>Value Investing: From Graham to Buffett and Beyond</em></strong>“ by <em>Bruce C.N. Greenwald</em>, <em>Judd Kahn</em>, <em>Paul D. Sonkin</em>, and <em>Michael van Biema</em> promotes a framework that separates the whole evaluation process into several stages: 1. calculate the Asset Value (AV) of the company, 2. calculate the Earnings Power Value (EPV) of the company, 3. compare to the market value and see whether we’ll be able to make the decision to invest in this company or not.</p><h2 id="Asset-Value-AV"><a href="#Asset-Value-AV" class="headerlink" title="Asset Value (AV)"></a>Asset Value (AV)</h2><p>The Asset Value is calculated to evaluate the actual value of the company, including tangible assets and intangible assets. Tangible assets include <em>PPE</em>, <em>marketable securities</em>, <em>inventory</em>, and so on. They can be found in the balance sheet in the annual/quarter report. However, the one-the-book asset value doesn’t reflect its value right now, so we need to make adjustments on these items in order to find out the current value of the company asset.</p><p>Intangible assets include <em>goodwill</em>, <em>brand value</em>, <em>workforce</em>, <em>product portfolio</em>, <em>clients/contracts</em>, and everything. As most of these assets are not documented in the balance sheet, we need to figure out a way to estimate the ballpark amount of these items. For example, the workforce cost is already included in the SG&amp;A in the balance sheet but not the HR cost on recruiting this workforce. Therefore, if there is a company A that has 1,000 blue-collar workers, we can take the US average wages of blue-collar workers to calculate the total cost.</p><script type="math/tex; mode=display">1,000 \times \$ 33,762 = \$ 33\ million</script><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>According to <a href='https://www.comparably.com/salaries/salaries-for-blue-collar-worker'>www.comparably.com</a></i></p><p>We assume the cost to recruit the workforce is 10% of the total cost of the workforce, then we’ll be able to calculate the cost of the recruitment to be:</p><script type="math/tex; mode=display">\$ 33\ million \times 0.1 = \$ 3.3\ million</script><p>This would be one of the adjustments that we made while calculating the company asset value.</p><h2 id="Earnings-Power-Value-EPV"><a href="#Earnings-Power-Value-EPV" class="headerlink" title="Earnings Power Value (EPV)"></a>Earnings Power Value (EPV)</h2><p>Earnings Power Value essentially means the capability of a company to make money, and it’s not just any money that a company makes. We’re looking for <em>Net Operating Profit After Tax (NOPAT)</em>, meaning the income from financial activities and from investing activities. The NOPAT of a company could showcase the ability to earn net income through selling the company’s services or products. After all, selling services and goods to the customers is the major business activity of the company.</p><p>Also, we need to make sure the company can sustainably make this amount of money or more. If a company’s NOPAT fluctuates a lot, this would implicitly indicate that the company business is not stable enough to support sustainable growth.</p><p>A quick way to explain the way to calculate the EPV is:</p><script type="math/tex; mode=display">\begin{align*}&\ \ \ \ \ \text{Revenue}\\-&\ \ \ \ \ \text{Operating expense}\\-&\ \ \ \ \ \text{Depreciation and amortization charges}\\-&\ \ \ \ \ \text{Tax}\\--&--------------\\&\ \ \ \ \ \text{Net operating profit after tax}\\\end{align*}</script><p>Lastly, since we have been able to approximately evaluate the NOPAT of the company we can use <a href="https://www.investopedia.com/terms/d/dcf.asp">DCF (Discounted Cash Flow)</a> model to calculate the EPV of the company. We use the <em><a href="https://www.investopedia.com/terms/w/wacc.asp">Weighted Average Cost of Capital (WACC)</a></em> as the discount rate in our calculation so that we take the actual cost of working capital into account. Then, we will get a number that represents the value of an investment that can generate this NOPAT steadily.</p><script type="math/tex; mode=display">EPV = \frac{NOPAT(Net Operating Profit After Tax)}{\text{WACC(Weighted Average Cost of Capital)}}</script><h2 id="The-final-call-on-the-decision"><a href="#The-final-call-on-the-decision" class="headerlink" title="The final call on the decision"></a>The final call on the decision</h2><p>Once we have our AV and EPV ready, we can start making our final call on whether we should long this investment or not. Here’s a general principle to follow:</p><ul><li>If AV is higher than EPV, meaning the industry is declining and this company won’t be able to make enough profit as it’s mismanagement of its assets.</li><li>If AV is equal to EPV, meaning this company is able to efficiently manage its asset to generate enough profit.</li><li>If AV is below the EPV, meaning this company’s management team has a superior ability to manage its asset. Also, this indicates that this company has sufficient power to build the barriers to entry to outcompete the other competitors in this industry.</li></ul><p>Then, we compare the EPV with the market value of the company to see whether this company is currently undervalued or overvalued. If it is undervalued, maybe this is the timing for us to enter this trade.</p><img data-src="/2022/01/03/2022-01-10-value-investing-part1/value.png" class="" width="350"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>AV, EPV, and market value</i></p><h1 id="Wrap-up"><a href="#Wrap-up" class="headerlink" title="Wrap up"></a>Wrap up</h1><p>What I have demonstrated above is only a part of the value investing methodology. There are more technics, assumptions, and methodologies involved that are too complex to be tuck into one single post. So I’ll stop it right here so that you can discover more by yourself.</p><p>A lot of people say that Value Investing is dying. But I think value investing is a tool and mindset, and also an essence of analysts’ experience. There are a lot of valuable thoughts that can be extracted and be applied to quantitative trading. For example, stock-picking to form your stock pool, evaluating a company to see it is under- or overvalued, and also processing the fundamental data to make it more meaningful to conduct a second analysis. I believe learning how value investors think would definitely benefit your capability to build an even better quantitative trading strategy.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/01/03/2022-01-10-value-investing-part1/cover.jpg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p&gt;Value investing is an investing strategy that has been popular for decades. The main idea involves picking quality stocks among distressed companies, buying and holding them for the long-term (over several years), and expecting the good quality stocks to remain good and rebound from the valley. In short, value investing is to &lt;b&gt;&lt;i&gt;buy good companies at a good price&lt;/i&gt;&lt;/b&gt;. In this post, we’re going to go through the framework that some of the value investors use to evaluate the company value.&lt;/p&gt;</summary>
    
    
    
    <category term="Value Investing" scheme="http://mikelhsia.github.io/categories/Value-Investing/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Fundamental Analysis" scheme="http://mikelhsia.github.io/tags/Fundamental-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Four strategies of using RSI indicator to better time your market entry</title>
    <link href="http://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/"/>
    <id>http://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/</id>
    <published>2021-11-03T04:09:19.000Z</published>
    <updated>2021-11-09T04:14:24.294Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/11/03/2021-11-06-rsi-indicator/cover.jpeg" class="" width="600"><p>We talked about how to use MACD indicator and other secondary indicators to tell when to long certain stocks in the previous articles. If you haven’t read them yet, below are the links to catch up on where we left. But, is this the end of the optimization of our trading strategy? In this article, we’re going to demonstrate the power of RSI indicators and see how this indicator can be a help to our current trading strategy.</p><ul><li><a href="https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/">How to save your silver bullets with MACD strategy?</a></li><li><a href="https://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/">Optimize your MACD strategies with advanced indicators</a></li></ul><a id="more"></a><h1 id="Train-of-thought-How-to-optimize-our-trading-strategy"><a href="#Train-of-thought-How-to-optimize-our-trading-strategy" class="headerlink" title="Train of thought - How to optimize our trading strategy"></a>Train of thought - How to optimize our trading strategy</h1><img data-src="/2021/11/03/2021-11-06-rsi-indicator/train_of_thought.png" class="" width="300"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Train of thought</i></p><h3 id="1-Where-to-start"><a href="#1-Where-to-start" class="headerlink" title="1. Where to start?"></a>1. Where to start?</h3><p>The definition of optimizing the trading strategy can be simplified as increasing the money you make in this very trading strategy. It always comes down to two directions: either profit more, or you lose less compared to our benchmark strategy. Instead of spending more time studying the topic of stopping loss, I decided to give it one more shot to add another momentum indicator to see whether that can better time the entry.</p><h3 id="2-What-I-have-in-the-trading-strategy"><a href="#2-What-I-have-in-the-trading-strategy" class="headerlink" title="2. What I have in the trading strategy"></a>2. What I have in the trading strategy</h3><p>The <a href="https://www.tradingview.com/support/solutions/43000502344-macd-moving-average-convergence-divergence/">MACD</a> indicator I have adopted in our strategy is a momentum indicator, indicating the stock price trend by using 9-day EMA and 26-day EMA. When the fast EMA(9-day EMA) crosses above the slow EMA(26-day EMA), it gives us the idea that the stock price seems to have the tendency to go upward.</p><h3 id="3-What-we-can-add-to-the-trading-strategy"><a href="#3-What-we-can-add-to-the-trading-strategy" class="headerlink" title="3. What we can add to the trading strategy"></a>3. What we can add to the trading strategy</h3><p>Since we have the future tendency indicator, I believe we also need to indicator to point us where the stock price is at compared to the stock price these days. There are many options, such as SMA (Simple Moving Average), oscillators, <a href="https://www.tradingview.com/support/solutions/43000501840-bollinger-bands-bb/">Bollinger Bands</a>, we can choose from. Here, we pick the RSI indicator to apply to our strategy.</p><h3 id="4-What-is-RSI"><a href="#4-What-is-RSI" class="headerlink" title="4. What is RSI?"></a>4. What is RSI?</h3><p>The <strong>Relative Strength Index (RSI)</strong> is a momentum indicator used in technical analysis that measures the magnitude of recent price movement and evaluates overbought or oversold conditions in the price of a stock or other asset. The MACD, on the other hand, measures the momentum of those price moves. This means that an asset could be overbought or oversold but is still able to show positive momentum in that direction. When both indicators concur, we get a better idea of what is the state of the current stock price, enhance the confidence of our bet side, and hopefully increase our win rate and total profit. In short, the indicator constructed in our trading strategy would consist of:</p><ul><li>MACD: Prediction of the future trend</li><li>Awesome Oscillator: Confirmation of the future trend</li><li>RSI: Past price history and movement</li></ul><h3 id="5-Formula-of-RSI-Calculation-of-RS-and-RSI"><a href="#5-Formula-of-RSI-Calculation-of-RS-and-RSI" class="headerlink" title="5. Formula of RSI / Calculation of RS and RSI"></a>5. Formula of RSI / Calculation of RS and RSI</h3><p>Let’s quickly go through the calculation of RSI:</p><script type="math/tex; mode=display">RS = \frac{\text{Average of Upward Price Change}}{\text{Average of Downward Price Change}}</script><script type="math/tex; mode=display">RSI = 100 - \frac{100}{1 + RS}</script><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>The formula of RSI / Calculation of RS and RSI</i></p><p>Let’s see how to calculate a 14-day period. We say there is a stock that has \$2 growth for eight days in this 14-day period, and -\$2 decrease for six days. So we will get our RS value by doing:</p><blockquote><p>$RS = \frac{2 \times 8}{14} \div \frac{2 \times 6}{14} = 1.333$</p></blockquote><p>Our RSI will be:</p><blockquote><p>$RSI = 1 - \frac{100}{1+1.333} = 57.13$</p></blockquote><p>As the RSI indicator is in a form of the oscillator, it ranges from 0~100. A stock would usually be considered as oversold when if the RSI is lower than 30, indicating a bullish price momentum in order to revert the RSI back to the average range. On the other hand, a stock would be deemed as overbought when the RSI is higher than 70. Just like the below stock price of Amazon (<em>AMZN</em>)</p><img data-src="/2021/11/03/2021-11-06-rsi-indicator/amzn.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>AMZN stock price</i></p><h3 id="6-Limitations-of-RSI"><a href="#6-Limitations-of-RSI" class="headerlink" title="6. Limitations of RSI"></a>6. Limitations of RSI</h3><p>RSI is one of the most popular day trading strategy indicators since it was developed in 1978. You can find tons of articles on the internet about what RSI can achieve. However, when a market is in a strong trend, RSI loses its usefulness. Why? Because RSI can remain overbought or oversold for long periods providing the trader misleading signals.</p><p>Below is the stock price of Tesla (<em>TSLA</em>) since September, 2021. The RSI in the red rectangle stays above 70-line for over a month and has no signs of reverting. This is the exact example illustrating that the strong bullish momentum would generate wrong signals.</p><img data-src="/2021/11/03/2021-11-06-rsi-indicator/tsla.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>TSLA stock price since September, 2021</i></p><p>In other words, blindly executing a trade based on overbought or oversold signals is definitely not a good idea. Indicators are tools to help you quickly have a big picture of the specific stock, but they won’t help you enough if you don’t understand the market context or company-specific risk.</p><hr><h1 id="Strategy-setups-for-our-backtests"><a href="#Strategy-setups-for-our-backtests" class="headerlink" title="Strategy setups for our backtests"></a>Strategy setups for our backtests</h1><p>After introducing what RSI is and what are we going to use it for, let’s get back to the business: constructing our trading and preparing for the backtest. This strategy is going to use the strategy we built before in <a href="https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/">here</a> and <a href="https://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/">here</a></p><h2 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h2><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h2 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h2><ol><li>Sort stocks by <code>PERatio</code>, <code>EPS</code>, <code>ROE</code>, <code>NetIncome</code> and take top 60%</li><li>Sort stocks by <code>PBRatio</code>, from high to low</li></ol><h2 id="Rebalancing-strategy"><a href="#Rebalancing-strategy" class="headerlink" title="Rebalancing strategy"></a>Rebalancing strategy</h2><ol><li>Recalculate our universe and indicators every day.</li><li>We keep 10 stocks that have buy-in signals and with the highest <code>PBRatio</code>.</li><li>We assign weight to each position evenly.</li><li>We don’t adjust the weight of each stock until we close these positions.</li></ol><h2 id="Signal-generation"><a href="#Signal-generation" class="headerlink" title="Signal generation"></a>Signal generation</h2><p>As written in the title of this article, we’re going to introduce four different RSI strategies and see how our trading strategy can benefit by adding any one of them. Now, we quickly talk about how each type of RSI indicator strategy:</p><h3 id="1-The-Moving-Average-of-RSI"><a href="#1-The-Moving-Average-of-RSI" class="headerlink" title="1. The Moving Average of RSI"></a>1. The Moving Average of RSI</h3><p>The very first strategy is that we use SMA (<em>Simple Moving Average</em>) to smooth the RSI.</p><script type="math/tex; mode=display">RSI_{SMA}= \frac{RSI_n + RSI_{n-1} + ... + RSI_1}{n}</script><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Formula of SMA</i></p><p>The benefit of applying SMA on the RSI we have acquired is that we can reduce the frequency of our threshold to be triggered. A lot of times that the threshold was reached because the anomaly/abnormal price movements were generated due to a certain of market events. You can tell from the below chart, that the smoothed RSI line triggered twice only compared to the original RSI line that triggered five times.</p><img data-src="/2021/11/03/2021-11-06-rsi-indicator/sma.png" class="" width="700"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>RSI V.S. smoothed RSI</i></p><ul><li>Buy signal: Original buy signal + SMA of RSI &lt; 30 (which tells us that this stock is potentially oversold at the moment)</li><li>Sell signal: Original sell signal</li></ul><blockquote><p>Note: We’re not going to add the RSI signal in our selling signal generation rule. Our intention is to buy when all signals confirmed the same direction, but sell when the future prediction indicator MACD tells us that the upward trending is over.</p><p>Note 2: You can check the previous articles <a href="https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/">here</a> and <a href="https://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/">here</a></p></blockquote><h3 id="2-RSI-stack"><a href="#2-RSI-stack" class="headerlink" title="2. RSI stack"></a>2. RSI stack</h3><p>The concept of the RSI stack is to use multiple consecutive time frames to further confirm the relative strength. Taking the example from the post <a href="https://alpaca.markets/learn/backtrader-01/">Alpaca &amp; Backtrader: Tools of the Trade (Part 1)</a>, you can see that the author uses <code>15m, 30m, 1h</code> three different time frames to confirm the relative strength is strong enough to start bidding on the reverting direction. Since here we are constructing our strategy to run on a daily basis, we use <code>1d, 2d</code> as the time frame to confirm the strength of the current trend.</p><ul><li>Buy signal: Original buy signal + $RSI_{n} &lt; 30$ + $RSI_{n-1} &lt; 30$</li><li>Sell signal: Original sell signal</li></ul><h3 id="3-The-RSI²-Leading-Indicator"><a href="#3-The-RSI²-Leading-Indicator" class="headerlink" title="3. The RSI² Leading Indicator"></a>3. The RSI² Leading Indicator</h3><p>As the RSI is derived directly from the stock price movements, so the RSI indicator value will highly depend on the market condition overall. Therefore <a href="https://python.plainenglish.io/the-rsi%C2%B2-leading-indicator-detecting-trend-exhaustion-early-in-trading-284a59dc1ea3">in this post</a> suggests that we can perform another RSI function over the original RSI, called $RSI^2$. This will tell us when will the original RSI meets the extreme conditions and start to revert to the opposite direction.</p><ul><li>Buy signal: Original buy signal + $RSI^2 &lt; 30$</li><li>Sell signal: Original sell signal</li></ul><h3 id="4-The-Stochastic-RSI-Indicator"><a href="#4-The-Stochastic-RSI-Indicator" class="headerlink" title="4. The Stochastic-RSI Indicator"></a>4. The Stochastic-RSI Indicator</h3><p>Stochastic Oscillator is a technique that normalizes our value into a range from 0 ~ 1. We usually time 100 to the result so that the number is more approachable, ranging from 0 ~ 100. The outcome tells us that we either stand at the top (&gt; 70) or at the bottom (&lt;30) in the range of historical RSI.</p><script type="math/tex; mode=display">\text{Stochastic RSI} = \frac{\text{Current RSI} - \text{Highest RSI since n periods}}{\text{Highest RSI since n periods} - \text{Lowest RSI since n periods}}</script><ul><li>Buy signal: Original buy signal + $\text{Stochastic RSI} &lt; 30$</li><li>Sell signal: Original sell signal</li></ul><h2 id="Other-parameters"><a href="#Other-parameters" class="headerlink" title="Other parameters"></a>Other parameters</h2><p><strong>Backtest Date:</strong> <code>2019, 1 ,10</code> ~ <code>2021, 10, 25</code></p><hr><h1 id="Backtest-results"><a href="#Backtest-results" class="headerlink" title="Backtest results"></a>Backtest results</h1><p>Below are the backtests that were performed according to our constructed strategies. In addition to those strategies we mentioned above, I have conducted another set of backtests using <strong>EMA</strong> (<em>Exponential Moving Average</em>) to calculate our RSI just for reference. The results are quite aligned between these two types of RSI calculations.</p><img data-src="/2021/11/03/2021-11-06-rsi-indicator/backtest_result.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Backtest results summary</i></p><h2 id="Backtest-diagrams"><a href="#Backtest-diagrams" class="headerlink" title="Backtest diagrams"></a>Backtest diagrams</h2><h3 id="1-The-Moving-Average-of-RSI-1"><a href="#1-The-Moving-Average-of-RSI-1" class="headerlink" title="1. The Moving Average of RSI"></a>1. The Moving Average of RSI</h3><div class="table-container"><table><thead><tr><th>SMA of RSI (Simple)</th><th>SMA of RSI (Exponential)</th></tr></thead><tbody><tr><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/sma_sim.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using SMA to construct RSI</i> </p></td><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/sma_ema.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using EMA to construct RSI</i> </p></td></tr></tbody></table></div><p>With the help from the RSI, Our net profit doesn’t seem to increase. Referring to both the backtest results and the diagram, there are fewer trading signals generated and the higher win rate compared to the benchmark strategy. However, the net profit slides drastically from 199.348% to around 100%. This could be a sign that there are too few valid trading signals were generated. Also, let’s look at the period after the outburst of COVID. There are no trades made for at least 5 months, meaning this strategy wasn’t able to capture the opportunities during the recovery of the economy. As survivors of post-market after the COVID outburst, we all know by now that the best opportunity is actually lying behind the downturn of the market.</p><h3 id="2-RSI-stack-1"><a href="#2-RSI-stack-1" class="headerlink" title="2. RSI stack"></a>2. RSI stack</h3><div class="table-container"><table><thead><tr><th>RSI Stack (Simple)</th><th>RSI Stack (Exponential)</th></tr></thead><tbody><tr><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/stack_sim.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using SMA to construct RSI</i> </p></td><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/stack_ema.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using EMA to construct RSI</i> </p></td></tr></tbody></table></div><p>The RSI stack doesn’t seem to really help confirm the direction and relative strength. Same as the SMA of RSI strategy, even though the win rate did rise to <code>80%</code> of total trades, the profitability of this strategy still doesn’t seem promising.</p><h3 id="3-The-RSI²-Leading-Indicator-1"><a href="#3-The-RSI²-Leading-Indicator-1" class="headerlink" title="3. The RSI² Leading Indicator"></a>3. The RSI² Leading Indicator</h3><div class="table-container"><table><thead><tr><th>SMA of RSI (Simple)</th><th>SMA of RSI (Exponential)</th></tr></thead><tbody><tr><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/square_sim.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using SMA to construct RSI</i> </p></td><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/square_ema.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using EMA to construct RSI</i> </p></td></tr></tbody></table></div><p>By looking at the stat <code>number of trades</code> and the diagram <code>HeldPositions</code>, we can confirm that now this strategy does generate enough signals to perform effective trading. The profitability has increased but the annual standard deviation has worsened. Even though the net profit looks attractive, all the stats and diagrams don’t profit enough confidence for us to go all-in.</p><h3 id="4-The-Stochastic-RSI-Indicator-1"><a href="#4-The-Stochastic-RSI-Indicator-1" class="headerlink" title="4. The Stochastic-RSI Indicator"></a>4. The Stochastic-RSI Indicator</h3><div class="table-container"><table><thead><tr><th>SMA of RSI (Simple)</th><th>SMA of RSI (Exponential)</th></tr></thead><tbody><tr><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/stoch_sim.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using SMA to construct RSI</i> </p></td><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/stoch_ema.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using EMA to construct RSI</i> </p></td></tr></tbody></table></div><p>This RSI strategy looks relatively promising as both the stats and the diagrams outperform the benchmark and the other RSI strategies. Also, if you look at the diagram, we’re able to outperform the benchmark performance after the COVID outburst. This could potentially indicate that this strategy is capable of capturing the opportunities during the market growth, but is unable to profit from the bumpy market condition.</p><h1 id="Delivery"><a href="#Delivery" class="headerlink" title="Delivery"></a>Delivery</h1><p>One thing worth mentioning is that even though we have one successful backtest, it doesn’t 100% ensure that we’re going to get the same profit if we put this strategy to life.</p><p>Seems all our backtests don’t give us enough confidence to say whether it’s a good enough strategy to launch it. However, there are still a lot of possibilities of the RSI that can be explored. For example, so far we have used <code>cross above/under the threshold</code> as the trigger of the RSI signals. Yet, we can try staying put when we cross above/under the threshold and trigger our signals when the RSI <code>reverts back from the threshold</code> to confirm the trend is indeed happening. This exploration could take a serious amount of time. But like what <em>Larry Swedroe</em>, the Director of research for Buckingham Strategic Wealth once said, “<strong>when you are trying to time the markets, you have to be right twice: going in, and going out</strong>“. You need to double in the efforts so that you’ll get the comparable rewarding.</p><p><br><div style="border: 2pt solid lightgrey;border-radius: 4pt;box-shadow: 7px 7px lightgrey;padding: 1.3em;width:80%;margin:auto;"> <i><b style="font-size:1.3em;padding: 1.3em;color:grey;">"When you are trying to time the markets, you have to be right twice: going in, and going out"</b></i> <p style="font-size: 0.9em; text-align:right; color: grey;">    <i><b>Larry Swedroe</b><br> Director of research for Buckingham Strategic Wealth</i></p> </div><br></p><hr><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://tradingsim.com/blog/stochastic-rsi/">https://tradingsim.com/blog/stochastic-rsi/</a></li><li><a href="https://tradingsim.com/blog/relative-strength-index-rsi/">RSI Trade Settings Explained + 4 Unique Trading Strategies</a></li><li><a href="https://medium.com/the-investors-handbook/trading-techniques-the-moving-average-of-rsi-f489fca3b572">Trading Techniques — The Moving Average of RSI</a></li><li><a href="https://alpaca.markets/learn/backtrader-01/">RSI stack part I</a> &amp; <a href="https://alpaca.markets/learn/backtrader-02/">part II</a></li><li><a href="https://python.plainenglish.io/the-rsi%C2%B2-leading-indicator-detecting-trend-exhaustion-early-in-trading-284a59dc1ea3">The RSI² Leading Indicator. Detecting Trend Exhaustion Early in Trading.</a></li><li><a href="https://kaabar-sofien.medium.com/the-stochastic-rsi-indicator-the-full-guide-in-python-fb495e8820b7">The Stochastic-RSI Indicator</a></li><li><a href="https://medium.com/raposa-technologies/4-simple-rsi-trading-strategies-db7b9790c690">4 Simple RSI Trading Strategies</a></li><li><a href="https://medium.datadriveninvestor.com/trend-confirmation-strategy-using-the-rsi-in-python-96079b74e712">Trend Confirmation Strategy Using the RSI in Python.</a></li><li><a href="https://wire.insiderfinance.io/the-more-signals-the-better-stochastic-rsi-vs-rsi-b0740a17c584">The more signals the better? Stochastic RSI vs. RSI</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/11/03/2021-11-06-rsi-indicator/cover.jpeg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p&gt;We talked about how to use MACD indicator and other secondary indicators to tell when to long certain stocks in the previous articles. If you haven’t read them yet, below are the links to catch up on where we left. But, is this the end of the optimization of our trading strategy? In this article, we’re going to demonstrate the power of RSI indicators and see how this indicator can be a help to our current trading strategy.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/&quot;&gt;How to save your silver bullets with MACD strategy?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/&quot;&gt;Optimize your MACD strategies with advanced indicators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Momentum" scheme="http://mikelhsia.github.io/tags/Momentum/"/>
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>Is my trading strategy one step away from making a fortune? - From research to backtest</title>
    <link href="http://mikelhsia.github.io/2021/10/22/2021-10-23-rebalancing-strategy/"/>
    <id>http://mikelhsia.github.io/2021/10/22/2021-10-23-rebalancing-strategy/</id>
    <published>2021-10-21T17:03:31.000Z</published>
    <updated>2021-11-09T04:14:24.294Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/cover.jpeg" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><p>After reading the post <a href="https://python.plainenglish.io/how-to-improve-investment-portfolio-with-rebalancing-strategy-in-python-a58841ee8b5e">How to Improve Investment Portfolio with Rebalancing Strategy in Python</a> by <a href="https://teobguan2013.medium.com/?source=post_page-----a58841ee8b5e--------------------------------">Bee Guan Teo</a>, I was thrilled to know that this trading strategy can be that powerful and the portfolio return is greater than any of my existing trading strategies. Therefore I decided to give it a try and backtest this strategy to verify the profitability it claimed.</p><a id="more"></a><h1 id="Extracting-the-essences-of-the-strategy"><a href="#Extracting-the-essences-of-the-strategy" class="headerlink" title="Extracting the essences of the strategy"></a>Extracting the essences of the strategy</h1><p>First of all, we extracted several things from the <a href="https://python.plainenglish.io/how-to-improve-investment-portfolio-with-rebalancing-strategy-in-python-a58841ee8b5e">post</a> in order to formulate the skeleton of our backtest strategy.</p><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/diagnosis.jpeg" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Perform the autopsy on the trading strategy</i></p><h2 id="1-Platform"><a href="#1-Platform" class="headerlink" title="1. Platform"></a>1. Platform</h2><p>I’m using <a href="https://www.quantconnect.com/">QuantConnect</a> to backtest this seemingly lucrative strategy.</p><h2 id="2-Universe"><a href="#2-Universe" class="headerlink" title="2. Universe"></a>2. Universe</h2><p>Instead of using a fixed set of stocks as in the original article, I’m using the following rules to filter the stocks that are similar in nature:</p><ol><li>Rank all the stocks by <code>DollarVolume</code></li><li>Choose stocks that are in NASDAQ and NYSE</li><li>Filter out the stocks that are listed less than 180 days (3 months)</li><li>Filter out the companies whose market capitalization are less than 500 million dollars</li><li>Lastly, we sorted all the remaining stocks by Dollar Volume, and limit them to top either <code>100</code> or <code>200</code> stocks</li></ol><h2 id="3-Rebalancing-strategy"><a href="#3-Rebalancing-strategy" class="headerlink" title="3. Rebalancing strategy"></a>3. Rebalancing strategy</h2><ol><li>As instructed in the article, we keep maximum five stocks that are most likely to rise.</li><li>We assign weight to each position evenly.</li><li>We don’t adjust the weight of each stock until we close this positions.</li></ol><h2 id="4-Signal-generation"><a href="#4-Signal-generation" class="headerlink" title="4. Signal generation"></a>4. Signal generation</h2><p>The strategy described in the article essentially is a kind of momentum strategy. It assumes that the stocks will continue to have great performances when they have good performances in the previous month. By holding this assumption, the author suggested:</p><ol><li>Every month we long five stocks that have the best monthly return in the previous month.</li><li>In the next month, we abandon two stocks that have the worst performance and</li><li>Replace them with the other two stocks that have good monthly returns in the previous month.</li></ol><h2 id="5-Other-parameters"><a href="#5-Other-parameters" class="headerlink" title="5. Other parameters"></a>5. Other parameters</h2><p>Other than the size of our universe, we pick <code>backtest time frame</code> as another parameter for us to test against with. In the end, we’re going to conduct four backtests:</p><ol><li>Limit the number of stocks in the universe to <code>100</code> and backtest it for 2 years</li><li>Limit the number of stocks in the universe to <code>100</code> and backtest it for 5 years</li><li>Limit the number of stocks in the universe to <code>200</code> and backtest it for 2 years</li><li>Limit the number of stocks in the universe to <code>200</code> and backtest it for 5 years</li></ol><h1 id="Backtest-results"><a href="#Backtest-results" class="headerlink" title="Backtest results"></a>Backtest results</h1><div class="table-container"><table><thead><tr><th></th><th>Momentum-100-2y</th><th>Momentum-100-5y</th><th>Momentum-200-2y</th><th>Momentum-100-5y</th></tr></thead><tbody><tr><td>No. of trade</td><td>93</td><td>233</td><td>93</td><td>235</td></tr><tr><td>Return</td><td>577.34%</td><td>162.471%</td><td>230.94 %</td><td>738.94 %</td></tr><tr><td>Annual Return</td><td>178.398%</td><td>21.922%</td><td>89.750%</td><td>54.789%</td></tr><tr><td>Annual Standard Deviation</td><td>0.546</td><td>0.469</td><td>0.476</td><td>0.373</td></tr><tr><td>Max D.D.</td><td>46.5%</td><td>66.9%</td><td>37.800%</td><td>43.000%</td></tr><tr><td>Beta</td><td>0.947</td><td>1.127</td><td>0.846</td><td>1.107</td></tr><tr><td>Alpha</td><td>1.186</td><td>0.132</td><td>0.594</td><td>0.306</td></tr><tr><td>Sharpe Ratio</td><td>2.471</td><td>0.594</td><td>1.555</td><td>1.205</td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Backtest results summary</i></p><p>Wow! Even though the backtest time span has across 5 years, the annual return rates look promising, ranging from 21% to 178%. Sharpe ratios are also telling us that we’re making a good amount of money under reasonable risk. Even though the max drawdown is a bit intimidatingly high, the huge amount of compensation looks lucrative enough to take that degree of risk. In the end, by looking at the stats of these backtests, this strategy has the potential to make some hard coin!</p><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/coin.jpg" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><p>Hold on. Take a step back and don’t jump the gun. Let’s do a double check by looking at the return diagram of the described scenario respectively. See whether we can discover some patterns that are not hidden behind these numbers.</p><div class="table-container"><table><thead><tr><th>Duration \<br> # Universe</th><th>100</th><th>200</th></tr></thead><tbody><tr><td>2 years</td><td><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/test-100-2y.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Limit universe to contain 100 stocks<br>from 2019/12/02 to 2021/10/13</i> </p></td><td><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/test-200-2y.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Limit universe to contain 200 stocks<br>from 2019/12/02 to 2021/10/13</i> </p></td></tr><tr><td>5 years</td><td><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/test-100-5y.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Limit universe to contain 100 stocks<br>from 2016/12/02 to 2021/10/13</i> </p></td><td><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/test-200-5y.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Limit universe to contain 200 stocks<br>from 2016/12/02 to 2021/10/13</i> </p></td></tr></tbody></table></div><p>Did you notice the pattern in the above four diagrams? Apparently, the majority of the portfolio return is generated starting the late 2020s. Any time before the late 2020s actually very little return over years. This fact indicates that the portfolio return over years is contributed by luck so that we can capture this uprising wave. From the asset sales volume distribution diagram in the backtest below, you can tell that most of the return is contributed by Tesla (<code>TSLA</code>), ROKU (<code>ROKU</code>), Advanced Micro Devices (<code>AMD</code>), and GameStop (<code>GME</code>), which are highly volatile and unpredictable <a href="https://en.wikipedia.org/wiki/Meme_stocks">MEME stocks</a>.</p><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/asset_sales_volume.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;"><i>Asset sales volume over time</i></p><p>It’s a fair question to ask that whether this type of opportunity will continue to be captured by this strategy. Also, what if your capital won’t sustain until the day you capture this opportunity? These are the objective questions that you need to ask yourself before you adopt this as an executable trading strategy. Other than those, <code>the number of trades</code> and <code>the backtest time span</code> are also the important KPIs that I keep my eyes on. I didn’t mean to judge whether this is a good or bad strategy, but knowing the answers to the above questions can help you adjust the position of this strategy in your investment portfolio.</p><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="Code-of-alpha-model-for-QuantConnect-platform"><a href="#Code-of-alpha-model-for-QuantConnect-platform" class="headerlink" title="Code of alpha model for QuantConnect platform"></a>Code of alpha model for QuantConnect platform</h2><p><em>(including signal generation)</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> AlgorithmImports <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SymbolData</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, algorithm, symbol</span>):</span></span><br><span class="line">        self.symbol = symbol</span><br><span class="line">        self.algorithm = algorithm</span><br><span class="line">        self.rolling_close = RollingWindow[float](<span class="number">2</span>)</span><br><span class="line">        hist = algorithm.History(</span><br><span class="line">            [self.symbol],</span><br><span class="line">            <span class="number">4</span>,</span><br><span class="line">            Resolution.Daily</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;close&#x27;</span> <span class="keyword">in</span> hist.columns:</span><br><span class="line">            self.rolling_close.Add(hist[<span class="string">&#x27;close&#x27;</span>][<span class="number">-2</span>])</span><br><span class="line">            self.rolling_close.Add(hist[<span class="string">&#x27;close&#x27;</span>][<span class="number">-1</span>])</span><br><span class="line">            <span class="comment"># algorithm.Debug(f&#x27;[&#123;self.symbol&#125;] - &#123;self.rolling_close[0]&#125; , &#123;self.rolling_close[1]&#125; init complete&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Update</span>(<span class="params">self, close</span>):</span></span><br><span class="line">        self.rolling_close.Add(close)</span><br><span class="line">        <span class="comment"># self.algorithm.Debug(f&#x27;[&#123;self.symbol&#125;] - &#123;self.rolling_close[0]&#125; , &#123;self.rolling_close[1]&#125; update complete&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Remove</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monthly_return</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (self.rolling_close[<span class="number">0</span>] - self.rolling_close[<span class="number">1</span>])/self.rolling_close[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopNReturnAlphaModel</span>(<span class="params">AlphaModel</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        capacity = <span class="number">10</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        replacement = <span class="number">5</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        resolution = Resolution.Daily</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        self.resolution = resolution</span><br><span class="line">        self._changes = <span class="literal">None</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.replacement = replacement</span><br><span class="line">        self.lastMonth = <span class="number">-1</span></span><br><span class="line">        self.symbol_data = dict()</span><br><span class="line">        self.trade_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Update</span>(<span class="params">self, algorithm, data</span>):</span></span><br><span class="line">        insights = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> algorithm.Time.month == self.lastMonth <span class="keyword">and</span> self.traded_flag == <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># algorithm.Debug(f&#x27;Time is &#123;algorithm.Time&#125;: Data is empty&#x27;)</span></span><br><span class="line">            <span class="keyword">return</span> insights</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.lastMonth = algorithm.Time.month</span><br><span class="line">            self.traded_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(data.Bars) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> insights</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            algorithm.Debug(<span class="string">f&#x27;Time from Update: <span class="subst">&#123;algorithm.Time&#125;</span>&#x27;</span>)</span><br><span class="line">            self.traded_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        addedSecuritiesSymbols = [x.Symbol <span class="keyword">for</span> x <span class="keyword">in</span> self._changes.AddedSecurities] <span class="keyword">if</span> self._changes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        removedSecuritiesSymbols = [x.Symbol <span class="keyword">for</span> x <span class="keyword">in</span> self._changes.RemovedSecurities] <span class="keyword">if</span> self._changes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> security <span class="keyword">in</span> algorithm.ActiveSecurities.Keys:</span><br><span class="line">            <span class="keyword">if</span> addedSecuritiesSymbols:</span><br><span class="line">                <span class="keyword">if</span> security <span class="keyword">in</span> addedSecuritiesSymbols:</span><br><span class="line">                    <span class="comment"># Add rolling window</span></span><br><span class="line">                    <span class="keyword">if</span> security <span class="keyword">not</span> <span class="keyword">in</span> self.symbol_data.keys():</span><br><span class="line">                        self.symbol_data[security] = SymbolData(algorithm, security)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> self.symbol_data[security].rolling_close.IsReady:</span><br><span class="line">                            <span class="comment"># Not ready so remove again</span></span><br><span class="line">                            symbolData = self.symbol_data.pop(security, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Update rolling window</span></span><br><span class="line">                self.symbol_data[security].Update(data.Bars[security].Close)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> removedSecuritiesSymbols:</span><br><span class="line">            <span class="keyword">for</span> security <span class="keyword">in</span> removedSecuritiesSymbols:</span><br><span class="line">                <span class="comment"># Remove rolling window</span></span><br><span class="line">                <span class="keyword">if</span> security <span class="keyword">in</span> self.symbol_data.keys():</span><br><span class="line">                    symbolData = self.symbol_data.pop(security, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        sorted_symbol_data = &#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(</span><br><span class="line">            self.symbol_data.items(),</span><br><span class="line">            key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>].monthly_return,</span><br><span class="line">            reverse = <span class="literal">True</span></span><br><span class="line">        )[:self.capacity]&#125;</span><br><span class="line"></span><br><span class="line">        invested_stocks = dict()</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> algorithm.Portfolio:</span><br><span class="line">            <span class="keyword">if</span> s.Value.Invested:</span><br><span class="line">                invested_stocks[s.Key] = algorithm.Portfolio[s.Key].UnrealizedProfitPercent</span><br><span class="line"></span><br><span class="line">        invested_stocks = &#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(</span><br><span class="line">            invested_stocks.items(),</span><br><span class="line">            key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>],</span><br><span class="line">            reverse=<span class="literal">True</span></span><br><span class="line">        )&#125;</span><br><span class="line"></span><br><span class="line">        algorithm.Debug(<span class="string">f&#x27;Invested number: <span class="subst">&#123;len(invested_stocks)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        insightExpiry = Expiry.EndOfDay(algorithm.Time)</span><br><span class="line">        <span class="keyword">if</span> len(invested_stocks) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> sorted_symbol_data.keys():</span><br><span class="line">                insights.append(</span><br><span class="line">                    Insight.Price(</span><br><span class="line">                        str(s),</span><br><span class="line">                        insightExpiry,</span><br><span class="line">                        InsightDirection.Up,</span><br><span class="line">                        <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0.05</span></span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">                <span class="comment"># algorithm.Debug(f&#x27;Buying &#123;str(s)&#125;&#x27;)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>, self.replacement):</span><br><span class="line">                <span class="comment"># Close the positions that have the worse performances</span></span><br><span class="line">                worse_stock = invested_stocks.popitem()</span><br><span class="line">                insights.append(</span><br><span class="line">                    Insight.Price(</span><br><span class="line">                        str(worse_stock[<span class="number">0</span>]),</span><br><span class="line">                        insightExpiry,</span><br><span class="line">                        InsightDirection.Flat,</span><br><span class="line">                        <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0.05</span>    <span class="comment"># Weight</span></span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">                <span class="comment"># algorithm.Debug(f&#x27;Selling &#123;str(worse_stock[0])&#125;&#x27;)</span></span><br><span class="line"></span><br><span class="line">            open_positions = self.replacement</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> sorted_symbol_data.keys():</span><br><span class="line">                <span class="keyword">if</span> open_positions &gt; <span class="number">0</span> <span class="keyword">and</span> s <span class="keyword">not</span> <span class="keyword">in</span> invested_stocks.keys():</span><br><span class="line">                    insights.append(</span><br><span class="line">                        Insight.Price(</span><br><span class="line">                            str(s),</span><br><span class="line">                            insightExpiry,</span><br><span class="line">                            InsightDirection.Up,</span><br><span class="line">                            <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0.05</span>    <span class="comment"># Weight</span></span><br><span class="line">                        ),</span><br><span class="line">                    )</span><br><span class="line">                    open_positions -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># algorithm.Debug(f&#x27;Buying &#123;str(s)&#125;&#x27;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reset the changes</span></span><br><span class="line">        self._changes = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># algorithm.Debug(f&#x27;Sent out &#123;len(insights)&#125; on &#123;algorithm.Time&#125;&#x27;)</span></span><br><span class="line">        <span class="keyword">return</span> insights</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">OnSecuritiesChanged</span>(<span class="params">self, algorithm, changes</span>):</span></span><br><span class="line">        self._changes = changes</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/10/22/2021-10-23-rebalancing-strategy/cover.jpeg&quot; class=&quot;&quot; width=&quot;500&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;After reading the post &lt;a href=&quot;https://python.plainenglish.io/how-to-improve-investment-portfolio-with-rebalancing-strategy-in-python-a58841ee8b5e&quot;&gt;How to Improve Investment Portfolio with Rebalancing Strategy in Python&lt;/a&gt; by &lt;a href=&quot;https://teobguan2013.medium.com/?source=post_page-----a58841ee8b5e--------------------------------&quot;&gt;Bee Guan Teo&lt;/a&gt;, I was thrilled to know that this trading strategy can be that powerful and the portfolio return is greater than any of my existing trading strategies. Therefore I decided to give it a try and backtest this strategy to verify the profitability it claimed.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Momentum" scheme="http://mikelhsia.github.io/tags/Momentum/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>【Pair Trading】Part 3. The strategy that helps minimize your portfolio risk</title>
    <link href="http://mikelhsia.github.io/2021/09/30/2021-10-05-pair-trading-market-neutral/"/>
    <id>http://mikelhsia.github.io/2021/09/30/2021-10-05-pair-trading-market-neutral/</id>
    <published>2021-09-30T07:45:52.000Z</published>
    <updated>2021-11-03T04:22:05.167Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/cover.png" class="" width="800"><blockquote><p>Previous reading:</p><ul><li><a href="https://medium.com/@mikelhsia/pair-trading-introduction-to-pair-trading-strategy-c97a1d0897ff">【Pair Trading】Introduction to pair trading strategy</a></li><li><a href="https://medium.com/@mikelhsia/after-knowing-what-the-pair-trading-strategy-is-about-from-the-previous-post-were-going-to-use-98e41ef3ea5">【Pair Trading】In-depth analysis of 5 distance approach strategies in pair trading</a></li></ul></blockquote><p>In the previous post <a href="https://medium.com/@mikelhsia/after-knowing-what-the-pair-trading-strategy-is-about-from-the-previous-post-were-going-to-use-98e41ef3ea5">【Pair Trading】In-depth analysis of 5 distance approach strategies in pair trading</a>, we have conducted various research against each variation of distance approaches in pair trading strategy. Despite the research has given us probable insights whether there is an <strong>$\alpha$</strong> exists in the strategy we constructed, we still haven’t established our portfolio construction strategy. Here we introduce a concept called the “long-short equity (LSE)” strategy.</p><p>Therefore, the objectives of this post are consists of three:</p><ol><li>What is the long-short equity (LSE) strategy</li><li>Review our backtest results to see the impact of adopting the long-short strategy</li><li>What are the advanced strategies that we can explore</li></ol><a id="more"></a><h1 id="The-Long-short-equity-LSE-strategy"><a href="#The-Long-short-equity-LSE-strategy" class="headerlink" title="The Long-short equity (LSE) strategy"></a>The Long-short equity (LSE) strategy</h1><p>The long-short equity (LSE) strategy is an extension of the pair strategy which takes long positions in stocks that are expected to appreciate and takes short positions in stocks that are expected to depreciate. It’s a classic hedge fund investment strategy that is able to generate relatively higher risk-adjusted returns with lower volatility and smaller market-specific exposure compared to the traditional long-only portfolio.</p><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/long-short.jpg" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Long-short strategy</i></p><h1 id="Backtest-against-the-distance-approaches-selected"><a href="#Backtest-against-the-distance-approaches-selected" class="headerlink" title="Backtest against the distance approaches selected"></a>Backtest against the distance approaches selected</h1><p>Here we’re going to run backtests against the approaches we have spoken about in the previous post:</p><ul><li>Basic distance</li><li>High variance</li><li>Zero crossing</li><li>Pearson correlation</li></ul><p>In this series of backtests, we will adopt the <strong>long-only strategy</strong> (<em>buy the stocks that are most likely to rise</em>) against each of the four pair-trading approaches. In the meantime, we’re going to adopt the <strong>long-short strategy</strong> (<em>long the stocks that are expected to appreciate, and short other stocks that are expected to depreciate</em>) to backtest each pair-trading approach under the same conditions. By doing these, we can compare and see the impact of applying the long-short strategy.</p><h2 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h2><p>There are other setups including:</p><h3 id="1-Platform"><a href="#1-Platform" class="headerlink" title="1. Platform"></a>1. Platform</h3><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h3 id="2-Universe-selection"><a href="#2-Universe-selection" class="headerlink" title="2. Universe selection"></a>2. Universe selection</h3><ol><li>Rank all the stocks by <code>DollarVolume</code></li><li>Choose stocks that are in NASDAQ and NYSE</li><li>Filter out the stocks that are listed less than 180 days (3 months)</li><li>Filter out the companies whose market capitalization are less than 500 million dollars</li></ol><h3 id="3-Rebalancing-strategy"><a href="#3-Rebalancing-strategy" class="headerlink" title="3. Rebalancing strategy"></a>3. Rebalancing strategy</h3><ol><li>For the long-only strategy scenario, we buy 20 stocks that are most likely to rise.</li><li>For the long-short strategy scenario, we long 20 stocks that are most likely to rise and short 20 stocks that are most likely to drop.</li><li>We assign even weight to each position.</li><li>We don’t adjust the weight of the portfolio while we hold our positions.</li></ol><h3 id="4-Long-Short-signal-generation"><a href="#4-Long-Short-signal-generation" class="headerlink" title="4. Long/Short signal generation"></a>4. Long/Short signal generation</h3><p>We have all the details regarding how to trigger the long or short signals in <a href="https://medium.com/@mikelhsia/after-knowing-what-the-pair-trading-strategy-is-about-from-the-previous-post-were-going-to-use-98e41ef3ea5">this post here</a>. For those who haven’t read this post, the critical details have been summarized below:</p><ol><li><p>For basic distance, high variance, and zero-crossing methods, we use $\pm 1.5 \times std\ of\ spread$ as the upper bound and lower bound to trigger the buy/sell signals. Then we close the positions when the spread reverts back to the zero-line.</p><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/threshold.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Open when above the upper bound and below the lower bound, and close when reverting back to the zero-line.</i></p></li><li><p>For the Pearson Correlation method, we construct a benchmark portfolio for each stock by picking the 50 most correlated stocks. We long the stocks that its stock price movement deviated from its benchmark portfolio movement, and spread of the stock movement is negative. Vice versa, we short the stocks that the spread of the stock movement is positive against the benchmark portfolio movement.</p></li></ol><h2 id="Backtest-results"><a href="#Backtest-results" class="headerlink" title="Backtest results"></a>Backtest results</h2><h3 id="Backtest-of-basic-distance"><a href="#Backtest-of-basic-distance" class="headerlink" title="Backtest of basic distance"></a>Backtest of basic distance</h3><div class="table-container"><table><thead><tr><th></th><th>LO-BD</th><th>LS-BD</th><th>Impact</th></tr></thead><tbody><tr><td>Diagram</td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-LO-BD-2y.png" class="" width="600"></td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-MN-BD-2y.png" class="" width="600"></td><td></td></tr><tr><td>No. of trade</td><td>172</td><td>428</td><td><font color="red">+256</font></td></tr><tr><td>Return</td><td>67.45%</td><td>18.98%</td><td><font color="red">-48.47%</font></td></tr><tr><td>Annual Return</td><td>35.393%</td><td>10.754%</td><td><font color="red">-24.639%</font></td></tr><tr><td>Annual Standard Deviation</td><td>0.304</td><td>0.134</td><td><font color="green">-0.17</font></td></tr><tr><td>Max D.D.</td><td>38.4%</td><td>13.9%</td><td><font color="green">-24.5%</font></td></tr><tr><td>Beta</td><td>-0.161</td><td><font color="green">0.036</font></td><td></td></tr><tr><td>Alpha</td><td>0.381</td><td>0.09</td><td><font color="red">-0.372</font></td></tr><tr><td>Sharpe Ratio</td><td>1.136</td><td>0.731</td><td><font color="red">-0.405</font></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>LO: Long-Only strategy, LS: Long-Short strategy, BD: Basic Distance</i></p><h3 id="Backtest-of-zero-crossing"><a href="#Backtest-of-zero-crossing" class="headerlink" title="Backtest of zero crossing"></a>Backtest of zero crossing</h3><div class="table-container"><table><thead><tr><th></th><th>LO-ZC</th><th>LS-ZC</th><th>Impact</th></tr></thead><tbody><tr><td>Diagram</td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-LO-ZC-2y.png" class="" width="600"></td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-MN-ZC-2y.png" class="" width="600"></td><td></td></tr><tr><td>No. of trade</td><td>102</td><td>216</td><td><font color="red">+114</font></td></tr><tr><td>Return</td><td>35.98%</td><td>8.27%</td><td><font color="red">-27.71%</font></td></tr><tr><td>Annual Return</td><td>19.8%</td><td>4.779%</td><td><font color="red">-15.021%</font></td></tr><tr><td>Annual Standard Deviation</td><td>0.303</td><td>0.093</td><td><font color="green">-0.21</font></td></tr><tr><td>Max D.D.</td><td>45.0%</td><td>8.3%</td><td><font color="green">-36.7%</font></td></tr><tr><td>Beta</td><td>-0.204</td><td><font color="green">0.014</font></td><td></td></tr><tr><td>Alpha</td><td>0.262</td><td>0.041</td><td><font color="red">-0.221</font></td></tr><tr><td>Sharpe Ratio</td><td>0.714</td><td>0.47</td><td><font color="red">-0.244</font></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>LO: Long-Only strategy, LS: Long-Short strategy, ZC: Zero Crossing</i></p><h3 id="Backtest-of-high-variance"><a href="#Backtest-of-high-variance" class="headerlink" title="Backtest of high variance"></a>Backtest of high variance</h3><div class="table-container"><table><thead><tr><th></th><th>LO-HV</th><th>LS-HV</th><th>Impact</th></tr></thead><tbody><tr><td>Diagram</td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-LO-HV-2y.png" class="" width="600"></td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-MN-HV-2y.png" class="" width="600"></td><td></td></tr><tr><td>No. of trade</td><td>75</td><td>186</td><td><font color="red">+111</font></td></tr><tr><td>Return</td><td>39.1%</td><td>10.66%</td><td><font color="red">-28.44%</font></td></tr><tr><td>Annual Return</td><td>21.446%</td><td>6.136%</td><td><font color="red">-15.31%</font></td></tr><tr><td>Annual Standard Deviation</td><td>0.27</td><td>0.079</td><td><font color="green">-0.191</font></td></tr><tr><td>Max D.D.</td><td>41.00%</td><td>6.200%</td><td><font color="green">-34.80%</font></td></tr><tr><td>Beta</td><td>-0.143</td><td><font color="green">0.037</font></td><td></td></tr><tr><td>Alpha</td><td>0.25</td><td>0.046</td><td><font color="red">-0.204</font></td></tr><tr><td>Sharpe Ratio</td><td>0.806</td><td>0.677</td><td><font color="red">-0.129</font></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>LO: Long-Only strategy, LS: Long-Short strategy, HV: High Variance</i></p><h3 id="Backtest-of-Pearson-Correlation"><a href="#Backtest-of-Pearson-Correlation" class="headerlink" title="Backtest of Pearson Correlation"></a>Backtest of Pearson Correlation</h3><div class="table-container"><table><thead><tr><th></th><th>LO-PC</th><th>LS-PC</th><th>Impact</th></tr></thead><tbody><tr><td>Diagram</td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-LO-PC-2y.png" class="" width="600"></td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-MN-PC-2y.png" class="" width="600"></td><td></td></tr><tr><td>No. of trade</td><td>72</td><td>1438</td><td><font color="red">+1366</font></td></tr><tr><td>Return</td><td>67.72%</td><td>3.9%</td><td><font color="red">-63.82%</font></td></tr><tr><td>Annual Return</td><td>35.522%</td><td>2.272%</td><td><font color="red">-33.25%</font></td></tr><tr><td>Annual Standard Deviation</td><td>0.406</td><td>0.197</td><td><font color="green">-0.209</font></td></tr><tr><td>Max D.D.</td><td>52.200%</td><td>33.90%</td><td><font color="green">-18.30%</font></td></tr><tr><td>Beta</td><td>-0.174</td><td><font color="green">-0.015</font></td><td>+0.159</td></tr><tr><td>Alpha</td><td>0.435</td><td>0.042</td><td><font color="red">-0.393</font></td></tr><tr><td>Sharpe Ratio</td><td>0.975</td><td>0.196</td><td><font color="red">-0.779</font></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>LO: Long-Only strategy, LS: Long-Short strategy, PC: Pearson Correlation</i></p><h3 id="Summaries"><a href="#Summaries" class="headerlink" title="Summaries"></a>Summaries</h3><p>It’s quite clear to notice the impact after applying the long-short strategy. There are a few insights that we can extract from this series of backtests:</p><div class="table-container"><table><thead><tr><th></th><th>Summarized details</th></tr></thead><tbody><tr><td>Pros</td><td>1. As you short stocks while applying this strategy, you’re actually gaining and preserving more cash for your available cash pool. <br> 2. The volatility KPIs, such as annual standard deviation and max dropdown, are drastically decreased by a certain degree, making your portfolio less volatile.<br> 3. <strong><em>Beta</em></strong> is the indicator of whether your portfolio is highly related to the entire market. Your portfolio will be influenced less by the market fluctuation when the beta is close to 0. After applying the long-short strategy, you can tell that the beta has reduced to one-tenth in every scenario. Compare to the traditional long-only strategy, the long-short strategy suffers less influence during the recession, therefore your portfolio could rebound faster than the long-only strategy. <br><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/long-short-strategy.png" class="" width="400"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>The opposite position would help hedge your losing positions, just like the dropdown happened in Apr. 2020 </i> </p></td></tr><tr><td>Cons</td><td>1. Despite it has the benefit of reducing the volatility of your portfolio, the long-short strategy would also hurt the return of your portfolio.<br> 2. How do we evaluate whether applying the long-short strategy brings us more goods than harms or vice versa? We can take a look at the KPI <strong><em>Sharpe ratio</em></strong>. Sharpe ratio indicates the ratio between the risk-free return and the volatility. The decrease in Sharpe ratios in all scenarios does tell us that the long-short strategy takes away more return that can’t be compensated by the ability to withstand the volatility it adds.<br> 3. As you can see in the previous backtest, that the number of transactions increased substantially afterwards in any scenario. The transactional cost of applying this strategy would increase compared to the traditional long-only strategy.</td></tr></tbody></table></div><h1 id="What-are-the-advanced-strategies-that-we-can-explore"><a href="#What-are-the-advanced-strategies-that-we-can-explore" class="headerlink" title="What are the advanced strategies that we can explore?"></a>What are the advanced strategies that we can explore?</h1><p>Ummmm…. It seems like the results we have above don’t really gonna make us enough money to pay our rent. Even though the pair trading strategy that we developed above will help us reduce the volatility of our portfolio return, but the reduced return would really annoy us as this strategy makes us less money. So what are the things we can do in order to optimize this strategy and make it a money-making strategy? Here are a few other variations that we can explore:</p><h2 id="Long-bias-strategy"><a href="#Long-bias-strategy" class="headerlink" title="Long-bias strategy"></a>Long-bias strategy</h2><p>The long-bias strategy would require holding 130% long positions of invested capital and 30% short positions, achieving 100% net in long positions. The benefit of this strategy is that you could obtain more capital (<em>30% more cash from the short position, plus the original 100% capital</em>) to leverage compared to the traditional long-only strategy, which can only leverage 100% of their capital.</p><h2 id="Market-neutral-strategy"><a href="#Market-neutral-strategy" class="headerlink" title="Market neutral strategy"></a>Market neutral strategy</h2><p>Market neutral strategy refers to a type of investment strategy where the investor aims to profit from both an increase and a decrease in paired stock prices. This strategy features zero $\beta$, which makes the portfolio return won’t be impacted by the market fluctuation by hedging the systematic risk.</p><p>The benefits of adopting this strategy are pretty similar to the observation we have above, that applying market neutral strategy will make our portfolio more resilient in combating the economic storm.</p><h2 id="Dollar-neutral-strategy"><a href="#Dollar-neutral-strategy" class="headerlink" title="Dollar neutral strategy"></a>Dollar neutral strategy</h2><p>Similar to market neutral strategy, dollar neutral strategy targets to long the same dollar amount in positions and to short the same dollar amount in positions, rendering leveraging a very little portion of your available cash. The benefit being, you can leverage your positive and negative insights to maximize your portfolio value with very little money needed to be invested.</p><h1 id="Final-words"><a href="#Final-words" class="headerlink" title="Final words"></a>Final words</h1><p>From the performed backtest, we get to know the outcomes of applying long-short strategies and how it impacts your portfolio performance. Long-short strategies and pair trading strategies are never a strategy that can bring you outstanding returns to brag about. However, it is a strategy that can become a gold mine that brings you money slowly and steadily over the long run.</p><hr><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://corporatefinanceinstitute.com/resources/knowledge/strategy/market-neutral/">What is Market Neutral?</a></li><li><a href="https://www.investopedia.com/terms/l/long-shortequity.asp">Long-Short Equity by Investopedia</a></li><li><a href="https://www.investopedia.com/articles/investing/111313/multiple-strategies-hedge-funds.asp">Multiple hedge fund strategies</a></li><li><a href="https://www.investopedia.com/terms/m/marketneutral.asp">Market Neutral</a></li><li><a href="https://www.alliancebernstein.com/CmsObjectABD/PDF/Research_WhitePaper/MarketNeutralWhitepaper06.08.12.pdf">Market-Neutral Strategies: An All-Weather Investment Option</a></li><li><a href="https://www.eurekahedge.com/Research/News/785/13030-Funds-What-is-Behind-the-Commercial-Offensive">130/30 Funds: What is Behind the Commercial Offensive?</a></li></ul><h2 id="Attached-backtest-summarized-report"><a href="#Attached-backtest-summarized-report" class="headerlink" title="Attached backtest summarized report"></a>Attached backtest summarized report</h2><div class="table-container"><table><thead><tr><th><strong>Scenario</strong></th><th><strong>No. of trade</strong></th><th><strong>Return</strong></th><th><strong>Annual Return</strong></th><th><strong>Annual Standard Deviation</strong></th><th><strong>Max DD</strong></th><th><strong>Beta</strong></th><th><strong>Alpha</strong></th><th><strong>Sharpe Ratio</strong></th></tr></thead><tbody><tr><td>LO-BD</td><td>172</td><td>67.45%</td><td>35.393%</td><td>0.304</td><td>38.4%</td><td>-0.161</td><td>0.381</td><td>1.136</td></tr><tr><td>MN-BD</td><td>428</td><td>18.98%</td><td>10.754%</td><td>0.134</td><td>13.900%</td><td>0.036</td><td>0.09</td><td>0.731</td></tr><tr><td>LO-ZC</td><td>102</td><td>35.98%</td><td>19.8%</td><td>0.303</td><td>45.00%</td><td>-0.204</td><td>0.262</td><td>0.714</td></tr><tr><td>MN-ZC</td><td>216</td><td>8.27%</td><td>4.779%</td><td>0.093</td><td>8.3%</td><td>0.014</td><td>0.041</td><td>0.47</td></tr><tr><td>LO-HV</td><td>75</td><td>39.17%</td><td>21.446</td><td>0.27</td><td>41.00%</td><td>-0.143</td><td>0.25</td><td>0.806</td></tr><tr><td>MN-HV</td><td>186</td><td>10.66%</td><td>6.136%</td><td>0.079</td><td>6.200%</td><td>0.037</td><td>0.046</td><td>0.677</td></tr><tr><td>LO-PC</td><td>752</td><td>67.72%</td><td>35.522%</td><td>0.406</td><td>52.200%</td><td>-0.174</td><td>0.435</td><td>0.975</td></tr><tr><td>MN-PC</td><td>1438</td><td>3.9%</td><td>2.272%</td><td>0.197</td><td>33.900%</td><td>-0.015</td><td>0.042</td><td>0.196</td></tr></tbody></table></div><p><strong><em>Do tell me if you feel like this post helped you to some extent or not</em></strong></p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/09/30/2021-10-05-pair-trading-market-neutral/cover.png&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;Previous reading:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@mikelhsia/pair-trading-introduction-to-pair-trading-strategy-c97a1d0897ff&quot;&gt;【Pair Trading】Introduction to pair trading strategy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@mikelhsia/after-knowing-what-the-pair-trading-strategy-is-about-from-the-previous-post-were-going-to-use-98e41ef3ea5&quot;&gt;【Pair Trading】In-depth analysis of 5 distance approach strategies in pair trading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the previous post &lt;a href=&quot;https://medium.com/@mikelhsia/after-knowing-what-the-pair-trading-strategy-is-about-from-the-previous-post-were-going-to-use-98e41ef3ea5&quot;&gt;【Pair Trading】In-depth analysis of 5 distance approach strategies in pair trading&lt;/a&gt;, we have conducted various research against each variation of distance approaches in pair trading strategy. Despite the research has given us probable insights whether there is an &lt;strong&gt;$\alpha$&lt;/strong&gt; exists in the strategy we constructed, we still haven’t established our portfolio construction strategy. Here we introduce a concept called the “long-short equity (LSE)” strategy.&lt;/p&gt;
&lt;p&gt;Therefore, the objectives of this post are consists of three:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What is the long-short equity (LSE) strategy&lt;/li&gt;
&lt;li&gt;Review our backtest results to see the impact of adopting the long-short strategy&lt;/li&gt;
&lt;li&gt;What are the advanced strategies that we can explore&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Research" scheme="http://mikelhsia.github.io/tags/Research/"/>
    
    <category term="Pair Trading" scheme="http://mikelhsia.github.io/tags/Pair-Trading/"/>
    
  </entry>
  
  <entry>
    <title>【Pair Trading】Part 2. 5 in-depth analysis of distance approach in pair trading</title>
    <link href="http://mikelhsia.github.io/2021/08/30/2021-08-30-pair-trading-distance-approach/"/>
    <id>http://mikelhsia.github.io/2021/08/30/2021-08-30-pair-trading-distance-approach/</id>
    <published>2021-08-30T07:50:39.000Z</published>
    <updated>2021-10-12T12:21:24.471Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/cover.jpg" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>Previous readings</strong></th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/">【Pair Trading】Introduction to pair trading strategy</a></td></tr></tbody></table></div><p>After knowing what the pair trading strategy is about from the <a href="https://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/">previous post</a>, we’re going to use the <a href="https://www.quantconnect.com/">QuantConnect platform</a> to research and validate each variation of the <strong><em>distance method</em></strong>. The agenda of this post would be:</p><ol><li><strong>Introduction</strong>: what is the distance approach and what are its variants</li><li><strong>Research methodology</strong>: the methodology we use to conduct this research</li><li><strong>Research and performance analysis</strong>: Implement each variation and compare</li></ol><p>Let’s get it started!</p><a id="more"></a><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/get_started.jpg" class="" width="150"><hr><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The distance approach in pair trading was first popularized by Gatev, Goetzmann, and Rouwenhorst in their <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=141615">academic paper</a> in 2006. This was because of its effectiveness of selecting the paired stocks that track each other well back then. Along with the simplicity in calculating the distance which saves computation resources, this academic paper became the most cited paper of pair trading strategy and derived many different strategies to further discover the relationship between stocks in the stock pair.</p><h2 id="Basic-distance-approach"><a href="#Basic-distance-approach" class="headerlink" title="Basic distance approach"></a>Basic distance approach</h2><p>The basic idea of the distance approach is to use data in the formation period to calculate the <strong>Euclidean squared distances</strong> between each pair of normalized prices during the pair selection process. This <strong>Euclidean squared distance</strong> can be interpreted as the similarity of how do the stock normalized prices move in a defined period. The smaller the <strong>Euclidean squared distance</strong> of a stock pair is, the more similar movements these two assets have. Therefore, we’re going to pick the stock pair that has the smallest <strong>Euclidean squared distance</strong> as its spread should be stable enough to expect the spread will revert when rising to the peak or hitting the rock bottom.</p><script type="math/tex; mode=display">SSD (Sum\ of\ Squared\ Distance) = \sum \limits _{t=1} ^{N} ({P^1}_t - {P^2}_t)^2</script><p style="font-size: 0.8em; text-align:center; color: grey;">    <i><font >The formula of Euclidean squared distance</i></p><h2 id="Variants-of-distance-approach"><a href="#Variants-of-distance-approach" class="headerlink" title="Variants of distance approach"></a>Variants of distance approach</h2><p>Other than using <strong>Euclidean squared distance</strong> to evaluate how two assets are correlated, there are other methods evolving from the basic strategy such as Pearson’s correlation, distance correlation, angular distance, and so on. Also, there are other additional ideas added to the distance approach to discover what is the best-fit stock pair to be traded. The following methods were introduced in the below papers: <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=141615">Gatev et al. (2006): Pairs Trading: Performance of a Relative Value Arbitrage Rule</a>, <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1707125">Do and Faff(2011): Are Pairs Trading Profits Robust to Trading Costs?</a>, <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.547.8922&amp;rep=rep1&amp;type=pdf">Do and Faff (2012): Does Simple Pairs Trading Still Work?</a>. These approaches are:</p><ol><li>Selecting pairs that are in the same industry group</li><li>Selecting pairs with a higher number of zero-crossings</li><li>Selecting pairs with a higher historical variance</li><li>Selecting pairs with a higher Pearson’s correlation</li></ol><h1 id="Research-methodology"><a href="#Research-methodology" class="headerlink" title="Research methodology"></a>Research methodology</h1><p>To find out which one is the most effective method among distance approach and its variants, we have to set up a few rules to make sure that all backtests we are going to perform are tested under the same controlled environment:</p><ol><li>Use the constituents of the S&amp;P 500 index as our universe, meaning we will consider only the stocks that are in the S&amp;P 500 index.</li><li>Take <strong>12+12</strong> months’ daily close price of each stock in our defined universe. Data from the first 12-month period was used to form/train our pair trading model, and then the following 12 months’ data were used to backtest the model against the real-world scenario.</li><li>Normalize price data before we train our pair trading model. Let’s say we have stock A price ranging from \$100 ~ \$180, stock B price sits around \$20.00, and stock C price is over \$1000. The distances between pair A-B and pair B-C won’t be comparable because they don’t share the same starting point. Therefore normalizing price data removes the differences between two stock prices in order to make all pairs comparable.</li><li>As there are <strong>121,771</strong> pairs been generated, we reserve the top 10% and drop the remaining 90% of the under-performed pair in order not to waste time to analyze the pairs that are not significantly correlated.</li><li>Rank the stocks by the possibility of getting a positive return the next day (from high to low). The way to decide the possibility is different in every variant.</li><li>We calculate and analyze the expected return from two different angles in order to evaluate which strategy is better:<br> 6.1. <strong>Stratified analysis</strong>: Separate the stock pairs into 8 groups in order to see whether a higher possibility would actually result in a higher positive return.<br> 6.2. <strong>Long strategy analysis</strong>: Take the first 20 stocks to calculate the expected return so that we won’t take in too many noises into our performance analysis.</li><li>Generate trading signals:<br> 7.1. If the spread value exceeds 1.5 times of the historical deviations of the spread ($1.5\sigma$), generate a sell signal.<br> 7.2. If the spread value drops below 1.5 times of the historical deviations of the spread ($1.5\sigma$), generate a buy signal<br> 7.3. Close the open position when spread crosses over above or below the zero-line of the historical deviation.</li></ol><blockquote><p>Tips:</p><ol><li><code>itertools.combinations()</code> is a good util tool to create combinations contain two different symbols, for example <code>(&#39;AAPL&#39;,&#39;AMZN&#39;)</code></li><li>Normalization formula: $P_{Normalized} = \frac{P - min(P)}{max(P) - min(P)}$.</li><li>$min(P)$ and $max(P)$ are extracted from the formation period, and apply to the price data in backtest period</li></ol></blockquote><h1 id="Research-and-performance-analysis"><a href="#Research-and-performance-analysis" class="headerlink" title="Research and performance analysis"></a>Research and performance analysis</h1><p>Here we’re going to quickly talk about them and then we’ll conduct research and backtest against the basic distance approach and its variants.</p><h2 id="Basic-distance-approach-1"><a href="#Basic-distance-approach-1" class="headerlink" title="Basic distance approach"></a>Basic distance approach</h2><h3 id="Approach-description"><a href="#Approach-description" class="headerlink" title="Approach description"></a>Approach description</h3><p>We calculate the SSD of each pair and take the top 10% pairs which have the smallest SSD to conduct the performance analysis.</p><h3 id="Stratified-analysis"><a href="#Stratified-analysis" class="headerlink" title="Stratified analysis"></a>Stratified analysis</h3><p>Among 8 groups, group 1 contains the pairs that have the smallest SSD, and group 8 contains the pairs that have the biggest SSD. However, group 1 doesn’t seem to generate a positive expected return and group 8 doesn’t induce the relative huge loss as expected. The magnitude of SSD doesn’t seem to positively correlate to the expected return as we expect.</p><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/basic_stratified.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Basic distance approach stratified analysis</i></p><h3 id="Long-strategy-performance-analysis"><a href="#Long-strategy-performance-analysis" class="headerlink" title="Long strategy performance analysis"></a>Long strategy performance analysis</h3><p>If we long 20 the most stable stock pair by picking the pairs that have the smallest SSD, the portfolio still doesn’t generate a positive portfolio return over 12 months.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/basic_top.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Basic distance approach long strategy analysis (Top 20 stocks)</i></p><h2 id="Selecting-pairs-that-are-in-the-same-industry-group"><a href="#Selecting-pairs-that-are-in-the-same-industry-group" class="headerlink" title="Selecting pairs that are in the same industry group"></a>Selecting pairs that are in the same industry group</h2><p>This method holds an assumption that the paired stocks that are in the same industry are more likely to move together. So the idea here is to categorize each company by <a href="https://www.equitieslab.com/wiki/admin/morningstar-sector">Morning Star sector code</a> and pair the stocks within the same sector/industry group. Once we have these pairs from the same industry prepared, then we do exactly the same as the basic distance approach in order to analyze the portfolio performance.</p><h3 id="Stratified-analysis-1"><a href="#Stratified-analysis-1" class="headerlink" title="Stratified analysis"></a>Stratified analysis</h3><p>It’s still a mess. Our group 1 that suppose to make the most profit actually incurred the most loss. The lines that represented the accumulated return of each group tangled tightly instead of staying apart from each other.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/same_industry_stratified.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Same industry distance approach stratified analysis</i></p><h3 id="Stratified-analysis-by-sector"><a href="#Stratified-analysis-by-sector" class="headerlink" title="Stratified analysis by sector"></a>Stratified analysis by sector</h3><p>One more analysis we can do is to see which sector performs the worst. The sectors that perform the worst are <code>101</code> and <code>206</code>, which are the <code>Material</code> and the <code>Health care</code> sectors. Therefore by conducting the stratified analysis by sector, we could potentially initiate another strategy by removing the sectors that perform worse in the first place.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/same_industry_return_by_sector.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Expected return by sector</i></p><h3 id="Long-strategy-performance-analysis-1"><a href="#Long-strategy-performance-analysis-1" class="headerlink" title="Long strategy performance analysis"></a>Long strategy performance analysis</h3><p>It’s quite interesting to tell the line is very similar to the expected return above, meaning the top 20 pairs we picked could highly resemble the top 20 pairs in the basic distance approach. In terms of return, nothing gets improved. But one thing to be noticed is that by creating pairs within the same industry, we reduce the total pair from <strong>121,771</strong> pairs to <strong>13,207</strong> pairs and greatly reduce the time needed for the calculation.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/same_industry_top.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Same industry distance approach long strategy analysis (Top 20 stocks)</i></p><h2 id="Selecting-pairs-with-a-higher-number-of-zero-crossings"><a href="#Selecting-pairs-with-a-higher-number-of-zero-crossings" class="headerlink" title="Selecting pairs with a higher number of zero-crossings"></a>Selecting pairs with a higher number of zero-crossings</h2><p>It’s a good sign that the spread of the paired stocks is stable enough. However, if the spread of a certain pair is way too stable, there will be no chance for the traders to step in and make a profit. Therefore in this variant, among the top 10% pairs that have the smallest <strong>Euclidean squared distance</strong>, we further pick the pairs that had the highest number of crossing the zero-spread line. A high number of zero-crossing gives this pair enough energy to swing up and down, but without losing the ability to maintain its stability and come back to the zero-spread line.</p><p>Here’s a tip to share with you, that it’s fairly simple to calculate the number of zero-crossing if you have your spread in proper time-series format.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Both price_a and price_b are nd.array or pd.Series objects</span></span><br><span class="line">spread = pd.Series((price_a - price_b).reshape(<span class="number">-1</span>))</span><br><span class="line">num_of_zero_crossing = ((spread * spread.shift())&lt;<span class="number">0</span>).sum()</span><br></pre></td></tr></table></figure></p><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/zero-crossing.png" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Why the number of zero-crossing matters</i></p><h3 id="Stratified-analysis-2"><a href="#Stratified-analysis-2" class="headerlink" title="Stratified analysis"></a>Stratified analysis</h3><p>Now we do see the differences by adding the zero-crossing criteria. The first two groups that have the highest number of zero-crossing did stand out in the accumulated performance. However, the expected return of low zero-crossing pairs doesn’t tell us that we can count on this to form a market-neutral strategy. Maybe a long-only strategy would be better off.</p><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/zerocrossing_stratified.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Zero-crossing distance approach stratified analysis</i></p><h3 id="Long-strategy-performance-analysis-2"><a href="#Long-strategy-performance-analysis-2" class="headerlink" title="Long strategy performance analysis"></a>Long strategy performance analysis</h3><p>It does! THe long-only strategy definitely helps gradually accumulate our portfolio return. This diagram kind of proving our assumption that the high value of zero-crossing would single out the pairs that are more resilient and are capable of reverting back to the normal spread level.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/zerocrossing_top.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Zero-crossing distance approach long strategy analysis (Top 20 stocks)</i></p><h2 id="Selecting-pairs-with-higher-historical-variance"><a href="#Selecting-pairs-with-higher-historical-variance" class="headerlink" title="Selecting pairs with higher historical variance"></a>Selecting pairs with higher historical variance</h2><p>This variant actually used the same idea as above <code>Selecting pairs with a higher number of zero-crossings</code>. Instead of using the number of zero-crossings, this method takes the high variance as the sign of the spread between the paired stocks being fluctuated enough to be traded.</p><h3 id="Stratified-analysis-3"><a href="#Stratified-analysis-3" class="headerlink" title="Stratified analysis"></a>Stratified analysis</h3><p>Um…. Don’t even bother talking about this diagram. This result obviously tells us that this variant is not a fit for market neutral strategy.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/high_variance_stratified.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>High variance distance approach stratified analysis</i></p><h3 id="Long-strategy-performance-analysis-3"><a href="#Long-strategy-performance-analysis-3" class="headerlink" title="Long strategy performance analysis"></a>Long strategy performance analysis</h3><p>Even though the accumulated return looks weaker than the return from the high zero-crossing long strategy, we still can expect this long-only strategy to perform well.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/high_variance_top.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>High variance distance approach long strategy analysis (Top 20 stocks)</i></p><h2 id="Selecting-pairs-with-higher-Pearson’s-correlation"><a href="#Selecting-pairs-with-higher-Pearson’s-correlation" class="headerlink" title="Selecting pairs with higher Pearson’s correlation"></a>Selecting pairs with higher <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson’s correlation</a></h2><p>This method is relatively more complex than the above methods. This variant is mentioned in the paper <a href="http://www.pbcsf.tsinghua.edu.cn/research/chenzhuo/paper/Empirical%20Investigation%20of%20an%20Equity%20Pairs%20Trading%20Strategy.pdf">Chen et al. (2012): Empirical Investigation of an Equity Pairs Trading Strategy</a>, and the paper <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3608896">Christopher Krauss (2015): Statistical arbitrage pairs trading strategies: Review and outlook</a>.</p><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/one_track_many.jpeg" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>One tracks a group of assets instead of tracking just one</i></p><p>The idea of this method is that we’re going to use the composition of 50 stocks as the benchmark to calculate the spread against the target asset. In this way, we’ll be able to diversify the specific risk by comparing it to a basket of stocks. To do this, we will need to use Pearson’s correlation to pick out the 50 most related assets to construct the benchmark portfolio of the target asset. Then instead of using historical deviation ($1.5 \sigma$) as the threshold to trigger our trading signals, we use <strong><a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html">linear regression</a></strong> to construct the relation between two stocks and then use calculated $\alpha$ and $\beta$ to calculate the deviation. The higher the number of the deviation, the more likely deviation will revert.</p><script type="math/tex; mode=display">Deviation = R_{jt} - \alpha\ +\ \beta \times R_{it}</script><p>$where$</p><p>$R_{jt}$ is the return of the pairs portfolio</p><p>$R_{it}$ is the stock return</p><h3 id="Stratified-analysis-4"><a href="#Stratified-analysis-4" class="headerlink" title="Stratified analysis"></a>Stratified analysis</h3><p>This time we do something easier. We pick the top 20 stocks that deviate the most from its benchmark portfolio and long them and pick the bottom 20 pairs that deviate least and short them.</p><p>This would be the perfect variant to formulate both the market-neutral strategy and the long-only strategy. The return of the stocks we long go straight up and the return of the stocks we short go down. In the meantime, both lines are negatively correlated. When the green line drop below the bottom and break through the zero lines, the red line (the return of the stocks we short) revert and recover the loss from the green line. By longing the top 20 and shorting the bottom 20, we perfectly form the market-neutral strategy that still makes a positive return over 12 months including the bear market.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/pearson_correlation.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Pearson's correlation distance approach market neutral strategy</i></p><p><br></p><p><br><div style="border: 2pt solid lightgrey;border-radius: 4pt;box-shadow: 7px 7px lightgrey;padding: 1.3em;width:50%;margin:auto;"><i><b style="font-size:1.3em;padding: 1.3em;color:grey;">"Home Run!"</b></i><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/homerun.jpg" class="" width="300"></div><br></p><h1 id="Final-words-and-next-step"><a href="#Final-words-and-next-step" class="headerlink" title="Final words and next step"></a>Final words and next step</h1><p>Through the above researches, you can tell that the pair trading strategy is consist of four parts:</p><ol><li>Pair selection</li><li>Model formation (to form $\sigma$ or benchmark return in Pearson’s correlation variant)</li><li>Monitoring the current stats</li><li>Generate trading signals against the trained model</li></ol><p>The most important part I believe would be the pair selection part as I believe it’s crucial to find the pair/stock that does bounce back when the spread/price hit the ceiling and the floor. So essentially it’s still considered a mean reversion strategy.</p><p>Even though we have found our perfect strategy among these five variants, there are many things that we haven’t looked at such as:</p><ol><li>Should we use the rolling window to constantly update our model?</li><li>Should we trade more than 20 stocks at a time?</li><li>Should we find some other formulas to replace the Pearson’s correlation in order to find the more correlated paired stocks?</li><li>Should we expand the <strong>whole</strong> universe instead of only looking at the stocks in S&amp;P 500?</li></ol><p>These can be the potential improvements that can be experimented with. Also, make sure you run the proper backtest using the backtesting platform as <a href="https://www.quantconnect.com/">QuantConnect</a> or <a href="https://www.joinquant.com/">JointQaunt</a> to make sure you validate your algorithm against the real-world scenario.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://opencodecom.net/post/2021-04-30-pairs-trading-replicating-gatev-goetzmann-and-rouwenhorst-2006/">Pairs Trading: Replicating Gatev, Goetzmann and Rouwenhorst (2006)</a></li><li><a href="https://hudsonthames.org/research/">Hudson &amp; Thames Official website</a></li><li><a href="https://www.youtube.com/channel/UC8hI87gt0dmTAIEupEcsckA">Hudson &amp; Thames Youtube channel</a></li><li><a href="http://www.pbcsf.tsinghua.edu.cn/research/chenzhuo/paper/Empirical%20Investigation%20of%20an%20Equity%20Pairs%20Trading%20Strategy.pdf">Empirical Investigation of an Equity Pairs Trading Strategy</a></li><li><a href="https://www.quantconnect.com/tutorials/strategy-library/pairs-trading-with-stocks">QuantConnect Tutorials - Pair trading with stocks</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/08/30/2021-08-30-pair-trading-distance-approach/cover.jpg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;strong&gt;Previous readings&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/&quot;&gt;【Pair Trading】Introduction to pair trading strategy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;After knowing what the pair trading strategy is about from the &lt;a href=&quot;https://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/&quot;&gt;previous post&lt;/a&gt;, we’re going to use the &lt;a href=&quot;https://www.quantconnect.com/&quot;&gt;QuantConnect platform&lt;/a&gt; to research and validate each variation of the &lt;strong&gt;&lt;em&gt;distance method&lt;/em&gt;&lt;/strong&gt;. The agenda of this post would be:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Introduction&lt;/strong&gt;: what is the distance approach and what are its variants&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Research methodology&lt;/strong&gt;: the methodology we use to conduct this research&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Research and performance analysis&lt;/strong&gt;: Implement each variation and compare&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let’s get it started!&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Research" scheme="http://mikelhsia.github.io/tags/Research/"/>
    
    <category term="Pair Trading" scheme="http://mikelhsia.github.io/tags/Pair-Trading/"/>
    
  </entry>
  
  <entry>
    <title>【Pair Trading】Part 1. Introduction to pair trading strategy</title>
    <link href="http://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/"/>
    <id>http://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/</id>
    <published>2021-08-02T07:02:21.000Z</published>
    <updated>2021-10-12T12:21:24.470Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/08/02/2021-08-12-pair-trading/cover.jpg" class="" width="600"><p style="text-align:center; color: grey;">    <i>Pair trading is just like a man leashing a dog. They never apart too far away.</i></p><p>New Column started! In this new column, we’re going to start by introducing the idea and principle behind this famous strategy. In the later posts, we’ll do research using different famous methods in pair trading. Hopefully, we’ll cover the fundamental knowledge of pair trading as much as possible.</p><p>Pairs trading is among the most popular trading strategies in many markets. This particular strategy involves simultaneous taking two correlated assets in different directions, using one asset in the pair to hedge the risk of the other one. Essentially, it is a market-neutral strategy.</p><a id="more"></a><h1 id="What-is-the-pair-strategy"><a href="#What-is-the-pair-strategy" class="headerlink" title="What is the pair strategy?"></a>What is the pair strategy?</h1><p>Imagine this, if there are two convenience stores (A &amp; B) opened in one area. They import their ingredients from the same farm and sell the same meat product at the same price <code>$10</code>. Both stores are making a good profit. As the product price of both stores tracks closely to each other, it’s expected that there won’t be a big difference in prices.</p><img data-src="/2021/08/02/2021-08-12-pair-trading/stores.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>Store A and store B</i></p><p>One day, the farm raises the price of the ingredient, causing the owner of store A to decide to raise the price to <code>$12</code> to spread the cost to his customers. Unfortunately, the owner of store B was out of town so the price in store B stays at <code>$10</code>. According to our past experience, we expect the price difference to converge after the owner of store B comes back to town. As a clever consumer, what you should do to get benefits from this opportunity?</p><p>Should we buy more products from store B and store them in our warehouse at a cheaper price? Nah…. What if the farm again drops the price so that the product price would incline to drop as well. Our stock in the warehouse would be considered overpriced. The risk of taking either asset in one direction would be considered tremendous.</p><p>…</p><p>I believe as clever as you have already come up with the plan. We can buy the lower-priced product from store B, and sell it to the customers who want to buy the higher-priced product from store A. By doing that, there will be a <code>$2</code> profit <strong>per trade</strong>. We treat the price in store A and the price in store B as a pair. Whenever a price difference expands to certain degree, we could leverage the same strategy to buy the cheap one and sell the other expensive one. This can be exploited over and over again as long as the relationship between the price in store A and the price in store B doesn’t go away.</p><p>And, that is the pair trading strategy.</p><h1 id="History-of-pair-strategy"><a href="#History-of-pair-strategy" class="headerlink" title="History of pair strategy"></a>History of pair strategy</h1><p>Pair trading is a methodology and practice that derive from statistical arbitrage trading. It first appeared in the theory developed by Australian investor and hedge fund manager Alfred Winslow Jones in the 1950s. However, due to the nature of the pair trading strategy, these strategies were not made possible until the 1980s when computers gradually become popular.</p><p>In 1987, Morgan Stanley disclosed the fact that they have made over 50 million dollars on pair trading strategy. The money at that time was like 10 times more valuable than the same amount today. Therefore you could imagine the amount of money they have made with a single strategy. Even the details of this strategy were revealed over time, the pair strategy is still the most popular market-neutral strategy these days.</p><p>I learn from <a href="https://blog.pairtradefinder.com/best-trading-strategy-ever/">here</a> that pair strategy has been identified as the trading strategy used by <a href="https://en.wikipedia.org/wiki/Jim_Simons_(mathematician"><strong><em>Jim Simons</em></strong></a>), the most successful and smart hedge fund manager. He has publicly stated that the strategy his hedge fund adopting is contrarian: <code>often buying stocks (that) recently out of favor, and selling those recently in favor</code>.</p><p><div><iframe width='300' src="https://www.youtube.com/embed/lnSGgfv7Fv0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></p><p style="text-align:center; color: grey;">  <i>The Founder and President of Renaissance Technologies had to say publicly in Congressional testimony</i></p><p><br><div style="border: 2pt solid lightgrey;border-radius: 4pt;box-shadow: 7px 7px lightgrey;padding: 1.3em;width:80%;margin:auto;"><i><b style="font-size:1.3em;padding: 1.3em;color:grey;">"We often buying stocks (that) recently out of favor, and selling those recently in favor"</b></i></div><br></p><h1 id="The-principle-of-pair-trading"><a href="#The-principle-of-pair-trading" class="headerlink" title="The principle of pair trading"></a>The principle of pair trading</h1><p>Even though with all these talks and examples to explain what pair trading is, the principle of the pair trading is actually surprisingly simple. First we need to find out the right pair that the price movements of two assets follow a pattern. Let’s take the stock pair <code>KEY-RF</code> for example.</p><img data-src="/2021/08/02/2021-08-12-pair-trading/step1.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>The correlation between KEY and RF is fairly high</i></p><p>The price movements of <strong>KeyCorp(<a href="https://finance.yahoo.com/quote/KEY/">KEY</a>)</strong> and <strong>Regions Financial Corporation(<a href="https://finance.yahoo.com/quote/RF/">RF</a>)</strong> are very similar. But how similar they are? One way to do it is to check the price difference between their prices, which is called the <code>spread</code>. Therefore in the second step, we create a diagram of the spread to monitor the historic spread movement. To better understand the movement of spread, we marked the mean of the spread with the black dotted line, marked the threshold <code>mean + 1.5 * STD</code> and <code>mean - 1.5 * STD</code> to denote the area above and under the threshold are anomalies. As long as the spread breaks through the upper threshold, then we consider this a long signal. Once the movement drops to the mean of the spread, we consider the movement has restored to the normal level, so close the related positions.</p><img data-src="/2021/08/02/2021-08-12-pair-trading/step2.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>The price spread between `KEY` and `RF`, and the green triangle denotes the long signal.</i></p><p>The last rule we need to follow is, we long the cheaper asset and short the more expensive asset in the pair. Again taking the <code>KEY-RF</code> pair for example, if we follow the trigger generated in the above diagram, we gain $\$19 - \$9 = \$10.0$ from the <code>KEY</code> we short, and we lost $\$15.8 - \$8 = \$7.8$ from the <code>RF</code> we long. Combining the P&amp;L of these paired assets, we actually earned $\$10.0 - \$7.8 = \$2.2$ in this trade. In short, the profit earned from the pair trading strategy is not from the movement of the stock’s intrinsic value, but from the anticipation of the shrinkage of the price spread.</p><img data-src="/2021/08/02/2021-08-12-pair-trading/step3.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>KEY has recovered more return than what RF lost</i></p><p>To summarize everything in very simple words, there are only three steps to implement and execute the pair trading strategy:</p><ol><li>Find the target paired assets and how they are correlated</li><li>Monitor the movement to see when to generate the trading signals</li><li>Long the cheaper and short the more expensive when we see the trading signals.</li></ol><h1 id="How-to-find-the-pair-that-works"><a href="#How-to-find-the-pair-that-works" class="headerlink" title="How to find the pair that works?"></a>How to find the pair that works?</h1><p>So it all comes down to the question of how to find the right pair to trade. If two assets in your selected pair are not correlated or if they are correlated but the spread will not converge, then they are not the right pair to trade. Here are three methods you can use to try finding the right pair.</p><h2 id="According-to-business-models"><a href="#According-to-business-models" class="headerlink" title="According to business models"></a>According to business models</h2><p>We can choose two assets that are similar in their business model because they are suffering the same environmental risk, business risk, infrastructure risk, …, as well as external opportunities. As a result, their price movement has the inclination to move in the same direction with the same magnitude. A potentially good pair could be <code>UBER</code> v.s. <code>LYFT</code>, or <code>CCL</code> v.s. <code>RCL</code>.</p><img data-src="/2021/08/02/2021-08-12-pair-trading/cclvsrcl.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>CCL vs RCL in normalized price movement</i></p><h2 id="According-to-the-professional-knowledge"><a href="#According-to-the-professional-knowledge" class="headerlink" title="According to the professional knowledge"></a>According to the professional knowledge</h2><p>As the business models are the public information that is accessed by you and tens of thousands of people/institutions, the profit generated from this type of trading pair can fade away very quickly as so many parties are exploiting the same opportunity. To gain an edge competing with others, you need to study and work harder to keep yourself from competing with others in the red ocean.</p><p>If you understand the business models in a bigger picture, you can put all the small pieces of information together to solve the puzzles. For example, you get to learn that company B is the sole supplier of company A. So if company A makes a good profit in the fiscal year, then you can expect company B will make a good profits as well. If not, there might be a chance for arbitrages. Or, if you find out that an ETF was tracking with a stock index like S&amp;P 500, you can trade when the spread between the ETF and the index expends and close this trade when the spread converges. You can spot more and more opportunities like this when you understand the assets or the market more,</p><h2 id="According-to-the-pair-correlation-and-cointegration"><a href="#According-to-the-pair-correlation-and-cointegration" class="headerlink" title="According to the pair correlation and cointegration"></a>According to the pair correlation and cointegration</h2><p>This method is more of a mathematical way to find the right pair of assets. This post is already long enough, so you can check out this <a href="https://www.quora.com/What-is-the-difference-between-correlation-and-cointegration-Is-cointegration-a-good-measure-of-risk">Quora thread</a> before we get to this topic in the following post.</p><h1 id="Pair-trading-methods"><a href="#Pair-trading-methods" class="headerlink" title="Pair trading methods"></a>Pair trading methods</h1><p>Christopher Krauss has summarized various pair trading methods in his dissertation on <a href="https://www.econstor.eu/bitstream/10419/116783/1/833997289.pdf">Statistical arbitrage pairs trading strategies</a>. The methods are:</p><img data-src="/2021/08/02/2021-08-12-pair-trading/methods.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>Extracted from <a href='https://www.youtube.com/watch?v=gd009r7QUuM&list=PLfv9eTYgatm3oz8uq8G17-50ed_s-n5ds&index=2&t=238s'>Pairs Trading: The Distance Approach</a> by <a href='https://www.youtube.com/channel/UC8hI87gt0dmTAIEupEcsckA'>Hudson & Thames</a></i></p><p>We will cover these methods one by one in the following series.</p><h1 id="Pair-trading-resources"><a href="#Pair-trading-resources" class="headerlink" title="Pair trading resources"></a>Pair trading resources</h1><ul><li><a href="https://hudsonthames.org/">Hudson &amp; Thames</a><ul><li>It’s a research institution that puts a lot of effort into working on pair trading strategies. It also has a dedicated python library for people who are interested in working with pair trading strategies. Check out <a href="https://hudsonthames.org/research/">their blog here</a> for more articles related to what they are doing.</li></ul></li><li><a href="https://blog.pairtradefinder.com/">Pair Trading Finder</a> is a blog that publishes its research regularly. Other than telling you their latest research results, they even share the best pair of stocks of the month to be traded.</li></ul><p>In the next post, we’ll start looking at how to build our first pair trading strategy using the distance approach.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.newtraderu.com/2017/06/05/nature-pair-stock-trading-history/">The Nature of Pair Stock Trading History</a></li><li><a href="https://en.wikipedia.org/wiki/Pairs_trade">Pairs trade from Wikipedia</a></li><li><a href="https://www.investopedia.com/terms/p/pairstrade.asp">Pairs trade from investopedia</a></li><li><a href="https://blog.pairtradefinder.com/best-trading-strategy-ever/">The Best Trading Strategy Ever? The Results Speak for Themselves…</a></li><li><a href="https://algotrading101.com/learn/pairs-trading-guide/">Pairs Trading – A Real-World Guide</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/08/02/2021-08-12-pair-trading/cover.jpg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;Pair trading is just like a man leashing a dog. They never apart too far away.&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;New Column started! In this new column, we’re going to start by introducing the idea and principle behind this famous strategy. In the later posts, we’ll do research using different famous methods in pair trading. Hopefully, we’ll cover the fundamental knowledge of pair trading as much as possible.&lt;/p&gt;
&lt;p&gt;Pairs trading is among the most popular trading strategies in many markets. This particular strategy involves simultaneous taking two correlated assets in different directions, using one asset in the pair to hedge the risk of the other one. Essentially, it is a market-neutral strategy.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Research" scheme="http://mikelhsia.github.io/tags/Research/"/>
    
    <category term="Pair Trading" scheme="http://mikelhsia.github.io/tags/Pair-Trading/"/>
    
  </entry>
  
</feed>
