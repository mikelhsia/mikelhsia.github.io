<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael&#39;s blog</title>
  
  <subtitle>Life-long Learning</subtitle>
  <link href="http://mikelhsia.github.io/atom.xml" rel="self"/>
  
  <link href="http://mikelhsia.github.io/"/>
  <updated>2022-12-17T03:12:32.666Z</updated>
  <id>http://mikelhsia.github.io/</id>
  
  <author>
    <name>Michael Hsia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【How 2】 Set Up Trading API Template In Python - Q&amp;A</title>
    <link href="http://mikelhsia.github.io/2022/12/15/2022-12-17-IBKR-broker-4/"/>
    <id>http://mikelhsia.github.io/2022/12/15/2022-12-17-IBKR-broker-4/</id>
    <published>2022-12-15T07:30:52.000Z</published>
    <updated>2022-12-17T03:12:32.666Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/12/15/2022-12-17-IBKR-broker-4/cover.png" class="" width="800"><p>In the last post in this series, we’re going to look at some questions that I discovered while working on connecting to Interactive Broker API. Some of them are due to the obscurity of the configuration and hard to find the right place to configure them, and some of them would need the extra tool to resolve. I put all of them down into one post and share it with you.</p><a id="more"></a><hr><p>Become a <a href="https://youssefraafat57.medium.com/membership">Medium member</a> to continue learning without limits. I’ll receive a small portion of your membership fee if you use the following link, at no extra cost to you.</p><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">【Momentum Trading】A Defense Trading Strategy That Works - CPPI (Constant Proportion Portfolio Insurance)</a></li><li><a href="https://mikelhsia.github.io/2022/12/12/2022-12-10-IBKR-Broker/">【How 2】 Set Up Trading API Template In Python - Connecting My Trading Strategies To Interactive Brokers</a></li><li><a href="https://mikelhsia.github.io/2022/12/12/2022-12-16-IBKR-broker-2/">【How 2】 Set Up Trading API Template In Python - Placing Orders with Interactive Broker</a></li><li><a href="https://mikelhsia.github.io/2022/12/14/2022-12-17-IBKR-broker-3/">【How 2】 Set Up Trading API Template In Python - Build Local Storage For Storing Trades</a></li></ul><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="1-When-I’m-using-apscheduler-and-ib-insync-at-the-same-time-there-are-errors-and-I-can’t-get-my-trading-script-to-work"><a href="#1-When-I’m-using-apscheduler-and-ib-insync-at-the-same-time-there-are-errors-and-I-can’t-get-my-trading-script-to-work" class="headerlink" title="1. When I’m using apscheduler and ib_insync at the same time, there are errors and I can’t get my trading script to work"></a>1. When I’m using apscheduler and ib_insync at the same time, there are errors and I can’t get my trading script to work</h2><p><a href="https://apscheduler.readthedocs.io/en/3.x/"><code>Apscheduler</code></a> is the standard package in my quantitative trading setup. It’s a python library that helps you schedule your python code/function to be run at a specific DateTime or regular intervals with consideration of timezone. I gotta recommend this library to those traders/developers who have similar requirements in their trading scripts.</p><p>However, both <code>apscheduler</code> and <code>ib_insync</code> packages use the design of multi-threading in their package. If you include both of them, you’ll run into a problem and find a <code>RuntimeError</code> occurred when you try to run your script. Fortunately, <code>ib_insync</code> package includes this functionality to enable nested threading.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: There <span class="keyword">is</span> no current event loop <span class="keyword">in</span> thread <span class="string">&#x27;ThreadPoolExecutor-0_0&#x27;</span>.</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>RuntimeError saying there is no current event loop</i></p><p>And all you have to do is to:</p><ol><li>Call <code>ib_insync.util.patchAsyncio()</code> after you import <code>ib_insync</code> library.</li><li>Use <code>AsyncIOScheduler</code> to create your scheduler.</li><li>Add <code>async</code> before the scheduled function definition.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ibkr_api.py</span></span><br><span class="line"><span class="keyword">import</span> ib_insync</span><br><span class="line">ib_insync.util.patchAsyncio()</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.asyncio <span class="keyword">import</span> AsyncIOScheduler</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">  print(datetime.datetime.now().strftime(’%Y-%m-%d-%H_%M_%S’))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  scheduler = AsyncIOScheduler()</span><br><span class="line"></span><br><span class="line">  scheduler.add_job(</span><br><span class="line">    test,</span><br><span class="line">    <span class="string">&#x27;cron&#x27;</span>,</span><br><span class="line">    day_of_week=<span class="string">&#x27;mon-fri&#x27;</span>,</span><br><span class="line">    hour=<span class="number">9</span>,</span><br><span class="line">    minute=<span class="number">10</span>,</span><br><span class="line">    timezone=ZoneInfo(<span class="string">&#x27;US/Easter&#x27;</span>),</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Apscheduler + ib_insync code snippet</i></p><p>By making the above changes, the <code>apscheduler</code> and <code>ib_insync</code> can coexist in the same script.</p><blockquote><p><em>Note: There are things that could still go wrong as using the nested threads are relatively complicated.</em><br>Reference: <a href="https://groups.io/g/insync/topic/using_ib_insync_with/7866651">Using ib-insync with APScheduler</a></p></blockquote><h2 id="2-Why-I-can’t-get-a-valid-stock-price-back-by-using-reqMktData"><a href="#2-Why-I-can’t-get-a-valid-stock-price-back-by-using-reqMktData" class="headerlink" title="2. Why I can’t get a valid stock price back by using reqMktData?"></a>2. Why I can’t get a valid stock price back by using reqMktData?</h2><p>There are several steps and restrictions for requesting stock prices using <code>reqMktData()</code> function:</p><ol><li>Before requesting a market quote, you need to subscribe to the market data on the IBKR platform. You can find the management page in the TWS or IB gateway tab <em>“Account” -&gt; “Manage Account” -&gt; “Subscribe Market Data/Research”</em>.</li><li>The <code>ib.reqMarketDataType(N)</code> is to specify what kind of data type you would like to request. For example, if you request market data type = 1 (live market data) outside the trading hour, you won’t be able to receive any valid pricing data from the server. Therefore choose the market data type carefully, and test and explore their limitation.</li><li>As said in the previous post, this entire querying of pricing data is an asynchronous process, meaning you could run into the situation that you’re accessing the pricing data while your script is still trying to fetch the data from the server. Therefore, remember to use <code>ib.sleep()</code> wisely to ensure you only access the pricing data when the pricing data is returned.</li></ol><blockquote><p>Reference: <a href="https://mikelhsia.github.io/2022/12/12/2022-12-16-IBKR-broker-2/">【How 2】 Set Up Trading API Template In Python - Placing orders with Interactive Brokers</a></p></blockquote><h2 id="3-There-are-popup-windows-that-prevent-me-from-placing-orders-using-API-What-happened"><a href="#3-There-are-popup-windows-that-prevent-me-from-placing-orders-using-API-What-happened" class="headerlink" title="3. There are popup windows that prevent me from placing orders using API. What happened?"></a>3. There are popup windows that prevent me from placing orders using API. What happened?</h2><p>Inside the TWS and the IB gateway, there are pre-configured conditions that prevent API consumers to place an unintended order. If you accidentally place an order that falls outside of the size or value range, or if the current market data is lagged and hasn’t been updated for a long time, then the TWS/IB gateway will pop up a warning window to tell you that there is a potential hazard to place such an order.</p><p>To prevent this from happening and stop your trading script, you can check the box in <em>API -&gt; Precautions -&gt; “Bypass Order Precaution for API Order”</em> to prevent the warning dialog boxes from popping up when you place orders through API. Yet, you have to bare the risk of unexpected loss when your script goes wrong.</p><img data-src="/2022/12/15/2022-12-17-IBKR-broker-4/order_precaution.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Check this checkbox to prevent the warning appears when placing orders via API</i></p><blockquote><p>Reference: <a href="https://guides.interactivebrokers.com/tws/usersguidebook/configuretws/apiprecautions.htm">API Precautions</a></p></blockquote><h2 id="4-How-could-I-reset-my-paper-account"><a href="#4-How-could-I-reset-my-paper-account" class="headerlink" title="4. How could I reset my paper account?"></a>4. How could I reset my paper account?</h2><p>Whenever you feel like starting a new test from a clean slate, you can always reset your paper account. However, the setting is quite hard to find. You have to log in to your paper account on the IBKR website, and then follow the below steps to reset your paper account.</p><img data-src="/2022/12/15/2022-12-17-IBKR-broker-4/step1.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>How to reset your paper account 1</i></p><img data-src="/2022/12/15/2022-12-17-IBKR-broker-4/step2.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>How to reset your paper account 2</i></p><img data-src="/2022/12/15/2022-12-17-IBKR-broker-4/step3.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>How to reset your paper account 3</i></p><h2 id="5-There-are-times-that-my-TWS-or-IB-gateway-won’t-successfully-auto-reconnect-What-should-I-do"><a href="#5-There-are-times-that-my-TWS-or-IB-gateway-won’t-successfully-auto-reconnect-What-should-I-do" class="headerlink" title="5. There are times that my TWS or IB gateway won’t successfully auto-reconnect. What should I do?"></a>5. There are times that my TWS or IB gateway won’t successfully auto-reconnect. What should I do?</h2><p>TWS and IB gateway are two very important intermediaries to relay the API instructions from your local trading script to the remote IBKR API server. However, there is a hidden mechanism inside TWS and IB gateway applications. These two applications need to restart every day and will automatically reconnect, and require human intervention to log in again every seven days. Therefore, there are two scenarios that we need to address:</p><ol><li><strong>Q:</strong> How do we keep the connection with IBKR after the software applications have auto-reconnected?<ul><li><strong>A:</strong> Avoid using the long connection as possible. Disconnect your <code>IB()</code> instance as long as the required actions are done, and reconnect to the server when new actions are needed.</li></ul></li><li><strong>Q:</strong> What if there’s an error occurred while software applications are rebooting?<ul><li><strong>A:</strong> As the software applications are run locally on your desktop or laptop, meaning this type of software crash is not monitored by any script or process. One possible solution is to wrap the headless software application inside docker. You can download the docker image of “ib-gateway-docker” from <a href="https://github.com/UnusualAlpha/ib-gateway-docker">here</a> and run this docker container on your local machine so that the process can be protected and monitored by the daemon inside the docker container.</li></ul></li></ol><blockquote><p>Reference:<a href="https://github.com/UnusualAlpha/ib-gateway-docker">IB gateway docker</a></p></blockquote><h2 id="6-What-to-do-with-2-factor-authentication-when-trading-using-a-real-account"><a href="#6-What-to-do-with-2-factor-authentication-when-trading-using-a-real-account" class="headerlink" title="6. What to do with 2-factor authentication when trading using a real account?"></a>6. What to do with 2-factor authentication when trading using a real account?</h2><p>Since Interactive Brokers adopts two-factor authentication for logging in and buying/selling stocks, it essentially means that working with Interactive Brokers API won’t be fully automated (See <a href="https://ibkr.info/article/2260">here</a> and <a href="https://ibkr.info/article/2879">here</a>). Every time you place a random order or log in to your TWS/IB gateway application, you will receive a message on your smartphone to confirm your corresponding action once more “<strong>manually</strong>“. Here are two posts that could give you a rough idea of how to work with this two-factor authentication system:</p><ul><li><a href="https://groups.io/g/insync/topic/81744821#6060">live trading and two-factor authentication</a></li><li><a href="https://groups.io/g/insync/topic/95475509#8603">Watchdog with 2fa</a></li></ul><p>There could be a possibility in the future to have a workaround to bypass this system. Currently, having your smartphone with you during trading hours would seem to be the most promising method.</p><hr><p>This is the last post in this <strong><em>Set-Up Trading API Template In Python</em></strong> series. I hope you enjoy reading these and let me know if there is any other topic you would like to read.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/12/15/2022-12-17-IBKR-broker-4/cover.png&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;p&gt;In the last post in this series, we’re going to look at some questions that I discovered while working on connecting to Interactive Broker API. Some of them are due to the obscurity of the configuration and hard to find the right place to configure them, and some of them would need the extra tool to resolve. I put all of them down into one post and share it with you.&lt;/p&gt;</summary>
    
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/categories/How2/"/>
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/How2/Quantitative-Trading/"/>
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/tags/How2/"/>
    
    <category term="Interactive Broker" scheme="http://mikelhsia.github.io/tags/Interactive-Broker/"/>
    
  </entry>
  
  <entry>
    <title>【How 2】 Set Up Trading API Template In Python - Build Local Storage For Storing Trades</title>
    <link href="http://mikelhsia.github.io/2022/12/14/2022-12-17-IBKR-broker-3/"/>
    <id>http://mikelhsia.github.io/2022/12/14/2022-12-17-IBKR-broker-3/</id>
    <published>2022-12-13T17:42:02.000Z</published>
    <updated>2022-12-15T07:12:01.091Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/12/14/2022-12-17-IBKR-broker-3/cover.png" class="" width="800"><p>Now we come to the third part of this series. In this post, I’m going to show you how I design and build my local database to store IBKR trades and other necessary information for generating meaningful indicators to review our strategy performance.</p><a id="more"></a><hr><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">【Momentum Trading】A Defense Trading Strategy That Works - CPPI (Constant Proportion Portfolio Insurance)</a></li><li><a href="https://mikelhsia.github.io/2022/12/12/2022-12-10-IBKR-Broker/">【How 2】 Set Up Trading API Template In Python - Connecting My Trading Strategies To Interactive Brokers</a></li><li><a href="https://mikelhsia.github.io/2022/12/12/2022-12-16-IBKR-broker-2/">【How 2】 Set Up Trading API Template In Python - Placing Orders with Interactive Broker</a></li></ul><h1 id="Why-do-we-need-to-build-this-capability-ourselves"><a href="#Why-do-we-need-to-build-this-capability-ourselves" class="headerlink" title="Why do we need to build this capability ourselves?"></a>Why do we need to build this capability ourselves?</h1><p>We have most of our functions ready in our previous two posts except the <code>def get_transaction()</code> function. Most of the brokers would provide the function to retrieve historic transactions for at least 60 days. However, Interactive Brokers doesn’t support the functionality to retrieve the historic trades and portfolio performance from it. The reason I want this function supported is that I need to:</p><ol><li>Use the historic portfolio performance to compare with the benchmark evaluating KPIs and see whether my trading strategy is successful or not.</li><li>In the <a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">CPPI strategy</a> we talked about before, the B and E ratio calculation depends on the previous day’s maximum portfolio value. Therefore we need to persist it so that we won’t lose it every time we restart our trading script.</li><li>I would like to take the impact of the commission into account. Since Interactive Brokers won’t save my trading records any longer, I would need to save those trading records on my local DB so that I get to keep track of the commission spent on this strategy.</li></ol><p>To address the requirements that I put together above, building a database on the local machine is imperative. Below, I’m going to put down my solution into two sections:</p><ul><li>Design DB schema</li><li>Implement DB-related capabilities</li></ul><p>Also, in terms of which DB should be used here, SQL such as MySql or NoSQL like MongoDB will be too complicated and way too powerful. Therefore, I simply pick <code>sqlite3</code> to create easy-to-use local storage.</p><h1 id="Design-DB-schema"><a href="#Design-DB-schema" class="headerlink" title="Design DB schema"></a>Design DB schema</h1><p>We are going to create three tables, and each of them is going to address the requirements that we raised above respectively.</p><ul><li>IB_SQLITE_CPPI_TBL_NAME<ul><li>The only critical variable here is the <code>MAX_ASSET</code>. This is a value to keep track of the max portfolio value and calculate the CPPI E_ratio and B_ratio. If you want to know why we need this variable tracked in the data table, you can check out <a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">this post</a></li></ul></li><li>IB_SQLITE_TRANSACTION_TBL_NAME<ul><li>This table is basically recording the daily performance of our portfolio and market benchmark. We have <code>PORTFOLIO_CLOSE_VALUE</code>, <code>SPY_CLOSE_PRICE</code>, and <code>COMMISSION</code>, where the commission is a sum added up from the <strong>IB_SQLITE_ORDER_TBL_NAME</strong>.</li></ul></li><li>IB_SQLITE_ORDER_TBL_NAME<ul><li>This table is meant to record all the orders placed. I extracted the following information from the <code>ib.trades()</code> response and tuck them into the table: <code>symbol</code>, <code>order_id</code>, <code>action</code> (buy or sell), <code>quantity</code>, <code>order status</code>, <code>commission cost</code>, and the <code>account number</code>.</li></ul></li></ul><img data-src="/2022/12/14/2022-12-17-IBKR-broker-3/db_schema.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>DB schema of three tables</i></p><h1 id="Implement-DB-related-capabilities"><a href="#Implement-DB-related-capabilities" class="headerlink" title="Implement DB-related capabilities"></a>Implement DB-related capabilities</h1><img data-src="/2022/12/14/2022-12-17-IBKR-broker-3/db_helper_functions.png" class="" width="600"><p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Private and public functions for managing our DB</i></p><br>Here I separated the functions into two groups. The first part of functions is the private functions that conduct database operations such as connecting to the database, creating the table, checking whether the table exists or not, and so on. This provides the minimum capability for managing the database. The second part of the functions is public functions that use private functions to interact with the specified data table in the database.</p><p>Below are the private sqlite3 DB functions:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="comment"># Sqlite3 private functions</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqlite_connect</span>(<span class="params">self</span>):</span></span><br><span class="line">    dirs = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        db_path = os.path.join(dirs, IB_SQLITE_DB_NAME)</span><br><span class="line">        conn = sqlite3.connect(db_path)</span><br><span class="line">        print(<span class="string">f&#x27;Sqlite connection established&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> conn</span><br><span class="line">        conn.close()</span><br><span class="line">        print(<span class="string">f&#x27;Sqlite connection closed&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">f&#x27;We are having an OS error&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sqlite_create_table</span>(<span class="params">self, conn=None, tbl_name=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tbl_name <span class="keyword">or</span> <span class="keyword">not</span> conn:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tbl_name == IB_SQLITE_TRANSACTION_TBL_NAME:</span><br><span class="line">        conn.execute(<span class="string">f&#x27;&#x27;&#x27;CREATE TABLE <span class="subst">&#123;IB_SQLITE_TRANSACTION_TBL_NAME&#125;</span></span></span><br><span class="line"><span class="string">            (ID INTEGER PRIMARY KEY AUTOINCREMENT,</span></span><br><span class="line"><span class="string">            CREATE_TIME DATETIME NOT NULL,</span></span><br><span class="line"><span class="string">            PORTFOLIO_CLOSE_VALUE FLOAT NOT NULL,</span></span><br><span class="line"><span class="string">            SPY_CLOSE_PRICE FLOAT NOT NULL,</span></span><br><span class="line"><span class="string">            COMMISSION FLOAT NOT NULL);</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> tbl_name == IB_SQLITE_CPPI_TBL_NAME:</span><br><span class="line">        conn.execute(<span class="string">f&#x27;&#x27;&#x27;CREATE TABLE <span class="subst">&#123;IB_SQLITE_CPPI_TBL_NAME&#125;</span></span></span><br><span class="line"><span class="string">            (ID INTEGER PRIMARY KEY AUTOINCREMENT,</span></span><br><span class="line"><span class="string">            CREATE_TIME DATETIME NOT NULL,</span></span><br><span class="line"><span class="string">            MAX_ASSET FLOAT NOT NULL,</span></span><br><span class="line"><span class="string">            E_RATIO FLOAT NOT NULL,</span></span><br><span class="line"><span class="string">            B_RATIO FLOAT NOT NULL);</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> tbl_name == IB_SQLITE_ORDER_TBL_NAME:</span><br><span class="line">        conn.execute(<span class="string">f&#x27;&#x27;&#x27;CREATE TABLE <span class="subst">&#123;IB_SQLITE_ORDER_TBL_NAME&#125;</span></span></span><br><span class="line"><span class="string">            (ID INTEGER PRIMARY KEY AUTOINCREMENT,</span></span><br><span class="line"><span class="string">            CREATE_TIME DATETIME NOT NULL,</span></span><br><span class="line"><span class="string">            SYMBOL TEXT NOT NULL,</span></span><br><span class="line"><span class="string">            ORDER_ID TEXT NOT NULL UNIQUE,</span></span><br><span class="line"><span class="string">            ACTION TEXT NOT NULL,</span></span><br><span class="line"><span class="string">            QUANTITY INT NOT NULL,</span></span><br><span class="line"><span class="string">            ORDER_STATUS TEXT NOT NULL,</span></span><br><span class="line"><span class="string">            COMMISSION FLOAT NOT NULL,</span></span><br><span class="line"><span class="string">            ACCOUNT TEXT NOT NULL);</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sqlite_is_table_exist</span>(<span class="params">self, conn=None, tbl_name=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tbl_name <span class="keyword">or</span> <span class="keyword">not</span> conn:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    c = conn.cursor()</span><br><span class="line"></span><br><span class="line">    c.execute(<span class="string">f&#x27;&#x27;&#x27;SELECT count(name)</span></span><br><span class="line"><span class="string">        FROM sqlite_master</span></span><br><span class="line"><span class="string">        WHERE type=&quot;table&quot; AND name=&quot;<span class="subst">&#123;tbl_name&#125;</span>&quot;;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.fetchone()[<span class="number">0</span>]==<span class="number">1</span> :</span><br><span class="line">        <span class="comment"># Table exists</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="comment"># Table does not exist</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sqlite_query_data</span>(<span class="params">self, conn=None, tbl_name=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> conn <span class="keyword">or</span> <span class="keyword">not</span> tbl_name:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.__sqlite_is_table_exist(conn, tbl_name):</span><br><span class="line">        self.__sqlite_create_table(conn, tbl_name)</span><br><span class="line"></span><br><span class="line">    df = pd.read_sql_query(<span class="string">f&#x27;SELECT * from <span class="subst">&#123;tbl_name&#125;</span>;&#x27;</span>, conn)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sqlite_insert_record</span>(<span class="params">self, conn=None, sql=None, value_tuple: tuple=None, tbl_name=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.__sqlite_is_table_exist(conn, tbl_name):</span><br><span class="line">        self.__sqlite_create_table(conn, tbl_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sql:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f&#x27;SQL string is empty&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    conn.execute(sql, value_tuple)</span><br><span class="line"></span><br><span class="line">    conn.commit()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><p>As for the public functions in our script, they provide support for our trading script so that it can achieve the purpose we want it to.</p><p>First of all, these two functions are for us to retrieve data from the corresponding data table and return in <code>pd.DataFrame()</code> format.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_transactions</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        df = self.__sqlite_query_data(conn, IB_SQLITE_TRANSACTION_TBL_NAME)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cppi_variables</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        df = self.__sqlite_query_data(conn, IB_SQLITE_CPPI_TBL_NAME)</span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure></p><p>Secondly, we created three functions for handling parsing the corresponding API responses into the data format we need. Therefore, this part of the functions involves interacting with the Interactive Brokers API, fetching data from sqlite3 local database, and processing the data accordingly.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_orders_in_db</span>(<span class="params">self</span>):</span></span><br><span class="line">    sql = <span class="string">f&#x27;&#x27;&#x27;INSERT OR IGNORE INTO <span class="subst">&#123;IB_SQLITE_ORDER_TBL_NAME&#125;</span> (CREATE_TIME, SYMBOL, ORDER_ID, ACTION, QUANTITY, ORDER_STATUS, COMMISSION, ACCOUNT) VALUES (?, ?, ?, ?, ?, ?, ?, ?);&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        trades = self.client.trades()</span><br><span class="line">        <span class="keyword">for</span> trade <span class="keyword">in</span> trades:</span><br><span class="line">            perm_id = trade.order.permId</span><br><span class="line">            qty = trade.order.filledQuantity</span><br><span class="line">            symbol = trade.contract.symbol</span><br><span class="line">            action = trade.order.action</span><br><span class="line">            commission = sum([fill.commissionReport.commission <span class="keyword">for</span> fill <span class="keyword">in</span> trade.fills])</span><br><span class="line">            status = trade.orderStatus.status</span><br><span class="line">            exec_time = trade.log[<span class="number">0</span>].time</span><br><span class="line">            account = trade.order.account</span><br><span class="line">            self.__sqlite_insert_record(</span><br><span class="line">                conn,</span><br><span class="line">                sql,</span><br><span class="line">                (exec_time, symbol, perm_id, action, qty, status, commission, account),</span><br><span class="line">                IB_SQLITE_ORDER_TBL_NAME</span><br><span class="line">            )</span><br><span class="line">    logger.logger.debug(<span class="string">f&#x27;Database <span class="subst">&#123;IB_SQLITE_ORDER_TBL_NAME&#125;</span> updated&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_transactions_in_db</span>(<span class="params">self</span>):</span></span><br><span class="line">    sql = <span class="string">f&#x27;&#x27;&#x27;INSERT OR IGNORE INTO <span class="subst">&#123;IB_SQLITE_TRANSACTION_TBL_NAME&#125;</span> (CREATE_TIME, PORTFOLIO_CLOSE_VALUE, SPY_CLOSE_PRICE, COMMISSION) VALUES (?,?,?,?);&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Portfolio value</span></span><br><span class="line">    portfolio_value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> self.accounts:</span><br><span class="line">        data = self.client.accountValues(account)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;TotalCashBalance&#x27;</span>, <span class="string">&#x27;StockMarketValue&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                portfolio_value += float(row.value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># SPY close value</span></span><br><span class="line">    benchmark_value = self.get_last_price_from_quote(<span class="string">&#x27;SPY&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update the latest commission</span></span><br><span class="line">    commission = self.get_commission_from_db(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        self.__sqlite_insert_record(</span><br><span class="line">            conn,</span><br><span class="line">            sql,</span><br><span class="line">            (datetime.now(), portfolio_value, benchmark_value, commission),</span><br><span class="line">            IB_SQLITE_TRANSACTION_TBL_NAME</span><br><span class="line">        )</span><br><span class="line">    logger.logger.debug(<span class="string">f&#x27;Database <span class="subst">&#123;IB_SQLITE_TRANSACTION_TBL_NAME&#125;</span> updated&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_cppi_variables_in_db</span>(<span class="params">self, max_asset, E, B</span>):</span></span><br><span class="line">    sql = <span class="string">f&#x27;&#x27;&#x27;INSERT OR IGNORE INTO <span class="subst">&#123;IB_SQLITE_CPPI_TBL_NAME&#125;</span> (CREATE_TIME, MAX_ASSET, E_RATIO, B_RATIO) VALUES (?,?,?,?);&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        self.__sqlite_insert_record(</span><br><span class="line">            conn,</span><br><span class="line">            sql,</span><br><span class="line">            (datetime.now(), max_asset, E, B),</span><br><span class="line">            IB_SQLITE_CPPI_TBL_NAME</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><p>Lastly, this is the function to achieve the goal for me to calculate the commission sum on the day (or for multiple days).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_commission_from_db</span>(<span class="params">self, time_delta:int=<span class="number">0</span></span>) -&gt; float:</span></span><br><span class="line">    <span class="keyword">with</span> self.sqlite_connect() <span class="keyword">as</span> conn:</span><br><span class="line">        df = self.__sqlite_query_data(conn, IB_SQLITE_ORDER_TBL_NAME)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df.empty:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> df[(datetime.now(self.timezone) - pd.to_datetime(df[<span class="string">&#x27;CREATE_TIME&#x27;</span>], utc=<span class="literal">False</span>)) &lt; timedelta(days=time_delta)][<span class="string">&#x27;COMMISSION&#x27;</span>].sum()</span><br></pre></td></tr></table></figure><h1 id="My-strategy-report-card"><a href="#My-strategy-report-card" class="headerlink" title="My strategy report card"></a>My strategy report card</h1><p>In the last part of this post, I’ll show you the portfolio performance metrics that I plan using to evaluate the trading strategy with the data stored in our local database. You can also modify the DB schema, record the information you need, and come up with important and helpful for you to evaluate the effectiveness of your trading script.</p><ol><li>Sharpe Ratio (SR)</li><li>Total return</li><li>Annualized return</li><li>Variance</li><li>Max Drawdown (MDD)</li><li>Trading fee spent</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_strategy_report</span>(<span class="params">self, config=None, verbose=False</span>):</span></span><br><span class="line">    final = self.get_transactions()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> verbose <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        print(final)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tmp.empty:</span><br><span class="line">        ret_data[<span class="string">&#x27;Version&#x27;</span>] = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">        ret_data[<span class="string">&#x27;SR/Portfolio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;SR/Benchmark&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Total Return/Portfolio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Total Return/Benchmark&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Annualized Return/Portfolio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Annualized Return/Benchmark&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Variance/Portfolio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Variance/Benchmark&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;MDD/Portfolio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;MDD/Benchmark&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Trading fee&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Trading fee ratio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ret_data[<span class="string">&#x27;Version&#x27;</span>] = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">        ret_data[<span class="string">&#x27;SR/Portfolio&#x27;</span>] = tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>].mean() / tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>].std()</span><br><span class="line">        ret_data[<span class="string">&#x27;SR/Benchmark&#x27;</span>] = tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>].mean() / tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>].std()</span><br><span class="line">        ret_data[<span class="string">&#x27;Total Return/Portfolio&#x27;</span>] = (tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>].iloc[<span class="number">-1</span>] / c[<span class="string">&#x27;init_cash&#x27;</span>]) - <span class="number">1</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Total Return/Benchmark&#x27;</span>] = (tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>].iloc[<span class="number">-1</span>] / tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>].iloc[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Annualized Return/Portfolio&#x27;</span>] = (<span class="number">1</span> + ret_data[<span class="string">&#x27;Total Return/Portfolio&#x27;</span>])**(<span class="number">365</span>/(datetime.today() - pd.to_datetime(c[<span class="string">&#x27;start_date&#x27;</span>])).days) - <span class="number">1</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Annualized Return/Benchmark&#x27;</span>] = (<span class="number">1</span> + ret_data[<span class="string">&#x27;Total Return/Benchmark&#x27;</span>])**(<span class="number">365</span>/(datetime.today() - pd.to_datetime(c[<span class="string">&#x27;start_date&#x27;</span>])).days) - <span class="number">1</span></span><br><span class="line">        ret_data[<span class="string">&#x27;Variance/Portfolio&#x27;</span>] = tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>].var()</span><br><span class="line">        ret_data[<span class="string">&#x27;Variance/Benchmark&#x27;</span>] = tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>].var()</span><br><span class="line">        ret_data[<span class="string">&#x27;MDD/Portfolio&#x27;</span>] = self.__calculate_mdd(tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>])</span><br><span class="line">        ret_data[<span class="string">&#x27;MDD/Benchmark&#x27;</span>] = self.__calculate_mdd(tmp.loc[:, <span class="string">&#x27;SPY_CLOSE_PRICE&#x27;</span>])</span><br><span class="line">        ret_data[<span class="string">&#x27;Trading fee&#x27;</span>] = tmp.loc[:, <span class="string">&#x27;COMMISSION&#x27;</span>].sum()</span><br><span class="line">        ret_data[<span class="string">&#x27;Trading fee ratio&#x27;</span>] = ret_data[<span class="string">&#x27;Trading fee&#x27;</span>] / tmp.loc[:, <span class="string">&#x27;PORTFOLIO_CLOSE_VALUE&#x27;</span>].iloc[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret_data</span><br></pre></td></tr></table></figure><hr><p>That’s it! I know it’s a bit too much code and too little talk in this post, but a good trading strategy should always include a performance evaluation to know whether this strategy is still in effect. This is the last bit of what I built in my API template so I hope it would help people who want to build their own API templates.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/12/14/2022-12-17-IBKR-broker-3/cover.png&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;p&gt;Now we come to the third part of this series. In this post, I’m going to show you how I design and build my local database to store IBKR trades and other necessary information for generating meaningful indicators to review our strategy performance.&lt;/p&gt;</summary>
    
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/categories/How2/"/>
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/How2/Quantitative-Trading/"/>
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/tags/How2/"/>
    
    <category term="Python3" scheme="http://mikelhsia.github.io/tags/Python3/"/>
    
    <category term="Interactive Broker" scheme="http://mikelhsia.github.io/tags/Interactive-Broker/"/>
    
    <category term="Sqlite3" scheme="http://mikelhsia.github.io/tags/Sqlite3/"/>
    
  </entry>
  
  <entry>
    <title>【How 2】 Set Up Trading API Template In Python - Placing orders with Interactive Brokers</title>
    <link href="http://mikelhsia.github.io/2022/12/12/2022-12-16-IBKR-broker-2/"/>
    <id>http://mikelhsia.github.io/2022/12/12/2022-12-16-IBKR-broker-2/</id>
    <published>2022-12-12T03:11:24.000Z</published>
    <updated>2022-12-15T07:05:45.858Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/12/12/2022-12-16-IBKR-broker-2/cover.png" class="" width="800"><p>This is the second part of the <a href="https://mikelhsia.github.io/2022/12/12/2022-12-10-IBKR-Broker/"><strong>Set Up Trading API Template In Python</strong></a>. We’re going to focus on implementing the rest of the functions in our Interactive Broker class.</p><a id="more"></a><hr><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">【Momentum Trading】A Defense Trading Strategy That Works - CPPI (Constant Proportion Portfolio Insurance)</a></li><li><a href="https://mikelhsia.github.io/2022/12/12/2022-12-10-IBKR-Broker/">【How 2】Set Up Trading API Template In Python - Connecting My Trading Strategies To Interactive Brokers</a></li></ul><h1 id="Recap-and-what’s-the-next"><a href="#Recap-and-what’s-the-next" class="headerlink" title="Recap and what’s the next"></a>Recap and what’s the next</h1><p>In the previous post, we get to know how our trading script sends API calls to the IBKR API service via the IB gateway. Also, we have learned how to configure the IB gateway application. Lastly, we also showcase the code snippet to get the available cash balance and the total investment market value under your account from the server. Now, we’ll look at the rest of the functions in our <code>InteractiveBrokerTradeAPI</code> class.</p><ul><li>Get a much more detailed status report with get_account_detail</li><li>Fetch the market calendar</li><li>How to create a valid order for Interactive Broker</li></ul><h1 id="API-document-reference"><a href="#API-document-reference" class="headerlink" title="API document reference"></a>API document reference</h1><p><a href="https://ib-insync.readthedocs.io/api.html"><code>ib_insync</code></a></p><h1 id="Get-a-deep-dive-status-report-with-get-account-detail"><a href="#Get-a-deep-dive-status-report-with-get-account-detail" class="headerlink" title="Get a deep dive status report with get_account_detail"></a>Get a deep dive status report with get_account_detail</h1><p>The <code>get_account_detail()</code> in our earlier example has successfully extracted the <code>TotalCashBalance</code> and <code>StockMarketValue</code> from the <code>ib.accountValues()</code> response. Yet, if we would like to know more about our portfolio status, we can include two more calls to obtain more information about our portfolio: 1. positions in our portfolio, 2. the orders that we placed in the past 24 hours.</p><p>For 1., we use <code>ib.portfolio()</code> to acquire information on the stocks we hold. We will extract the position size and the market value of each symbol, thus gaining a bigger picture of how our portfolio looks like.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[PortfolioItem(contract=Stock(conId=<span class="number">42454579</span>, symbol=<span class="string">&#x27;SHV&#x27;</span>, right=<span class="string">&#x27;0&#x27;</span>, primaryExchange=<span class="string">&#x27;NASDAQ&#x27;</span>, currency=<span class="string">&#x27;USD&#x27;</span>, localSymbol=<span class="string">&#x27;SHV&#x27;</span>, tradingClass=<span class="string">&#x27;NMS&#x27;</span>), position=<span class="number">427.0</span>, marketPrice=<span class="number">109.9701004</span>, marketValue=<span class="number">46957.23</span>, averageCost=<span class="number">109.98463535</span>, unrealizedPNL=<span class="number">-6.21</span>, realizedPNL=<span class="number">0.0</span>, account=<span class="string">&#x27;DU4399668&#x27;</span>),</span><br><span class="line"> PortfolioItem(contract=Stock(conId=<span class="number">39622943</span>, symbol=<span class="string">&#x27;SSO&#x27;</span>, right=<span class="string">&#x27;0&#x27;</span>, primaryExchange=<span class="string">&#x27;ARCA&#x27;</span>, currency=<span class="string">&#x27;USD&#x27;</span>, localSymbol=<span class="string">&#x27;SSO&#x27;</span>, tradingClass=<span class="string">&#x27;SSO&#x27;</span>), position=<span class="number">1060.0</span>, marketPrice=<span class="number">47.5340004</span>, marketValue=<span class="number">50386.04</span>, averageCost=<span class="number">48.7388397</span>, unrealizedPNL=<span class="number">-1277.13</span>, realizedPNL=<span class="number">-62.91</span>, account=<span class="string">&#x27;DU4399668&#x27;</span>)]</span><br></pre></td></tr></table></figure></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Response from <b>ib.portfolio()</b> call</i></p><p>As for 2., we use <code>ib.trades()</code> to obtain the trades we made in the past 24 hours. Remember, the Interactive broker holds this information for only 24 hours or so, and you won’t be able to retrieve this piece once the server drops this information. Therefore, we will find a way to address this in another post to persist the order-related information. In the below Trade objects, we extract the information we need such as order id, average price, order status, commission cost, and so on for each symbol.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Trade(contract=Stock(conId=<span class="number">42454579</span>, symbol=<span class="string">&#x27;SHV&#x27;</span>, right=<span class="string">&#x27;?&#x27;</span>, exchange=<span class="string">&#x27;SMART&#x27;</span>, currency=<span class="string">&#x27;USD&#x27;</span>, localSymbol=<span class="string">&#x27;SHV&#x27;</span>, tradingClass=<span class="string">&#x27;NMS&#x27;</span>), order=Order(permId=<span class="number">423185966</span>, action=<span class="string">&#x27;SELL&#x27;</span>, orderType=<span class="string">&#x27;MKT&#x27;</span>, lmtPrice=<span class="number">0.0</span>, auxPrice=<span class="number">0.0</span>, tif=<span class="string">&#x27;DAY&#x27;</span>, ocaType=<span class="number">3</span>, displaySize=<span class="number">2147483647</span>, rule80A=<span class="string">&#x27;0&#x27;</span>, openClose=<span class="string">&#x27;&#x27;</span>, volatilityType=<span class="number">0</span>, deltaNeutralOrderType=<span class="string">&#x27;None&#x27;</span>, referencePriceType=<span class="number">0</span>, account=<span class="string">&#x27;DU4399668&#x27;</span>, clearingIntent=<span class="string">&#x27;IB&#x27;</span>, cashQty=<span class="number">0.0</span>, dontUseAutoPriceForHedge=True, filledQuantity=<span class="number">1.0</span>, refFuturesConId=<span class="number">2147483647</span>, shareholder=<span class="string">&#x27;Not an insider or substantial shareholder&#x27;</span>), orderStatus=OrderStatus(orderId=<span class="number">0</span>, status=<span class="string">&#x27;Filled&#x27;</span>, filled=<span class="number">0.0</span>, remaining=<span class="number">0.0</span>, avgFillPrice=<span class="number">0.0</span>, permId=<span class="number">0</span>, parentId=<span class="number">0</span>, lastFillPrice=<span class="number">0.0</span>, clientId=<span class="number">0</span>, whyHeld=<span class="string">&#x27;&#x27;</span>, mktCapPrice=<span class="number">0.0</span>), fills=[Fill(contract=Stock(conId=<span class="number">42454579</span>, symbol=<span class="string">&#x27;SHV&#x27;</span>, right=<span class="string">&#x27;?&#x27;</span>, exchange=<span class="string">&#x27;SMART&#x27;</span>, currency=<span class="string">&#x27;USD&#x27;</span>, localSymbol=<span class="string">&#x27;SHV&#x27;</span>, tradingClass=<span class="string">&#x27;NMS&#x27;</span>), execution=Execution(execId=<span class="string">&#x27;00025b49.63971bea.01.01&#x27;</span>, time=datetime.datetime(<span class="number">2022</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">38</span>, tzinfo=datetime.timezone.utc), acctNumber=<span class="string">&#x27;DU4399668&#x27;</span>, exchange=<span class="string">&#x27;EDGEA&#x27;</span>, side=<span class="string">&#x27;SLD&#x27;</span>, shares=<span class="number">1.0</span>, price=<span class="number">109.97</span>, permId=<span class="number">423185966</span>, clientId=<span class="number">0</span>, orderId=<span class="number">0</span>, liquidation=<span class="number">0</span>, cumQty=<span class="number">1.0</span>, avgPrice=<span class="number">109.97</span>, orderRef=<span class="string">&#x27;&#x27;</span>, evRule=<span class="string">&#x27;&#x27;</span>, evMultiplier=<span class="number">0.0</span>, modelCode=<span class="string">&#x27;&#x27;</span>, lastLiquidity=<span class="number">2</span>), commissionReport=CommissionReport(execId=<span class="string">&#x27;00025b49.63971bea.01.01&#x27;</span>, commission=<span class="number">1.002648</span>, currency=<span class="string">&#x27;USD&#x27;</span>, realizedPNL=<span class="number">-1.017284</span>, yield_=<span class="number">0.0</span>, yieldRedemptionDate=<span class="number">0</span>), time=datetime.datetime(<span class="number">2022</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">38</span>, tzinfo=datetime.timezone.utc))], log=[TradeLogEntry(time=datetime.datetime(<span class="number">2022</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">38</span>, tzinfo=datetime.timezone.utc), status=<span class="string">&#x27;Filled&#x27;</span>, message=<span class="string">&#x27;Fill 1.0@109.97&#x27;</span>, errorCode=<span class="number">0</span>)], advancedError=<span class="string">&#x27;&#x27;</span>)]</span><br></pre></td></tr></table></figure></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Response from <b>ib.trades()</b> call</i></p><p>Combining everything we talked about above, we can construct our <code>get_account_detail()</code> function as below:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_account_detail</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.accounts = self.client.managedAccounts()</span><br><span class="line"></span><br><span class="line">    acc_data = []</span><br><span class="line">    <span class="keyword">for</span> account <span class="keyword">in</span> self.accounts:</span><br><span class="line">        acc = &#123;&#125;</span><br><span class="line">        acc[<span class="string">&#x27;account&#x27;</span>] = account</span><br><span class="line">        data = self.client.accountValues(account)</span><br><span class="line">        acc[<span class="string">&#x27;cash&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        acc[<span class="string">&#x27;total_assets&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;TotalCashBalance&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                acc[<span class="string">&#x27;cash&#x27;</span>] = row.value</span><br><span class="line">                acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">            <span class="keyword">elif</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;StockMarketValue&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">        acc_data.append(acc)</span><br><span class="line"></span><br><span class="line">    pos_data = []</span><br><span class="line">    data = self.client.portfolio()</span><br><span class="line">    <span class="keyword">for</span> position <span class="keyword">in</span> data:</span><br><span class="line">        pos = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        pos[<span class="string">&#x27;code&#x27;</span>] = position.contract.symbol</span><br><span class="line">        pos[<span class="string">&#x27;qty&#x27;</span>] = position.position</span><br><span class="line">        pos[<span class="string">&#x27;cost_price&#x27;</span>] = position.averageCost</span><br><span class="line">        pos[<span class="string">&#x27;market_val&#x27;</span>] = position.marketValue</span><br><span class="line">        pos[<span class="string">&#x27;pl_val&#x27;</span>] = position.unrealizedPNL</span><br><span class="line">        <span class="keyword">if</span> pos[<span class="string">&#x27;cost_price&#x27;</span>] * pos[<span class="string">&#x27;qty&#x27;</span>] == <span class="number">0</span>:</span><br><span class="line">            pos[<span class="string">&#x27;pl_ratio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pos[<span class="string">&#x27;pl_ratio&#x27;</span>] = pos[<span class="string">&#x27;pl_val&#x27;</span>] / (pos[<span class="string">&#x27;cost_price&#x27;</span>] * pos[<span class="string">&#x27;qty&#x27;</span>])</span><br><span class="line">        pos_data.append(pos)</span><br><span class="line"></span><br><span class="line">    orders_data = []</span><br><span class="line">    data = self.client.trades()</span><br><span class="line">    <span class="keyword">for</span> order <span class="keyword">in</span> data:</span><br><span class="line">        o = &#123;&#125;</span><br><span class="line">        o[<span class="string">&#x27;order_id&#x27;</span>] = order.order.orderId</span><br><span class="line">        o[<span class="string">&#x27;order_status&#x27;</span>] = order.orderStatus.status</span><br><span class="line">        o[<span class="string">&#x27;create_time&#x27;</span>] = order.log[<span class="number">-1</span>].time</span><br><span class="line">        o[<span class="string">&#x27;trd_side&#x27;</span>] = order.order.action</span><br><span class="line">        o[<span class="string">&#x27;order_type&#x27;</span>] = order.order.action</span><br><span class="line">        o[<span class="string">&#x27;code&#x27;</span>] = order.contract.symbol</span><br><span class="line">        orders_data.append(o)</span><br><span class="line">    <span class="keyword">return</span> acc_data, pos_data, orders_data</span><br></pre></td></tr></table></figure></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Full code of <b>get_account_detail()</b> function</i></p><h1 id="Fetch-the-market-calendar"><a href="#Fetch-the-market-calendar" class="headerlink" title="Fetch the market calendar"></a>Fetch the market calendar</h1><p>The trading hours information in <code>ib_insync</code> package is quite discreet. After reading the API document very carefully, I finally found it in the response of <code>ib.reqContractDetails()</code> call and look like this:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ContractDetails(contract=Contract(secType=<span class="string">&#x27;STK&#x27;</span>, conId=<span class="number">756733</span>, symbol=<span class="string">&#x27;SPY&#x27;</span>, exchange=<span class="string">&#x27;SMART&#x27;</span>, primaryExchange=<span class="string">&#x27;ARCA&#x27;</span>, currency=<span class="string">&#x27;USD&#x27;</span>, localSymbol=<span class="string">&#x27;SPY&#x27;</span>,</span><br><span class="line">tradingClass=<span class="string">&#x27;SPY&#x27;</span>), marketName=<span class="string">&#x27;SPY&#x27;</span>, minTick=<span class="number">0.01</span>, orderTypes=<span class="string">&#x27;ACTIVETIM,AD,ADJUST,ALERT,ALGO,ALLOC,AON,AVGCOST,BASKET,BENCHPX,CASHQTY,COND,CONDORDER,DARKONLY,</span></span><br><span class="line"><span class="string">DARKPOLL,DAY,DEACT,DEACTDIS,DEACTEOD,DIS,DUR,GAT,GTC,GTD,GTT,HID,IBKRATS,ICE,IOC,LIT,LMT,LOC,MIDPX,MIT,MKT,MOC,MTL,NGCOMB,NODARK,NONALGO,OCA,OPG,OPGREROUT,PEGBENCH,</span></span><br><span class="line"><span class="string">PEGMID,POSTATS,POSTONLY,PREOPGRTH,PRICECHK,REL,REL2MID,RELPCTOFS,RTH,SCALE,SCALEODD,SCALERST,SIZECHK,SMARTSTG,SNAPMID,SNAPMKT,SNAPREL,STP,STPLMT,SWEEP,TRAIL,TRAILLIT,</span></span><br><span class="line"><span class="string">TRAILLMT,TRAILMIT,WHATIF&#x27;</span>, validExchanges=<span class="string">&#x27;SMART,AMEX,NYSE,CBOE,PHLX,ISE,CHX,ARCA,ISLAND,DRCTEDGE,BEX,BATS,EDGEA,CSFBALGO,JEFFALGO,BYX,IEX,EDGX,FOXRIVER,PEARL,NYSENAT,</span></span><br><span class="line"><span class="string">LTSE,MEMX,IBEOS,PSX&#x27;</span>, priceMagnifier=<span class="number">1</span>, underConId=<span class="number">0</span>, longName=<span class="string">&#x27;SPDR S&amp;P 500 ETF TRUST&#x27;</span>, contractMonth=<span class="string">&#x27;&#x27;</span>, industry=<span class="string">&#x27;&#x27;</span>, category=<span class="string">&#x27;&#x27;</span>, subcategory=<span class="string">&#x27;&#x27;</span>, timeZoneId=<span class="string">&#x27;US/Eastern&#x27;</span>,</span><br><span class="line"> tradingHours=<span class="string">&#x27;20221212:0400-20221212:2000;20221213:0400-20221213:2000;20221214:0400-20221214:2000;20221215:0400-20221215:2000;20221216:0400-20221216:2000&#x27;</span>,</span><br><span class="line"> liquidHours=<span class="string">&#x27;20221212:0930-20221212:1600;20221213:0930-20221213:1600;20221214:0930-20221214:1600;20221215:0930-20221215:1600;20221216:0930-20221216:1600&#x27;</span>, evRule=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"> evMultiplier=<span class="number">0</span>, mdSizeMultiplier=<span class="number">1</span>, aggGroup=<span class="number">1</span>, underSymbol=<span class="string">&#x27;&#x27;</span>, underSecType=<span class="string">&#x27;&#x27;</span>, marketRuleIds=<span class="string">&#x27;26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26&#x27;</span>,</span><br><span class="line"> secIdList=[TagValue(tag=<span class="string">&#x27;ISIN&#x27;</span>, value=<span class="string">&#x27;US78462F1030&#x27;</span>)], realExpirationDate=<span class="string">&#x27;&#x27;</span>, lastTradeTime=<span class="string">&#x27;&#x27;</span>, stockType=<span class="string">&#x27;ETF&#x27;</span>, minSize=<span class="number">0.0001</span>, sizeIncrement=<span class="number">0.0001</span>,</span><br><span class="line"> suggestedSizeIncrement=<span class="number">100.0</span>, cusip=<span class="string">&#x27;&#x27;</span>, ratings=<span class="string">&#x27;&#x27;</span>, descAppend=<span class="string">&#x27;&#x27;</span>, bondType=<span class="string">&#x27;&#x27;</span>, couponType=<span class="string">&#x27;&#x27;</span>, callable=False, putable=False, coupon=<span class="number">0</span>, convertible=False,</span><br><span class="line"> maturity=<span class="string">&#x27;&#x27;</span>, issueDate=<span class="string">&#x27;&#x27;</span>, nextOptionDate=<span class="string">&#x27;&#x27;</span>, nextOptionType=<span class="string">&#x27;&#x27;</span>, nextOptionPartial=False, notes=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Response of <b></b>ib.reqContractDetails()</b> functions</i></p><p>The trading calendar resides in this response, and we can extract them by parsing them like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_market_open</span>(<span class="params">self, offset_days=<span class="number">0</span></span>):</span></span><br><span class="line">    spy_contract = ib_insync.Stock(<span class="string">&#x27;SPY&#x27;</span>, <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">    self.client.qualifyContracts(spy_contract)</span><br><span class="line">    trading_days = self.client.reqContractDetails(spy_contract)[<span class="number">0</span>].liquidHours</span><br><span class="line">    trading_days_dict = &#123;d.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>]:d.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>] <span class="keyword">for</span> d <span class="keyword">in</span> trading_days.split(<span class="string">&#x27;;&#x27;</span>)&#125;</span><br><span class="line">    today_str = (datetime.now().astimezone(self.timezone) + timedelta(days=offset_days)).strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> trading_days_dict.items():</span><br><span class="line">        <span class="keyword">if</span> (today_str <span class="keyword">in</span> k) <span class="keyword">and</span> (v == <span class="string">&#x27;CLOSED&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_market_open_now</span>(<span class="params">self</span>):</span></span><br><span class="line">    spy_contract = ib_insync.Stock(<span class="string">&#x27;SPY&#x27;</span>, <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">    self.client.qualifyContracts(spy_contract)</span><br><span class="line">    trading_days = self.client.reqContractDetails(spy_contract)[<span class="number">0</span>].liquidHours</span><br><span class="line">    trading_days_list = [d.split(<span class="string">&#x27;-&#x27;</span>) <span class="keyword">for</span> d <span class="keyword">in</span> trading_days.split(<span class="string">&#x27;;&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">    day_str = datetime.now().astimezone(self.timezone).strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">    time_str = datetime.now().astimezone(self.timezone).strftime(<span class="string">&#x27;%H%M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> trading_days_list:</span><br><span class="line">        <span class="keyword">if</span> len(d) &gt; <span class="number">1</span> <span class="keyword">and</span> day_str <span class="keyword">in</span> d[<span class="number">0</span>].split()[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">if</span> time_str &gt; d[<span class="number">0</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>] <span class="keyword">and</span> time_str &lt; d[<span class="number">1</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Full code of <b>is_market_open()</b> and <b>is_market_open_now()</b> functions</i></p><h1 id="How-to-create-a-valid-order-for-Interactive-Broker"><a href="#How-to-create-a-valid-order-for-Interactive-Broker" class="headerlink" title="How to create a valid order for Interactive Broker"></a>How to create a valid order for Interactive Broker</h1><p>In order to create a valid order that Interactive Broker could recognize, there are a few steps to follow:</p><ol><li>Specify the symbol and the currency used. Use <code>contract = ib_insync.Stock(symbol, &#39;SMART&#39;, self.currency)</code> to create a <code>contract</code> object for later use. Stock symbol would be the first parameter, the name of the stock exchange be the second, and the currency symbol (here we use <code>USD</code>) would be the third.</li><li>Make a query to the broker to filter and find the related stock information. <code>ib.qualifyContracts(contract)</code> would activate the <code>contract</code> object and infuse live data from the stock exchange.<img data-src="/2022/12/12/2022-12-16-IBKR-broker-2/contract.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;"><i>Contract object before and after using <b>ib.qualifyContracts()</b> to infuse correct data</i></p></li><li>We need the latest quote price in order to calculate how many shares we would like to purchase. First of all, you need to specify the <code>reqMarketDataType</code> to tell the server which type of data you’re requesting. There are four market data types:<ol><li>1 - Live market data: (top of the book)</li><li>2 - Frozen data (at the close)</li><li>3 - Delayed data (can be used if there are no live subscriptions)</li><li>4 - Frozen Delayed data (outside of regular trading hours)<br>Once we have specified the market data type, we’re all set to request the quote price from the server using the <code>contract</code> in your first parameter and <code>snapshot</code> to <em>True</em>.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ib.reqMarketDataType(<span class="number">3</span>)</span><br><span class="line">quote = ib.reqMktData(</span><br><span class="line">    contract,</span><br><span class="line">    genericTickList=<span class="string">&quot;&quot;</span>,</span><br><span class="line">    snapshot=<span class="literal">True</span>,</span><br><span class="line">    regulatorySnapshot=<span class="literal">False</span>,</span><br><span class="line">    mktDataOptions=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>One thing worth mentioning is that, do you remember the reason why I’m using the <code>ib_insync</code> package instead of the native IBKR API? Instead of saying fetching a quote price from the API server, subscribing to the periodical price change would be a better way to put it. We first subscribe to the price bar to get 5-minute, 10-minute, or one-day price data, and another thread would be created to stream the price data. Therefore, to extract the quote price from the returned object, you first must ensure the quote price has been successfully returned/received.<blockquote><p><em>Notes: Before requesting a market quote, you need to subscribe to the market data on the IBKR platform. You can find the management page in the TWS or IB gateway tab “Account” -&gt; “Manage Account” -&gt; “Subscribe Market Data/Research”</em></p></blockquote></li></ol></li><li>Lastly, other than using <code>sleep()</code> function call to ensure that we have received the price data from the server, we can also assign the callback function to monitor the status of a specific order status change. Here we use a global configuration under the <code>ib</code> instance to specify this callback function by using <code>ib.orderStatusEvent += [callback function]</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.client = ib_insync.IB()</span><br><span class="line">    <span class="comment"># Newly added</span></span><br><span class="line">    self.client.orderStatusEvent += self.__order_status</span><br><span class="line">    self.client.connect(</span><br><span class="line">        IB_TWS_URI,</span><br><span class="line">        <span class="comment"># IB_GATEWAY_PAPER_PORT,</span></span><br><span class="line">        IB_TWS_PAPER_PORT,</span><br><span class="line">        IB_TWS_CLIENT_ID</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> self</span><br><span class="line"></span><br><span class="line">    self.client.disconnect()</span><br><span class="line">    self.client.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">place_order</span>(<span class="params">self, symbol: str, quantity: int, price: float=<span class="number">0</span></span>):</span></span><br><span class="line">    contract = ib_insync.Stock(symbol.upper(), <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">    self.client.qualifyContracts(contract)</span><br><span class="line">    <span class="keyword">if</span> quantity &gt;= <span class="number">0.0</span>:</span><br><span class="line">        order = ib_insync.MarketOrder(<span class="string">&#x27;BUY&#x27;</span>, quantity)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        order = ib_insync.MarketOrder(<span class="string">&#x27;SELL&#x27;</span>, -quantity)</span><br><span class="line">    trade = self.client.placeOrder(contract, order)</span><br><span class="line">    self.client.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_last_price_from_quote</span>(<span class="params">self</span>):</span></span><br><span class="line">    contract = ib_insync.Stock(symbol.upper(), <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">    self.client.qualifyContracts(contract)</span><br><span class="line">    <span class="comment"># ib.reqMarketDataType(1)   # Live market data: (top of the book)</span></span><br><span class="line">    <span class="comment"># ib.reqMarketDataType(2)   # Frozen data (at the close)</span></span><br><span class="line">    <span class="comment"># ib.reqMarketDataType(3)   # Delayed data (can be used if there is no live subscriptions)</span></span><br><span class="line">    <span class="comment"># ib.reqMarketDataType(4)   # Frozen Delayed data (outside of regular trading hours)</span></span><br><span class="line">    self.client.reqMarketDataType(<span class="number">3</span>)</span><br><span class="line">    quote = self.client.reqMktData(</span><br><span class="line">        contract,</span><br><span class="line">        genericTickList=<span class="string">&quot;&quot;</span>,</span><br><span class="line">        snapshot=<span class="literal">True</span>,</span><br><span class="line">        regulatorySnapshot=<span class="literal">False</span>,</span><br><span class="line">        mktDataOptions=<span class="literal">None</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> math.isnan(quote.last):</span><br><span class="line">            self.client.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> quote.last</span><br><span class="line">    logger.logger.error(<span class="string">&#x27;&#123;&#125;[&#123;&#125;]: &#123;&#125;&#x27;</span>.format(sys._getframe().f_code.co_name, symbol, <span class="string">&#x27;No last price in quote&#x27;</span>))</span><br><span class="line">    self.notifier.send_msg(<span class="string">&#x27;&#123;&#125;[&#123;&#125;]&#x27;</span>.format(sys._getframe().f_code.co_name, symbol), <span class="string">&#x27;No last price in quote&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__order_status</span>(<span class="params">self, trade</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Call back function for checking order status</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">f&#x27;Order [<span class="subst">&#123;trade.contract.symbol&#125;</span>] status updated: <span class="subst">&#123;trade.orderStatus.status&#125;</span>&#x27;</span>)</span><br><span class="line">    match trade.orderStatus.status:</span><br><span class="line">        case <span class="string">&#x27;Filled&#x27;</span>:</span><br><span class="line">            print(<span class="string">f&#x27;<span class="subst">&#123;trade=&#125;</span>&#x27;</span>)</span><br><span class="line">            self.update_order_from_filledEvent_in_db(trade)</span><br><span class="line">        case <span class="string">&#x27;PendingSubmit&#x27;</span>:</span><br><span class="line">            <span class="comment"># print(f&#x27;Pending submit: &#123;trade&#125;&#x27;)</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        case <span class="string">&#x27;Submitted&#x27;</span>:</span><br><span class="line">            <span class="comment"># print(f&#x27;Submitted: &#123;trade&#125;&#x27;)</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        case _:</span><br><span class="line">            <span class="comment"># print(f&#x27;Others: &#123;trade.orderStatus.status&#125;&#x27;)</span></span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="Let’s-wrap-it-up"><a href="#Let’s-wrap-it-up" class="headerlink" title="Let’s wrap it up"></a>Let’s wrap it up</h1><p>We have all the pieces ready except the <code>get_transaction()</code>, which we will talk about it in another post as we need to take Database management into account. Let’s now add some test code so that you can also place the order.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="keyword">import</span> ib_insync</span><br><span class="line"><span class="keyword">from</span> modules.broker.TradeAPI <span class="keyword">import</span> AbstractTradeInterface</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> zoneinfo <span class="keyword">import</span> ZoneInfo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InteractiveBrokerTradeAPI</span>(<span class="params">AbstractTradeInterface</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,currency=<span class="string">&#x27;USD&#x27;</span></span>):</span></span><br><span class="line">        self.client = <span class="literal">None</span></span><br><span class="line">        self.accounts = []</span><br><span class="line">        self.currency = currency</span><br><span class="line">        self.timezone = ZoneInfo(<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @contextmanager</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.client = ib_insync.IB()</span><br><span class="line">        <span class="comment"># Newly added</span></span><br><span class="line">        self.client.orderStatusEvent += self.__order_status</span><br><span class="line">        self.client.connect(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">7497</span>, <span class="number">101</span>)</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">        print(<span class="string">&quot;Connection established&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> self</span><br><span class="line"></span><br><span class="line">        self.client.disconnect()</span><br><span class="line">        self.client.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">        print(<span class="string">&quot;Connection closed&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_account_detail</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.accounts = self.client.managedAccounts()</span><br><span class="line"></span><br><span class="line">        acc_data = []</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> self.accounts:</span><br><span class="line">            acc = &#123;&#125;</span><br><span class="line">            acc[<span class="string">&#x27;account&#x27;</span>] = account</span><br><span class="line">            data = self.client.accountValues(account)</span><br><span class="line">            acc[<span class="string">&#x27;cash&#x27;</span>] = <span class="number">0</span></span><br><span class="line">            acc[<span class="string">&#x27;total_assets&#x27;</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">if</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;TotalCashBalance&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                    acc[<span class="string">&#x27;cash&#x27;</span>] = row.value</span><br><span class="line">                    acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">                <span class="keyword">elif</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;StockMarketValue&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                    acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">            acc_data.append(acc)</span><br><span class="line"></span><br><span class="line">        pos_data = []</span><br><span class="line">        data = self.client.portfolio()</span><br><span class="line">        <span class="keyword">for</span> position <span class="keyword">in</span> data:</span><br><span class="line">            pos = &#123;&#125;</span><br><span class="line"></span><br><span class="line">            pos[<span class="string">&#x27;code&#x27;</span>] = position.contract.symbol</span><br><span class="line">            pos[<span class="string">&#x27;qty&#x27;</span>] = position.position</span><br><span class="line">            pos[<span class="string">&#x27;cost_price&#x27;</span>] = position.averageCost</span><br><span class="line">            pos[<span class="string">&#x27;market_val&#x27;</span>] = position.marketValue</span><br><span class="line">            pos[<span class="string">&#x27;pl_val&#x27;</span>] = position.unrealizedPNL</span><br><span class="line">            <span class="keyword">if</span> pos[<span class="string">&#x27;cost_price&#x27;</span>] * pos[<span class="string">&#x27;qty&#x27;</span>] == <span class="number">0</span>:</span><br><span class="line">                pos[<span class="string">&#x27;pl_ratio&#x27;</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos[<span class="string">&#x27;pl_ratio&#x27;</span>] = pos[<span class="string">&#x27;pl_val&#x27;</span>] / (pos[<span class="string">&#x27;cost_price&#x27;</span>] * pos[<span class="string">&#x27;qty&#x27;</span>])</span><br><span class="line">            pos_data.append(pos)</span><br><span class="line"></span><br><span class="line">        orders_data = []</span><br><span class="line">        data = self.client.trades()</span><br><span class="line">        <span class="keyword">for</span> order <span class="keyword">in</span> data:</span><br><span class="line">            o = &#123;&#125;</span><br><span class="line">            o[<span class="string">&#x27;order_id&#x27;</span>] = order.order.permId</span><br><span class="line">            o[<span class="string">&#x27;order_status&#x27;</span>] = order.orderStatus.status</span><br><span class="line">            o[<span class="string">&#x27;create_time&#x27;</span>] = order.log[<span class="number">-1</span>].time</span><br><span class="line">            o[<span class="string">&#x27;trd_side&#x27;</span>] = order.order.action</span><br><span class="line">            o[<span class="string">&#x27;order_type&#x27;</span>] = order.order.action</span><br><span class="line">            o[<span class="string">&#x27;code&#x27;</span>] = order.contract.symbol</span><br><span class="line">            orders_data.append(o)</span><br><span class="line">        <span class="keyword">return</span> acc_data, pos_data, orders_data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">place_order</span>(<span class="params">self, symbol: str, quantity: int, price: float=<span class="number">0</span></span>):</span></span><br><span class="line">        contract = ib_insync.Stock(symbol.upper(), <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">        self.client.qualifyContracts(contract)</span><br><span class="line">        <span class="keyword">if</span> quantity &gt;= <span class="number">0.0</span>:</span><br><span class="line">            order = ib_insync.MarketOrder(<span class="string">&#x27;BUY&#x27;</span>, quantity)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            order = ib_insync.MarketOrder(<span class="string">&#x27;SELL&#x27;</span>, -quantity)</span><br><span class="line">        trade = self.client.placeOrder(contract, order)</span><br><span class="line">        self.client.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_last_price_from_quote</span>(<span class="params">self, symbol:str</span>):</span></span><br><span class="line">        contract = ib_insync.Stock(symbol.upper(), <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">        <span class="comment"># self.client.reqMarketDataType(3)</span></span><br><span class="line">        self.client.reqMarketDataType(<span class="number">3</span>)</span><br><span class="line">        self.client.qualifyContracts(contract)</span><br><span class="line">        quote = self.client.reqMktData(</span><br><span class="line">            contract,</span><br><span class="line">            genericTickList=<span class="string">&quot;&quot;</span>,</span><br><span class="line">            snapshot=<span class="literal">True</span>,</span><br><span class="line">            regulatorySnapshot=<span class="literal">False</span>,</span><br><span class="line">            mktDataOptions=<span class="literal">None</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> math.isnan(quote.last):</span><br><span class="line">                self.client.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> quote.last</span><br><span class="line">        print(<span class="string">f&#x27;No last price in quote for <span class="subst">&#123;symbol&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__order_status</span>(<span class="params">self, trade</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Call back function for checking order status</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="string">f&#x27;Order [<span class="subst">&#123;trade.contract.symbol&#125;</span>] status updated: <span class="subst">&#123;trade.orderStatus.status&#125;</span>&#x27;</span>)</span><br><span class="line">        match trade.orderStatus.status:</span><br><span class="line">            case <span class="string">&#x27;Filled&#x27;</span>:</span><br><span class="line">                print(<span class="string">f&#x27;Order <span class="subst">&#123;trade.contract.symbol&#125;</span>, filled.&#x27;</span>)</span><br><span class="line">            case _:</span><br><span class="line">                print(<span class="string">f&#x27;Others order status: <span class="subst">&#123;trade.orderStatus.status&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_market_open</span>(<span class="params">self, offset_days=<span class="number">0</span></span>):</span></span><br><span class="line">        spy_contract = ib_insync.Stock(<span class="string">&#x27;SPY&#x27;</span>, <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">        self.client.qualifyContracts(spy_contract)</span><br><span class="line">        trading_days = self.client.reqContractDetails(spy_contract)[<span class="number">0</span>].liquidHours</span><br><span class="line">        trading_days_dict = &#123;d.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>]:d.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>] <span class="keyword">for</span> d <span class="keyword">in</span> trading_days.split(<span class="string">&#x27;;&#x27;</span>)&#125;</span><br><span class="line">        today_str = (datetime.now().astimezone(self.timezone) + timedelta(days=offset_days)).strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> trading_days_dict.items():</span><br><span class="line">            <span class="keyword">if</span> (today_str <span class="keyword">in</span> k) <span class="keyword">and</span> (v == <span class="string">&#x27;CLOSED&#x27;</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_market_open_now</span>(<span class="params">self</span>):</span></span><br><span class="line">        spy_contract = ib_insync.Stock(<span class="string">&#x27;SPY&#x27;</span>, <span class="string">&#x27;SMART&#x27;</span>, self.currency)</span><br><span class="line">        self.client.qualifyContracts(spy_contract)</span><br><span class="line">        trading_days = self.client.reqContractDetails(spy_contract)[<span class="number">0</span>].liquidHours</span><br><span class="line">        trading_days_list = [d.split(<span class="string">&#x27;-&#x27;</span>) <span class="keyword">for</span> d <span class="keyword">in</span> trading_days.split(<span class="string">&#x27;;&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">        day_str = datetime.now().astimezone(self.timezone).strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">        time_str = datetime.now().astimezone(self.timezone).strftime(<span class="string">&#x27;%H%M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> trading_days_list:</span><br><span class="line">            <span class="keyword">if</span> len(d) &gt; <span class="number">1</span> <span class="keyword">and</span> day_str <span class="keyword">in</span> d[<span class="number">0</span>].split()[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> time_str &gt; d[<span class="number">0</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>] <span class="keyword">and</span> time_str &lt; d[<span class="number">1</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_transactions</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main function</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    broker = InteractiveBrokerTradeAPI()</span><br><span class="line">    print(datetime.now().strftime(<span class="string">&#x27;Now is %Y-%m-%d&#x27;</span>))</span><br><span class="line">    <span class="keyword">with</span> broker.connect() <span class="keyword">as</span> c:</span><br><span class="line">        accounts, positions, orders = c.get_account_detail()</span><br><span class="line">        print(ib_insync.util.df(accounts))</span><br><span class="line">        print(ib_insync.util.df(positions))</span><br><span class="line">        print(ib_insync.util.df(orders))</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">        market_open = c.is_market_open()</span><br><span class="line">        market_open_now = c.is_market_open_now()</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;market_open=&#125;</span>&#x27;</span>)</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;market_open_now=&#125;</span>&#x27;</span>)</span><br><span class="line">        print(<span class="string">&quot;=&quot;</span>*<span class="number">30</span>)</span><br><span class="line">        print(c.get_last_price_from_quote(<span class="string">&#x27;SSO&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> market_open <span class="keyword">and</span> market_open_now:</span><br><span class="line">            last = c.get_last_price_from_quote(<span class="string">&#x27;AAPL&#x27;</span>)</span><br><span class="line">            print(<span class="string">f&#x27;<span class="subst">&#123;last=&#125;</span>&#x27;</span>)</span><br><span class="line">            c.place_order(<span class="string">&#x27;AAPL&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>And here’s the output.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Output</span></span><br><span class="line">Now <span class="keyword">is</span> <span class="number">2022</span><span class="number">-12</span><span class="number">-14</span></span><br><span class="line">==============================</span><br><span class="line">Connection established</span><br><span class="line">==============================</span><br><span class="line">     account      cash  total_assets</span><br><span class="line"><span class="number">0</span>  DU4399668  <span class="number">2118.598</span>     <span class="number">99946.918</span></span><br><span class="line">  code     qty  cost_price  market_val   pl_val  pl_ratio</span><br><span class="line"><span class="number">0</span>  SHV   <span class="number">427.0</span>  <span class="number">109.987048</span>    <span class="number">46970.03</span>     <span class="number">5.56</span>  <span class="number">0.000118</span></span><br><span class="line"><span class="number">1</span>  SSO  <span class="number">1019.0</span>   <span class="number">48.717576</span>    <span class="number">50858.29</span>  <span class="number">1215.08</span>  <span class="number">0.024476</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">==============================</span><br><span class="line">market_open=<span class="literal">True</span></span><br><span class="line">market_open_now=<span class="literal">True</span></span><br><span class="line">==============================</span><br><span class="line"><span class="number">49.94</span></span><br><span class="line">last=<span class="number">147.86</span></span><br><span class="line">Order [AAPL] status updated: PreSubmitted</span><br><span class="line">Others order status: PreSubmitted</span><br><span class="line">Order [AAPL] status updated: Filled</span><br><span class="line">Order AAPL, filled.</span><br><span class="line">==============================</span><br><span class="line">Connection closed</span><br><span class="line">==============================</span><br></pre></td></tr></table></figure><p>Voila! Now as long as we schedule the time for each function to run, we will have our automated trading script ready to run! It’s time for you to put on your creative hat and start improvising, adding your own magic to your trading script. See you next time.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/12/12/2022-12-16-IBKR-broker-2/cover.png&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;p&gt;This is the second part of the &lt;a href=&quot;https://mikelhsia.github.io/2022/12/12/2022-12-10-IBKR-Broker/&quot;&gt;&lt;strong&gt;Set Up Trading API Template In Python&lt;/strong&gt;&lt;/a&gt;. We’re going to focus on implementing the rest of the functions in our Interactive Broker class.&lt;/p&gt;</summary>
    
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/categories/How2/"/>
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/How2/Quantitative-Trading/"/>
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/tags/How2/"/>
    
    <category term="Python3" scheme="http://mikelhsia.github.io/tags/Python3/"/>
    
    <category term="Interactive Broker" scheme="http://mikelhsia.github.io/tags/Interactive-Broker/"/>
    
  </entry>
  
  <entry>
    <title>【How 2】Set Up Trading API Template In Python - Connecting My Trading Strategies To Interactive Brokers</title>
    <link href="http://mikelhsia.github.io/2022/12/07/2022-12-10-IBKR-Broker/"/>
    <id>http://mikelhsia.github.io/2022/12/07/2022-12-10-IBKR-Broker/</id>
    <published>2022-12-07T06:58:04.000Z</published>
    <updated>2022-12-15T07:05:45.857Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/12/07/2022-12-10-IBKR-Broker/cover.png" class="" width="800"><p>Building your trading strategy to connect to a broker with the broker’s proprietary API is always dreadful. There are tones of API documentation to read, tones of trial-and-error tests to conduct, and tones of unknown causes and bugs that fail your API test. In this post, I’m going to demonstrate my MVP API template to get my trading strategies to work, so that you can build your own in a way that makes your trading strategies work as well.</p><a id="more"></a><hr><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/">【Momentum Trading】A Defense Trading Strategy That Works - CPPI (Constant Proportion Portfolio Insurance)</a></li></ul><p>After completing the research CPPI investment strategy, I need to find a new broker with a new account to start trading. <a href="https://www.interactivebrokers.ca/en/trading/lp-why-ibkr.php?wid=978897570"><strong>Interactive Broker (IBKR)</strong></a> is the first broker that I am familiar with when I was a student, so I kinda have this obsession to make my trades through it. Years later, I consider myself finally had the luxury to sit down and spend time reading their API documentation. I’ve found the <a href="https://www.interactivebrokers.com/en/trading/api-guides.php">IBKR API</a> doesn’t support retrieving historical transaction data, for example, the orders you placed three days ago and the commissions you paid for each trade wouldn’t be stored anywhere in the IBKR server. However, I need this information to build my performance evaluation report. Therefore, I’ve decided to put it on hold until there’s a good enough solution to come to rescue me. Now, as my knowledge grows, I’ve figured it’s about time to tackle this task.</p><p><a href="https://www.interactivebrokers.ca/en/trading/lp-why-ibkr.php?wid=978897570"><strong>Interactive Broker (IBKR)</strong></a> is a renowned investment broker that has successfully operated its business across the world. It is also famous for its low trading fees in both the equity and the derivative markets. On the other hand, its proprietary API is notorious for being complicated enough to work with. I’m going to give you my two cents here and hopefully it’ll help people who would like to consider Interactive Broker as their market broker. Here are the things I’m going to talk about:</p><ul><li>IBKR TWS and IB gateway</li><li>IB gateway configurations</li><li>My MVP broker API template</li><li>Introduce ib_insync package and start connecting</li><li>Implement our first IBKR call</li></ul><h1 id="IBKR-TWS-and-IB-gateway"><a href="#IBKR-TWS-and-IB-gateway" class="headerlink" title="IBKR TWS and IB gateway"></a>IBKR TWS and IB gateway</h1><p>In order to connect to the broker’s API service, each broker provides different methods to do so. <a href="https://developer.tdameritrade.com/apis">TD Ameritrade API</a> allows you to use their API service remotely through the API token provided. <a href="https://openapi.futunn.com/futu-api-doc/en/">Futu OpenAPI</a> requires you to download extra software on your local PC/laptop, so that your API calls will be able to access their API service through this middleware. As for [IBKR API], it is similar to Futu OpenAPI that all the API calls are connected through its proprietary software to reach the API service.</p><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/cover.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>How does your API call reach the IBKR API service</i></p><p>Interactive broker provides two software applications to help you connect to their API service:</p><p><strong>TWS</strong><br>TWS stands for Trader Workstation. TWS is designed for trades who would like to conduct a series of research and trade equity and derivatives across many markets in one unified platform. Users can read the latest news, study company fundamentals and annual reports, research the stock trend or patterns, and even place orders with it. Also, it embeds the capability of being an intermediary between your desktop/laptop and the IBKR API service.<br><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/tws.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>IBKR TWS Trading Station</i></p><p><strong>IB gateway</strong><br>Compared to TWS, IB gateway is simply an API gateway without all the User Interface that you can see in the TWS. You can’t buy or sell or do anything with the IB gateway. It allows you to connect to the IBKR API service and nothing more. In general, it is a super lightweight TWS that will consume much less of your desktop/laptop memories and resources.<br><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/ib_gateway.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>IBKR IB Gateway</i></p><p>These two software applications have similar configurations but hold separate parameters which they don’t share mutually. Now let’s take a look at the configurations that will concern us before we start programming our API connection to IBKR.</p><h1 id="IB-gateway-configurations"><a href="#IB-gateway-configurations" class="headerlink" title="IB gateway configurations"></a>IB gateway configurations</h1><p>Let’s use IB gateway as an example so that we don’t get distracted by the various features that TWS offers. First of all, we need to log in to the IB gateway software application. I don’t want to mess around with my real money while testing my trading script, I would instead use a paper account. <em>(Tip: You can reset your paper account on your account management page every day.)</em></p><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/login.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Login to your paper account</i></p><p>Here is a few configurations that you need to pay attention to before starting to code:</p><ol><li>In API -&gt; Setting, uncheck the <em>“Read-Only API”</em>.</li><li>In API -&gt; Setting, remember or configure the <em>“Socket port”</em> because you will need it when connecting to this software.</li><li>In API -&gt; Precautions, check the box <em>“Bypass Order Precaution for API Order”</em> to prevent additional errors or warning dialog boxes popped up when you place orders through API.</li><li>If you’re using TWS as your middleman service, you need to check one more box <em>“Enable ActiveX and Socket Client”</em>.</li></ol><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/api_configuration.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>API configuration</i></p><img data-src="/2022/12/07/2022-12-10-IBKR-Broker/api_configuration2.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>API configuration 2</i></p><p>Now we’re all set. Let’s get down to the business.</p><h1 id="My-MVP-broker-API-template"><a href="#My-MVP-broker-API-template" class="headerlink" title="My MVP broker API template"></a>My MVP broker API template</h1><p>There are a few actions required in your trading strategies in order to run the basic buy/sell operations properly:</p><ol><li>Connect to and disconnect from the dedicated broker API service.</li><li>Get your basic account info in order to know the account status such as <code>Total asset value</code>, <code>Remaining cash balance</code>, <code>Purchasing power</code>, … and so on.</li><li>Check the trading calendar and trading hours to see whether the market is open for trading or if it’s a holiday today.</li><li>Check the current quote price of a specific symbol in order to know how many shares we would purchase.</li><li>Place orders through the broker API.</li><li>Get the transaction history for performance evaluation later on.</li></ol><p>I use the <a href="https://docs.python.org/3/library/abc.html">python package <code>abc</code></a> (abbreviation for <strong>Abstract Base Class</strong>) to build my base API template. The most obvious advantage of building a baseclass with an abstract base class is that you can easily extend from it to build another class. For example, you have a class called <strong>InteractiveBrokerClass</strong> to make trades, and another class called <strong>TDAmeritradeBrokerClass</strong> to make trades with <a href="https://www.tdameritrade.com/">TD Ameritrade</a>. Both broker classes do similar things and require similar functions. Implementing them using as abstract base class would make your life easier in terms of managing the actions in both derived classes. Here’s my broker base class:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TradeAPI.py</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractTradeInterface</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_account_detail</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_last_price_from_quote</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">place_order</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_market_open</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_market_open_now</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_transactions</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Abstract Trading API Template</i></p><p>Implementing any of them could be straightforward and also could be extremely complex, depending on the design of the structure of the proprietary broker API. Like I said earlier that Interactive Broker didn’t support querying historic transactions/trades, we need to build alternative functions on the side in order to support the <code>def get_transactions(self)</code> in our base template. I’m not going to dive into how to build them now and we will come back to this in another post. I will start by looking at how we are going to connect to the IB gateway by implementing the <code>def connect()</code> function, and then we can check the quote price and place orders with API calls whenever we want to.</p><h1 id="Introduce-ib-insync-package-and-start-connecting"><a href="#Introduce-ib-insync-package-and-start-connecting" class="headerlink" title="Introduce ib_insync package and start connecting"></a>Introduce ib_insync package and start connecting</h1><p>Instead of using the native <code>ib_api</code> package to connect to the IBKR API service, I choose to use <a href="https://pypi.org/project/ib-insync/"><code>ib_insync</code></a> package developed by <strong><em>Ewald R. de Wit</em></strong>. <code>ib_insync</code> not only simplifies the way to connect and communicate with the IBKR API service, but it also adds the asynchronous capability so that less CPU time was wasted while requesting data from the server. Here is an introductory post to get you familiar with the functions provided in <code>ib_insync</code>: <a href="https://algotrading101.com/learn/ib_insync-interactive-brokers-api-guide/">ib_insync: Interactive Broker API guide</a>. We can clearly learn that we can connect to the IBKR API service with the following code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ib = IB()</span><br><span class="line">ib.connect(</span><br><span class="line">  host=<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment"># local host IP</span></span><br><span class="line">  port=<span class="number">4002</span>, <span class="comment"># The port that we configured in the IB gateway</span></span><br><span class="line">  clientId=<span class="number">1</span> <span class="comment"># The non-duplicated client ID for each connection</span></span><br><span class="line">)</span><br><span class="line">ib.disconnect() <span class="comment"># To disconnect from the server</span></span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>You would need to connect to server before you make any request</i></p><p>This established connection <code>ib</code> was handled and maintained by whoever initiated it. In order to better and easier to handle the connection and close it effectively once we finished using it, I would suggest using <a href="https://docs.python.org/3/library/contextlib.html"><code>contextmanager</code></a> so that the context manager will close the connection once we finished using it. We don’t have to explicitly disconnect from the API service. Instead, the context manager will handle it every time when the <code>with</code> clause is finished.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">  self.client = ib_insync.IB()</span><br><span class="line">  self.client.connect(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">4002</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">yield</span> self <span class="comment"># Return the self instance</span></span><br><span class="line"></span><br><span class="line">  self.client.disconnect()</span><br><span class="line">  self.client.sleep(<span class="number">2</span>)  <span class="comment"># make sure the connection is closed before next time you connect to IBKR API service</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  <span class="keyword">with</span> broker.connect() <span class="keyword">as</span> c:</span><br><span class="line">    <span class="comment"># Make requests to the server</span></span><br><span class="line">  <span class="comment"># The connections will be closed since we disconnect from the server after `yield self`</span></span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Connect function implemented with context manager</i></p><h1 id="Implement-our-first-IBKR-call"><a href="#Implement-our-first-IBKR-call" class="headerlink" title="Implement our first IBKR call"></a>Implement our first IBKR call</h1><p>In the last part of this post, let’s try to implement <code>get_account_detail()</code> call in our broker class so that we could learn the account status.</p><p>In the original <a href="https://ib-insync.readthedocs.io/api.html">ib_insync document</a>, I found out that <code>ib.managedAccounts()</code> can retrieve a list of account names, and <code>ib.accountValues(account:str)</code> can retrieve all stats under this account parameter. Hence, I’m going to:</p><ol><li>First, use <code>ib.managedAccounts()</code> to retrieve all the accounts created.</li><li>Use <code>ib.accountValues()</code> to get all variables related to this account.</li><li>Extract the <code>TotalCashBalance</code> and <code>StockMarketValue</code> concerned USD so that I could tell how much money I have in cash and as well the total value under my account.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="keyword">import</span> ib_insync</span><br><span class="line"><span class="keyword">from</span> zoneinfo <span class="keyword">import</span> ZoneInfo</span><br><span class="line"><span class="keyword">from</span> modules.broker.TradeAPI <span class="keyword">import</span> AbstractTradeInterfac</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InteractiveBrokerTradeAPI</span>(<span class="params">AbstractTradeInterface</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,currency=<span class="string">&#x27;USD&#x27;</span></span>):</span></span><br><span class="line">        self.client = <span class="literal">None</span></span><br><span class="line">        self.accounts = []</span><br><span class="line">        self.currency = currency</span><br><span class="line"></span><br><span class="line"><span class="meta">    @contextmanager</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.client = ib_insync.IB()</span><br><span class="line">        self.client.connect(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">4002</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> self</span><br><span class="line"></span><br><span class="line">        self.client.disconnect()</span><br><span class="line">        self.client.sleep(<span class="number">2</span>)  <span class="comment"># make sure the connection is closed before next time you connect to IBKR API service</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_account_detail</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.accounts = self.client.managedAccounts()</span><br><span class="line"></span><br><span class="line">        acc_data = []</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> self.accounts:</span><br><span class="line">            acc = &#123;&#125;</span><br><span class="line">            acc[<span class="string">&#x27;account&#x27;</span>] = account</span><br><span class="line">            data = self.client.accountValues(account)</span><br><span class="line">            acc[<span class="string">&#x27;cash&#x27;</span>] = <span class="number">0</span></span><br><span class="line">            acc[<span class="string">&#x27;total_assets&#x27;</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">if</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;TotalCashBalance&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                    acc[<span class="string">&#x27;cash&#x27;</span>] = row.value</span><br><span class="line">                    acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">                <span class="keyword">elif</span> row.tag <span class="keyword">in</span> [<span class="string">&#x27;StockMarketValue&#x27;</span>] <span class="keyword">and</span> row.currency == self.currency:</span><br><span class="line">                    acc[<span class="string">&#x27;total_assets&#x27;</span>] += float(row.value)</span><br><span class="line">            acc_data.append(acc)</span><br><span class="line">        <span class="keyword">return</span> acc_data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_last_price_from_quote</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">place_order</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_market_open</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_market_open_now</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_transactions</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main function</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    broker = InteractiveBrokerTradeAPI()</span><br><span class="line">    <span class="keyword">with</span> broker.connect() <span class="keyword">as</span> c:</span><br><span class="line">        accounts = c.get_account_detail()</span><br><span class="line">        print(accounts)</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Full code</i></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Output</span></span><br><span class="line">&gt;&gt; [&#123;<span class="string">&#x27;account&#x27;</span>: <span class="string">&#x27;DU4399668&#x27;</span>, <span class="string">&#x27;cash&#x27;</span>: <span class="string">&#x27;77.44&#x27;</span>, <span class="string">&#x27;total_assets&#x27;</span>: <span class="number">96737.42</span>&#125;]</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Account status output</i></p><p><em>Noted: Make sure you attach the rest of the unimplemented functions as I did, as this is required in an abstract class. Otherwise, you will see the following error message when you run the test code.</em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/michael/quantitative-strategy/app/trading/test.py&quot;</span>, line <span class="number">86</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    broker = InteractiveBrokerTradeAPI(version_param=SCRIPT_VERSION)</span><br><span class="line">TypeError: Can<span class="string">&#x27;t instantiate abstract class InteractiveBrokerTradeAPI with abstract methods get_last_price_from_quote, get_transactions, is_market_open, is_market_open_now, place_order</span></span><br></pre></td></tr></table></figure></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>You need to implement all defined functions in the base class</i></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Done! We’re not officially connecting our trading script to the Interactive Broker API service. To make sure this broker class can fully support the functionalities of your trading program, there are still more functions to be implemented. Don’t worry, I’ll see you next time.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/12/07/2022-12-10-IBKR-Broker/cover.png&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;p&gt;Building your trading strategy to connect to a broker with the broker’s proprietary API is always dreadful. There are tones of API documentation to read, tones of trial-and-error tests to conduct, and tones of unknown causes and bugs that fail your API test. In this post, I’m going to demonstrate my MVP API template to get my trading strategies to work, so that you can build your own in a way that makes your trading strategies work as well.&lt;/p&gt;</summary>
    
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/categories/How2/"/>
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/How2/Quantitative-Trading/"/>
    
    
    <category term="How2" scheme="http://mikelhsia.github.io/tags/How2/"/>
    
    <category term="Python3" scheme="http://mikelhsia.github.io/tags/Python3/"/>
    
    <category term="Interactive Broker" scheme="http://mikelhsia.github.io/tags/Interactive-Broker/"/>
    
  </entry>
  
  <entry>
    <title>【Momentum Trading】A Defense Trading Strategy That Works - CPPI (Constant Proportion Portfolio Insurance)</title>
    <link href="http://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/"/>
    <id>http://mikelhsia.github.io/2022/11/04/2022-11-10-advanced-cppi-strategy/</id>
    <published>2022-11-03T17:04:25.000Z</published>
    <updated>2022-12-12T03:37:33.065Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/cover.jpg" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Photo by <a href='https://medium.com/r?url=https%3A%2F%2Funsplash.com%2F%40sasun1990%3Futm_source%3Dmedium%26utm_medium%3Dreferral'>Sasun Bughdaryan</a> on <a href='https://unsplash.com/?utm_source=medium&utm_medium=referral'>Unsplash</a></i></p><p>We’ve been talking too much about the attack side of quantitative trading, such as momentum, mean reversion, and ML. These strategies aim to outperform the benchmark/index by adding your personal points of view to the trading strategies. Beating the benchmark becomes the only goal when playing the offense. What about defense? After reading <a href="https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/">Introduction to CPPI – Constant Proportion Portfolio Insurance</a>, I started to feel that I can’t agree more with the idea of “The best defense is a good offense” once said by Sun Tzu, a Chinese military general, a strategist, and a philosopher. What does defense mean in the field of quantitative trading? Does defense mean we strive not to lose money and then nothing else worth doing? Maybe talking about the CPPI strategy would give us a better picture of what actually defense means to the traders. Let’s now have a look at how to approach the other side of trading.</p><a id="more"></a><hr><blockquote><p>If you enjoy reading this and my other articles, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote><hr><h1 id="What-does-it-mean-by-playing-defense-in-trading"><a href="#What-does-it-mean-by-playing-defense-in-trading" class="headerlink" title="What does it mean by playing defense in trading?"></a>What does it mean by playing defense in trading?</h1><p>When talking about quantitative strategy, they all come down to this advanced CAPM formula and use it to categorize different trading strategies. $\beta$ in this formula stands for the sensitivity of your portfolio against the movement of the market return and $\alpha$ stands for the excessive market return that can’t be captured by the $\beta$ term. For example, if the current risk-free rate is 1%, and the market return is 4% with 0 in $\alpha$, then you can calculate that your expected return would be $2*(4\%-1\%) + 1\% = 7\%$ if the $\beta$ equals to 2, or 10% if the $\beta$ equals 3.</p><script type="math/tex; mode=display">Return_{Expected} = Return_{riskfree} + \beta \times (Return_{market} - Return_{riskfree}) + \alpha</script><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Advanced CAPM model by <a href='https://www.investopedia.com/terms/j/jensensmeasure.asp'>Jensen</a></i></p><p>The $\beta$ here is essentially the <strong>exposure</strong> of our portfolio against market fluctuation. The idea of playing defense in trading is to reduce the exposure against the market so that you will lose less money than other people in the bear market. There are ways to reduce market exposure, such as market-neutral strategy, portfolio diversification, hedging, and many other methods that help reduce your market exposure and $\beta$ of your portfolio. However, reducing $\beta$ could also harm your profit when the overall market goes up because you have a smaller $\beta$. This is what happens when you play defense in trading.</p><h1 id="What-is-CPPI-Constant-Proportion-Portfolio-Insurance-strategy"><a href="#What-is-CPPI-Constant-Proportion-Portfolio-Insurance-strategy" class="headerlink" title="What is CPPI (Constant Proportion Portfolio Insurance) strategy?"></a>What is CPPI (Constant Proportion Portfolio Insurance) strategy?</h1><p>CPPI (Constant Proportion Portfolio Insurance) strategy achieves the goal of reducing risk exposure by adding a risk-free asset such as a 3-month treasury into your portfolio, which can be considered as a type of <em>portfolio diversification</em>. Short-term treasury usually has very little risk exposure against the market. You can see below the close price movement of SHV, SHY, TLT, and IEF compare to the movement of SPY close price.</p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/riskfree.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Which asset is worth being picked as a risk-free asset? As SHY and SHV are short-term Treasury ETFs, and TLT and IEF are long-term Treasury ETF</i></p><p>On top of adding a risk-free asset into the portfolio, the CPPI strategy proposes concepts named <strong><em>Floor</em></strong> and <strong><em>Cushion</em></strong>. <strong><em>Floor</em></strong> would be the minimum asset value that you want to protect from loss, and the <strong><em>Cushion</em></strong> is the asset value that you would like to invest in riskier assets in order to gain an additional return. CPPI strategy allows investors to keep the potential chances of profiting, and limiting the downside risk by scaling the ratios of the floor and cushion dynamically. I’m listing the related formulas below for reference. For more details, go take a look at the <a href="https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/">article</a> in <a href="https://quantpedia.com">QuantPedia</a>.</p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/intro-to-CPPI.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Extracted from <a href='https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/'>Introduction to CPPI – Constant Proportion Portfolio Insurance</a></i></p><h1 id="Disadvantages-when-applying-CPPI-strategies"><a href="#Disadvantages-when-applying-CPPI-strategies" class="headerlink" title="Disadvantages when applying CPPI strategies"></a>Disadvantages when applying CPPI strategies</h1><p>After conducting a series of backtesting against the proposed strategies in the <a href="https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/">article</a>, I’ve found the strategies are less promising and less satisfying than I originally expected. Here are a few things I discovered:</p><h2 id="Floor-level-is-fixed-even-if-the-total-asset-value-go-rocket-high"><a href="#Floor-level-is-fixed-even-if-the-total-asset-value-go-rocket-high" class="headerlink" title="Floor level is fixed even if the total asset value go rocket high"></a>Floor level is fixed even if the total asset value go rocket high</h2><ul><li>In <strong>Basic CPPI</strong> strategy: I approached this strategy by setting a fixed percentage (80%) of the original asset that I want to protect from the beginning. This means, for example, I have \$100,000 as my start-up fund, and I want to protect 80% value of my fund. Then I’ll have \$80,000 as my floor level.</li><li>Even though we have the minimum asset value protected, the floor value stays the same throughout the entire backtesting period. This also means that there is a big chunk of the asset not protected when the portfolio grows a certain amount. That’s the reason why we suffer a huge drop at the beginning of 2022.</li></ul><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/basic_cppi.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Basic CPPI: Max Drawdown: 59.3%, Annual Variance: 0.069</i></p><h2 id="The-value-floor-trench"><a href="#The-value-floor-trench" class="headerlink" title="The value floor trench"></a>The value floor trench</h2><ul><li>In <strong>New High CPPI</strong> Strategy: Applying <em>New High CPPI strategy</em> will update the floor when the total portfolio value reaches a new high and the floor value accordingly. Therefore, our increasingly growing floor will help us protect more value when there’s higher value in our portfolio.</li><li>There’s one scenario that could cause this strategy less effective. When your portfolio value grows substantially, your floor value also increased along the way and reached a skyrocket-high number. What if one day the market crashed and the portfolio value dropped way below the floor value, you’ll then need to invest 100% of your asset into bonds/treasuries by the definition of the New High CPPI strategy. It’d take months or even years for the portfolio to recover to above the floor level. By looking at the backtesting result below, we miss the fantastic opportunity to grow our portfolio back to where it was and <em>fall into a floor trench</em>.</li></ul><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/newhigh_cppi.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>New High CPPI ex1: Invest nearly 100% in bonds/treasuries after 2020</i></p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/newhigh_cppi_2.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>New High CPPI ex2: Investment loss will take a long time to recover back to floor level</i></p><h1 id="Let’s-add-some-spices-to-make-the-strategy-promising"><a href="#Let’s-add-some-spices-to-make-the-strategy-promising" class="headerlink" title="Let’s add some spices to make the strategy promising"></a>Let’s add some spices to make the strategy promising</h1><p>Since now we know the basics and pros and cons of the CPPI strategy, let’s add some spice to this strategy to make it more appealing so that traders like you will be more than willing to invest.</p><h2 id="Change-the-meat"><a href="#Change-the-meat" class="headerlink" title="Change the meat"></a>Change the meat</h2><p>As we all know the CPPI strategy can preserve the upward potential and limit the downward loss to a certain degree, why don’t we use the 2x SPY ETF to replace the SPY ETF to gain more upward space? Therefore,</p><ul><li>Risky asset<ul><li>We use <code>SSO</code> which is a <code>2x SPY</code> ETF so that we can exploit the high upward growth possibility.</li></ul></li><li>Risk-free asset<ul><li>We use <code>SHV</code> as it seems to be the more stable among the four risk-free assets we mentioned earlier in this post.</li></ul></li><li>Benchmark<ul><li>We still use <code>SPY</code> to be our benchmark</li></ul></li></ul><h2 id="Add-seasoning"><a href="#Add-seasoning" class="headerlink" title="Add seasoning"></a>Add seasoning</h2><p>As proposed in the article <a href="https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/">Introduction to CPPI – Constant Proportion Portfolio Insurance</a>, we can apply the dynamic multiplier method so that we get to use different multipliers depending on the market volatility instead of picking a fixed number throughout the backtesting period.</p><ul><li>Fixed multiplier<ul><li>We make the multiplier equal to 3 at all times.</li></ul></li><li>Dynamic multiplier<ul><li>We set a few indicators to categorize the regimes of current market volatility<ul><li>$EMA_{21d}$: Exponential moving average of close price in past 21 days</li><li>$SMA_{63d}$: Simple moving average of close price in the past 63 days</li><li>$\overline{EMA_{21d}}$: 126 days average of $EMA_{21d}$</li><li>$\overline{SMA_{63d}}$: 126 days average of $SMA_{63d}$<script type="math/tex; mode=display">\text{Dynamic multiplier} = \left\{\begin{array}\\  4 & \text{if } EMA_{21d} > \overline{EMA_{21d}} \text{ and } SMA_{63d} > \overline{SMA_{63d}} \\  2 & \text{if } EMA_{21d} < \overline{EMA_{21d}} \text{ and } SMA_{63d} < \overline{SMA_{63d}} \\  3 & \mbox{if others } \\\end{array}\right.</script></li></ul></li></ul></li></ul><h2 id="Additional-flavor-Smart-Floor"><a href="#Additional-flavor-Smart-Floor" class="headerlink" title="Additional flavor: Smart Floor"></a>Additional flavor: Smart Floor</h2><p>An idea struck me when I was working on backtesting the scenarios from the article: what if we can build a somewhat flexible/intelligent mechanism that can adjust the floor level based on historic values? The whole process of calculating the floor value has reminded me the process of using <strong>Gradient Descent</strong> to approach the local optima. If you are not familiar with the idea of <strong>Gradient Descent</strong>, check this video out, and it will give you a general idea of what it is and what it is for.</p><p><iframe src="//player.bilibili.com/player.html?aid=678849381&bvid=BV1Mm4y1Z7C4&cid=501387405&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Gradient Descent, Step-by-Step by <a href='https://www.youtube.com/c/joshstarmer'>StatQuest</a></i></p><p>Therefore by borrowing the main idea from the Gradient Descent, we can update our floor value based on the difference between the current total asset value and the total asset value from the previous period. We multiply this difference with the learning rate $\alpha$ and add it to the previous total asset value. Then the base value used for calculating the floor level is now one step closer to the current total asset value. Here’s what the formula looks like:</p><script type="math/tex; mode=display">\begin{align}\text{diff} &= \text{Current AV} - \text{Previous AV}\\\text{Updated Base Value} &= \text{Previous AV} + \text{diff} * \alpha\\\text{Smart Floor} &= \text{Updated Base Value} * \text{Floor Percentage}\\\end{align}</script><script type="math/tex; mode=display">where</script><script type="math/tex; mode=display">AV = \text{Asset Value}</script><script type="math/tex; mode=display">\alpha = \text{Learning Rate}</script><p>To mitigate the impact of trading fee charges, you can also add a buffer when updating the <em>Base Value</em> to make sure you don’t update it too frequently, causing unnecessary loss on the trading fee.</p><h1 id="Backtesting-and-result"><a href="#Backtesting-and-result" class="headerlink" title="Backtesting and result"></a>Backtesting and result</h1><p>Now we have three ways to update our floor value: <code>basic floor</code>, <code>new high floor</code>, <code>smart floor</code>, and two ways to decide our multiplier: <code>fixed multiplier</code> and <code>dynamic multiplier</code>. Including the <code>buy and hold</code> strategy as the benchmark, let’s mashup these conditions and start conducting backtest against each of the scenarios.</p><h2 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h2><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h2 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h2><ul><li>Using <code>SPY</code> as the portfolio benchmark</li><li><code>SHV</code> as risk-free asset</li><li><code>SSO</code> as the risky asset</li></ul><h2 id="Rebalancing-strategy"><a href="#Rebalancing-strategy" class="headerlink" title="Rebalancing strategy"></a>Rebalancing strategy</h2><p>We update the CPPI and floor value every week, and then we adjust the proportion of risky and risk-free assets accordingly.</p><h2 id="Backtest-time-frame"><a href="#Backtest-time-frame" class="headerlink" title="Backtest time frame"></a>Backtest time frame</h2><p>Three time periods we’re going to test against with:</p><ol><li>Full period: <em>2010, 1, 1 - 2022, 11, 1</em><ul><li>To backtest the complete period and evaluate the overall performance</li></ul></li><li>Bear market period: <em>2007, 1, 1 - 2012, 1, 1</em><ul><li>To backtest the bear market scenario and evaluate accordingly</li></ul></li><li>Bull market period: <em>2015, 1, 1 - 2019, 1, 1</em><ul><li>To backtest the slow bull market and evaluate its performance</li></ul></li></ol><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/backtest_period.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Benchmark backtest full period: 2010/01/01 - 2022/11/01</i></p><h2 id="Execution-and-backtest"><a href="#Execution-and-backtest" class="headerlink" title="Execution and backtest"></a>Execution and backtest</h2><p>Here we go!</p><h3 id="Scenarios"><a href="#Scenarios" class="headerlink" title="Scenarios"></a>Scenarios</h3><p>We’re going to run the following backtest scenarios against three time periods:</p><ul><li>SPY, Buy-and-hold</li><li>SSO, Buy-and-hold</li><li>SSO, Basic floor, Fixed Multiplier</li><li>SSO, Basic floor, Dynamic Multiplier</li><li>SSO, Newhigh floor, Fixed Multiplier</li><li>SSO, Newhigh floor, Dynamic Multiplier</li><li>SSO, Learning floor, Fixed Multiplier</li><li>SSO, Learning floor, Dynamic Multiplier</li></ul><h3 id="Backtesting-results"><a href="#Backtesting-results" class="headerlink" title="Backtesting results"></a>Backtesting results</h3><h4 id="Full-period"><a href="#Full-period" class="headerlink" title="Full period"></a>Full period</h4><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/fulltime_backtest.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Backtest full period: 2010/01/01 - 2022/11/01</i></p><p>The backtest results on the right-hand side have the highest max drawdown 59.3% among all scenarios. We can see that the scenarios <code>SSO, Learning floor, Fixed Multiplier</code> and <code>SSO, Learning floor, Dynamic Multiplier</code> both have similar annual returns as the <code>SPY benchmark</code> scenario, but have lower and better MMD and variance. At the first glance, the <code>Smart (learning) floor</code> seems to have a great capability to keep to upward potential and limit the downward risks. Now let’s look at the other two scenarios.</p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/fulltime_chart.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Scatter chart of full period: 2010/01/01 - 2022/11/01</i></p><h4 id="Bear-market-period"><a href="#Bear-market-period" class="headerlink" title="Bear market period"></a>Bear market period</h4><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/bear_backtest.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Backtest bear period: 2007/01/01 - 2012/01/01</i></p><p>It’s very obvious that the scenario <code>SSO, Learning floor, Fixed Multiplier</code> and <code>SSO, Learning floor, Dynamic Multiplier</code> has the highest returns among all the backtests including the benchmark buy-and-hold backtest. The Sharpe ratio, MDD, and annual variance of these two scenarios are also improved compared to the benchmark scenario. Seems <code>CPPI with learning floor</code> does have the capability to limit the downward loss.</p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/bear_chart.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Scatter chart of bear period: 2007/01/01 - 2012/01/01</i></p><h4 id="Bull-market-period"><a href="#Bull-market-period" class="headerlink" title="Bull market period"></a>Bull market period</h4><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/bull_backtest.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Backtest bull period: 2015/01/01 - 2019/01/01</i></p><p>The distribution of the backtests looks similar to the full-time period chart. The three right-most scenarios <code>SSO-buy-and-hold</code>, <code>SSO-basic-fixed</code>, and <code>SSO-basic-dynamic</code> have the highest MDD, which is the outcome that we’re trying to avoid from the beginning. In the meantime, the scenario <code>SSO, Learning floor, Fixed Multiplier</code> and <code>SSO, Learning floor, Dynamic Multiplier</code> still outperform the other scenarios in terms of overall returns and MDD.</p><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/bull_chart.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Scatter chart of bull period: 2015/01/01 - 2019/01/01</i></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Here’s my report card of my winning candidate strategy: <code>SSO, learning floor, fixed multiplier</code>:<br><img data-src="/2022/11/04/2022-11-10-advanced-cppi-strategy/my_winning_candidate.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>SSO; Smart Floor; Fixed multiplier</i></p><p>It seems that all the scenarios are able to limit their downside risk due to the fact that we added risk-free assets into our portfolio, achieving the goal to diversify the risk. Even though the returns are diluted, some of the scenarios still show promising outcomes by keeping proportional profit in the book (especially the scenarios using <code>Smart Floor</code>). As for the impact of whether adopting either dynamic multiplier or fixed multiplier is not yet significant, there would be more research needed to make a statistical decision on which method works better than the other.</p><hr><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/">Introduction to CPPI – Constant Proportion Portfolio Insurance</a></li><li><a href="https://wiki.mbalib.com/wiki/%E5%9B%BA%E5%AE%9A%E6%AF%94%E4%BE%8B%E6%8A%95%E8%B5%84%E7%BB%84%E5%90%88%E4%BF%9D%E9%99%A9%E7%AD%96%E7%95%A5">MBA Lib: Constant Proportion Portfolio Insurance Strategy</a></li><li><a href="http://www.scienpress.com/Upload/JFIA/Vol%207_3_2.pdf">Portfolio insurance strategies in a low interest rate environment: A simulation based study</a></li><li><a href="https://medium.com/swlh/protect-your-portfolio-using-cppi-strategy-in-python-c3184c2b6767">If you can’t beat the market at least you can protect from it using Python</a></li></ul><h2 id="Backtest-code"><a href="#Backtest-code" class="headerlink" title="Backtest code"></a>Backtest code</h2><script src='https://www.quantconnect.com/terminal/backtest.js?sid=b67dea595ad0a269ac788f35379b8971'></script>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/11/04/2022-11-10-advanced-cppi-strategy/cover.jpg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
  &lt;i&gt;Photo by &lt;a href=&#39;https://medium.com/r?url=https%3A%2F%2Funsplash.com%2F%40sasun1990%3Futm_source%3Dmedium%26utm_medium%3Dreferral&#39;&gt;Sasun Bughdaryan&lt;/a&gt; on &lt;a href=&#39;https://unsplash.com/?utm_source=medium&amp;utm_medium=referral&#39;&gt;Unsplash&lt;/a&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;We’ve been talking too much about the attack side of quantitative trading, such as momentum, mean reversion, and ML. These strategies aim to outperform the benchmark/index by adding your personal points of view to the trading strategies. Beating the benchmark becomes the only goal when playing the offense. What about defense? After reading &lt;a href=&quot;https://quantpedia.com/introduction-to-cppi-constant-proportion-portfolio-insurance/&quot;&gt;Introduction to CPPI – Constant Proportion Portfolio Insurance&lt;/a&gt;, I started to feel that I can’t agree more with the idea of “The best defense is a good offense” once said by Sun Tzu, a Chinese military general, a strategist, and a philosopher. What does defense mean in the field of quantitative trading? Does defense mean we strive not to lose money and then nothing else worth doing? Maybe talking about the CPPI strategy would give us a better picture of what actually defense means to the traders. Let’s now have a look at how to approach the other side of trading.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Momentum" scheme="http://mikelhsia.github.io/tags/Momentum/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
    <category term="Fundamental Analysis" scheme="http://mikelhsia.github.io/tags/Fundamental-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>【Momentum Trading】Use machine learning to boost your day trading skill - meta-labeling</title>
    <link href="http://mikelhsia.github.io/2022/10/21/2022-10-15-meta-label/"/>
    <id>http://mikelhsia.github.io/2022/10/21/2022-10-15-meta-label/</id>
    <published>2022-10-21T06:59:59.000Z</published>
    <updated>2022-10-22T17:20:35.140Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/10/21/2022-10-15-meta-label/cover.jpeg" class="" width="600"><p>The Triple barrier method and meta-labeling technique were together introduced in the book <strong><em>Advances in Financial Machine Learning</em></strong> by <em>Marcos Lopez De Prado</em>. It seems that the combination of these two tools makes a great pair to either stabilize or further increase your portfolio growth. In this post, I’m going to quote my old research result (<a href="https://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/">here</a>) from last time as the fundamental strategy benchmark, and apply these two techniques to see what beneficial impact we could bring to this strategy.</p><a id="more"></a><p><strong><em>Previous researches</em></strong></p><ul><li><a href="https://mikelhsia.github.io/2022/03/18/2022-03-22-supertrend-indicator/">【Momentum Trading】Yes or No? Adopting the Supertrend indicator in your trading strategies?</a></li><li><a href="https://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/">【Momentum Trading】Four strategies of using RSI indicator to better time your market entry</a></li><li><a href="https://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/">【Momentum Trading】Optimize your MACD strategies with advanced indicators</a></li></ul><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>After researching the combination of several technical indicators as buy-in signals, I feel the research framework is missing a robust method to mitigate the subjective impact of the technical indicators. Theoretically speaking, stock prices and other statistics represent the current market overview. Using this information to predict future stock price movements would be irrational. However, standing from the behavioral finance point of view, the historic stock prices and statistics could be used to summarize the standard behavior of general investors’ actions when certain critical points were reached. That’s where the momentum trading strategy begins to thrive. Traders/Investors combine several effective indicators and define the fixed or dynamic threshold to find the group of stocks that possess the momentum (uptrend or downtrend) in them. Then the problem comes back to, how do we define the threshold in a more objective method.</p><p>In the book <strong><em>Advances in Financial Machine Learning</em></strong> by <em>Marcos Lopez De Prado</em>, the Triple barrier method <em>(Chapter 3.4)</em> and the meta-labeling technique <em>(Chapter 3.6)</em> were introduced with his quote <em>“In that case, meta-labeling will help us figure out when we should pursue or dismiss a discretionary PM’s call” (Page 54).</em> These two tools could be adopted and leverage the power of machine learning to mitigate the subjectiveness in the technical-indicator-oriented momentum strategy.</p><p>As usual, I’m not going to introduce these two ideas from ground zero. The article <a href="http://www.sefidian.com/2021/06/26/labeling-financial-data-for-machine-learning/"><em>What is Triple Barrier Method(TBM) and Meta-labeling</em></a> breaks down the definitions of these two terms and attaches the code snippet for easier comprehension. See below for you to understand what they are.</p><h2 id="The-definition-of-the-Triple-Barrier-Method-TBM"><a href="#The-definition-of-the-Triple-Barrier-Method-TBM" class="headerlink" title="The definition of the Triple Barrier Method (TBM)"></a>The definition of the Triple Barrier Method (TBM)</h2><p>TBM adopts two horizontal lines and one vertical line to form a box, which is used for deciding the next move depending on the relative position of the stock price inside the box. There are three potential scenarios would be produced:</p><ul><li>If the upper barrier (profit-take) is hit first. Label “buy” or “1”.</li><li>If the lower barrier (stop-loss) is hit first. Label “sell” or “-1”.</li><li>If the vertical barrier (expiration) is hit first. Label = “return in this period” or “0”.</li></ul><img data-src="/2022/10/21/2022-10-15-meta-label/triple_barrier.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Triple Barrier Method Scenario 3 - hitting the vertical barrier</i></p><img data-src="/2022/10/21/2022-10-15-meta-label/triple_barrier2.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Triple Barrier Method Scenario 1 - hitting the horizontal barrier</i></p><h2 id="The-definition-of-the-meta-Labeling"><a href="#The-definition-of-the-meta-Labeling" class="headerlink" title="The definition of the meta-Labeling"></a>The definition of the meta-Labeling</h2><p>The meta-Labeling sounds like simply an extra label, but it is actually a term that indicates a series of actions for getting the final prediction at the end. <a href="https://www.youtube.com/watch?v=ZCFmZFBtqsQ">This Youtube video</a> by <a href="https://hudsonthames.org/">Hudson &amp; Thames</a> successfully summarizes the core idea of Meta-labeling:</p><blockquote><p><em>Meta-labeling is a machine learning (ML) layer that sits on top of any base primary strategy to help size positions, filter out false-positive signals, and improve metrics such as the Sharpe ratio and maximum drawdown.</em></p></blockquote><p>The steps to implement the meta-labeling can be summarized in the followings:</p><ol><li>Build the primary fundamental model and get the fundamental prediction.</li><li>Use a fixed value to filter the prediction.</li><li>Combine the prediction into your <code>x_train</code> as your new training data.</li><li>Combine the prediction into your <code>y_train</code> to form the new <code>y_train</code> data.</li><li>Construct the secondary model, and use your new <code>x_train</code> and <code>y_train</code> to train your secondary model.</li><li>Feed your <code>test_data</code> into both your primary and secondary model, and produce the predictions respectively.</li><li>Combine the predictions of both the primary and secondary models in order to acquire your final prediction.</li></ol><img data-src="/2022/10/21/2022-10-15-meta-label/meta_label_process.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Meta-Labeling process</i></p><p>You might have questions right now as you just read my <a href="https://mikelhsia.github.io/2022/08/20/2022-08-20-votingclassifier/">previous post</a> and ask <em>“weren’t the Meta-labeling and the ensemble learning referring to the same thing?”</em> The fundamental difference between these two is that ensemble learning (especially the stacking method) solely adds its prediction into the original training set as a new feature. On the other hand, the meta-labeling not only adds its own prediction into the training set, but also modifies the <code>y_label</code> in the training set in accordance with the signal generation logic from the primary model. By having general ideas of what these two are, we can start strategizing how to achieve our goal from zero to one.</p><h1 id="Train-of-thought-from-zero-to-one"><a href="#Train-of-thought-from-zero-to-one" class="headerlink" title="Train of thought - from zero to one"></a>Train of thought - from zero to one</h1><p>To accomplish this backtest, I’ve summarized five steps below to give you a big picture of what we’re going to do:</p><ol><li>Construct our primary model and generate meta label using our primary model</li><li>Use our <strong>modified</strong> Triple-Barrier Method to generate training data for training our secondary model</li><li>Construct the secondary machine learning model</li><li>Train the secondary model</li><li>Execute and place orders with the combined signals.</li></ol><h2 id="1-Construct-our-primary-model"><a href="#1-Construct-our-primary-model" class="headerlink" title="1. Construct our primary model"></a>1. Construct our primary model</h2><p>First of all, we use the strategy left from <a href="https://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/">here</a> and use the buy/sell signals generated from it as the Meta-label. We used MACD, Awesome Oscillator, and RSI indicator to generate our trading (buy/sell) signals. Other than this, we also prepare the following factors for later use:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FEATURES = [</span><br><span class="line">  <span class="string">&#x27;_1d_rtn&#x27;</span>, <span class="string">&#x27;_3d_rtn&#x27;</span>, <span class="string">&#x27;_5d_rtn&#x27;</span>, <span class="string">&#x27;_10d_rtn&#x27;</span>, <span class="string">&#x27;_20d_rtn&#x27;</span>, <span class="string">&#x27;_60d_rtn&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;_1d_volume_change&#x27;</span>, <span class="string">&#x27;_3d_volume_change&#x27;</span>, <span class="string">&#x27;_5d_volume_change&#x27;</span>, <span class="string">&#x27;_10d_volume_change&#x27;</span>, <span class="string">&#x27;_20d_volume_change&#x27;</span>, <span class="string">&#x27;_60d_volume_change&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;_macd&#x27;</span>, <span class="string">&#x27;_macd_histo&#x27;</span>, <span class="string">&#x27;_macd_change_3&#x27;</span>, <span class="string">&#x27;_macd_change_5&#x27;</span>, <span class="string">&#x27;_macd_change_10&#x27;</span>, <span class="string">&#x27;_macd_change_15&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;_macd_signal_change_3&#x27;</span>, <span class="string">&#x27;_macd_signal_change_5&#x27;</span>, <span class="string">&#x27;_macd_signal_change_10&#x27;</span>, <span class="string">&#x27;_macd_signal_change_15&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;_macd_histo_change_3&#x27;</span>, <span class="string">&#x27;_macd_histo_change_5&#x27;</span>, <span class="string">&#x27;_macd_histo_change_10&#x27;</span>, <span class="string">&#x27;_macd_histo_change_15&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;_rsi&#x27;</span>, <span class="string">&#x27;_rsi_change_3&#x27;</span>, <span class="string">&#x27;_rsi_change_5&#x27;</span>, <span class="string">&#x27;_rsi_change_10&#x27;</span>, <span class="string">&#x27;_rsi_change_15&#x27;</span>, <span class="string">&#x27;_awesome_oscillator&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Factors to be used in the second machine learning model</i></p><h2 id="2-Modified-Triple-Barrier-Method"><a href="#2-Modified-Triple-Barrier-Method" class="headerlink" title="2. Modified Triple-Barrier Method"></a>2. Modified Triple-Barrier Method</h2><p>In the original Triple-Barrier Method, the difference between the first and second vertical barriers indicates the expiration time that is a fixed number. However, the sell signal generated from our primary model could happen before reaching the expiration time. Secondly, we’re not able to predict the exact time between the buy signal and sell signal as each stock would have its own cycle and price movement velocity. Therefore, we need to slightly twist the definition of <strong>expiration time</strong> in Triple-Barrier Method by defining different expiration times for each stock base on the time between the time of generating the buy signal and the time of generating the sell signal.</p><img data-src="/2022/10/21/2022-10-15-meta-label/modified_triple_barrier.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Modified Triple-Barrier Method using buy/sell signals to form a close period</i></p><p>Since we have defined the expiration time, then we need to resample the original training data into a usable and meaningful format. For example, if we have a time series data that includes ‘price’, ‘1d_rtn’, ‘3d_rtn’, ‘1d_vol’, and ‘3d_vol’ as follows:</p><img data-src="/2022/10/21/2022-10-15-meta-label/data_process_1.png" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Example data - 1</i></p><p>Once we have the original data, now let’s generate the buy and sell signal with it and attach the signals generated to its own row. You can easily mark the row that has one buy signal and one sell signal.<br><img data-src="/2022/10/21/2022-10-15-meta-label/data_process_2.png" class="" width="500"></p><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Example data - 2</i></p><p>Lastly, just as we will do when resampling the data, we keep all the factors in the row that has buy signal equal to <code>True</code>. We calculate return gain/loss between the buy and sell signals. Then we remove the column ‘price’, ‘buy signal’, and ‘sell signal’. In the end, we will have our training data that is used for training our secondary model.</p><img data-src="/2022/10/21/2022-10-15-meta-label/data_process_3.png" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Example data - 3</i></p><h2 id="3-Construct-our-secondary-machine-learning-model"><a href="#3-Construct-our-secondary-machine-learning-model" class="headerlink" title="3. Construct our secondary machine learning model"></a>3. Construct our secondary machine learning model</h2><p>Here I use the basic neural network machine learning model to predict the winning stocks. There are two hidden layers in the model. Second, we use <code>Leaky ReLU</code> as the activation function of the hidden layers as I want the negative values to be able to update our model weights instead of doing nothing. I found <a href="https://mlfromscratch.com/activation-functions-explained/#/">this post</a> very useful to understand the differences among various activation functions such as GELU, SELU, ELU, ReLU, and Leaky ReLU. Also, since it’s going to be a binary classification to predict whether the trades we made are profitable or not, we’re using <code>binary_crossentropy</code> as our loss function.</p><p>See below for the summary of my neural network setup:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.model = tf.keras.Sequential()</span><br><span class="line">self.model.add(tf.keras.layers.Dense(len(FEATURES), activation=tf.keras.layers.LeakyReLU(alpha=<span class="number">0.01</span>), input_shape=(len(FEATURES), ), name=<span class="string">&quot;dense_1&quot;</span>))</span><br><span class="line">self.model.add(tf.keras.layers.Dropout(<span class="number">0.1</span>),)</span><br><span class="line">self.model.add(tf.keras.layers.Dense(len(FEATURES), activation=tf.keras.layers.LeakyReLU(alpha=<span class="number">0.01</span>), name=<span class="string">&quot;dense_2&quot;</span>))</span><br><span class="line">self.model.add(tf.keras.layers.Dropout(<span class="number">0.1</span>)),</span><br><span class="line">self.model.add(tf.keras.layers.Dense(<span class="number">1</span>, activation=<span class="string">&quot;sigmoid&quot;</span>, name=<span class="string">&quot;predictions&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compile model</span></span><br><span class="line">self.model.compile(</span><br><span class="line">    optimizer=<span class="string">&#x27;Adam&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="4-Training-and-predicting"><a href="#4-Training-and-predicting" class="headerlink" title="4. Training and predicting"></a>4. Training and predicting</h2><p>Since having our training data and our secondary model ready in steps 2 and 3, we are now going to feed the data into our machine-learning model and start training. Before that, do remember that our data is raw and could have many outliers and missing data that could potentially contaminate the results of the prediction. Feature engineering is a must-take step. Here are a few things I did before throwing data into the black box:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrepareData</span>(<span class="params">self, data</span>):</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;Prepares the data for a format friendly for our model&#x27;&#x27;&#x27;</span></span><br><span class="line">  target_column = <span class="string">&#x27;rtn_bin&#x27;</span></span><br><span class="line">  data = self.__LabelYData(data, <span class="string">&#x27;_y_trade_rtn&#x27;</span>, target_column)</span><br><span class="line"></span><br><span class="line">  data_tmp = data.dropna()</span><br><span class="line"></span><br><span class="line">  X_train = data_tmp.loc[:, FEATURES]</span><br><span class="line">  y_train = (data_tmp.loc[:, target_column]).astype(int)</span><br><span class="line"></span><br><span class="line">  X_train = self.__WinsorizeCustom(X_train, FEATURES)</span><br><span class="line">  X_train = self.__LogCustom(X_train, LOGNORMAL_FEATURE)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> X_train, y_train</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__LabelYData</span>(<span class="params">self, df, source=<span class="string">&#x27;_y_trade_rtn&#x27;</span>, rtn_bin=<span class="string">&#x27;rtn_bin&#x27;</span></span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__WinsorizeCustom</span>(<span class="params">self, df, cols: list</span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__LogCustom</span>(<span class="params">self, df, cols: list</span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="4-1-Create-y-label-to-train-our-model"><a href="#4-1-Create-y-label-to-train-our-model" class="headerlink" title="4.1. Create y_label to train our model"></a>4.1. Create y_label to train our model</h3><p>We need our dependent variable, the so-called <code>y label</code>, to train our secondary machine learning model. There are various ways to achieve this. I pick the easiest method to create the <code>y label</code> by assigning <code>True</code> to the stock that its return is greater than <strong>3.0%</strong> after we sell it. You can pick other methods and see which better suits your scenarios and models.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__LabelYData</span>(<span class="params">self, df, source=<span class="string">&#x27;_y_trade_rtn&#x27;</span>, rtn_bin=<span class="string">&#x27;rtn_bin&#x27;</span></span>):</span></span><br><span class="line">  df[rtn_bin] = np.nan</span><br><span class="line"></span><br><span class="line">  df[rtn_bin] = df[source] &gt; <span class="number">0.03</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><h3 id="4-2-Winsorize-the-outliers"><a href="#4-2-Winsorize-the-outliers" class="headerlink" title="4.2. Winsorize the outliers"></a>4.2. Winsorize the outliers</h3><p>Winsorization is the process of replacing the values of outliers with the less impactful smaller values. Here in order to reduce the impact of extreme values, we use the 5 percentile value to replace the extremely small value, and use the 95 percentile value to replace the extremely large value.</p><img data-src="/2022/10/21/2022-10-15-meta-label/winsorize.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Winsorization</i></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__WinsorizeCustom</span>(<span class="params">self, df, cols: list</span>):</span></span><br><span class="line">  <span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">    quantiles = df.loc[:, col].quantile([<span class="number">0.05</span>, <span class="number">0.95</span>])</span><br><span class="line">    q_05 = quantiles.loc[<span class="number">0.05</span>]</span><br><span class="line">    q_95 = quantiles.loc[<span class="number">0.95</span>]</span><br><span class="line"></span><br><span class="line">    df.loc[:, col] = np.where(</span><br><span class="line">      df.loc[:, col].values &lt;= q_05,</span><br><span class="line">      q_05,</span><br><span class="line">      np.where(</span><br><span class="line">        df.loc[:, col].values &gt;= q_95,</span><br><span class="line">        q_95,</span><br><span class="line">        df.loc[:, col].values</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><h3 id="4-3-Transform-our-data-to-the-log-normal-distribution"><a href="#4-3-Transform-our-data-to-the-log-normal-distribution" class="headerlink" title="4.3. Transform our data to the log-normal distribution"></a>4.3. Transform our data to the log-normal distribution</h3><p>It’s a well-known fact in financial machine learning, that having our data normally distributed is the prerequisite of an effective machine learning model. After plotting each of the factors in the histogram, you can easily tell which feature is skewed, then you apply log transform to make it less skewed. One thing that is worth bringing up again, is that some features could contain a <code>0</code> value. Since log 0 doesn’t exist and will return <code>NaN</code>, causing model training to fail, make sure you add <code>1</code> before you log transform the feature values.</p><img data-src="/2022/10/21/2022-10-15-meta-label/log_transform.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Transform the right-skewed distribution to normal distribution</i></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__LogCustom</span>(<span class="params">self, df, cols: list</span>):</span></span><br><span class="line">  <span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">    df.loc[:, col] = np.log(df.loc[:, col] + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><h3 id="4-4-Drop-the-null-data"><a href="#4-4-Drop-the-null-data" class="headerlink" title="4.4. Drop the null data"></a>4.4. Drop the null data</h3><p>Don’t forget to trim the null data. Otherwise, your model is going to fail while training and predicting.</p><h2 id="5-Execute-and-place-orders-with-the-combined-signal"><a href="#5-Execute-and-place-orders-with-the-combined-signal" class="headerlink" title="5. Execute and place orders with the combined signal"></a>5. Execute and place orders with the combined signal</h2><p>Lastly, to summarize, our trading strategy would be that when we receive the signal from the primary model, we send the data on the day as the testing data for predicting with the secondary model. Once the secondary model confirms the signal with the prediction higher than 0.5 possibility to be a winning trade, then we place the buy order. As for selling the stock, we don’t need confirmation from the secondary model. As long as the primary model confirms and generates the sell signal, we sell the related holding stock.</p><h1 id="Backtesting-and-result"><a href="#Backtesting-and-result" class="headerlink" title="Backtesting and result"></a>Backtesting and result</h1><p>Ok. Let’s see what the backtesting results look like following the strategy that we describe above. I will start by describing the backtesting scenarios that we’re going to perform, and then demonstrate the results.</p><h2 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h2><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h2 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h2><ul><li>Sort stocks by <code>PERatio</code>, <code>EPS</code>, <code>ROE</code>, <code>NetIncome</code> and take top 60%</li><li>Sort stocks by <code>PBRatio</code>, from high to low</li><li>Focus on <code>technology</code> industry</li><li>Using QQQ as the portfolio benchmark</li></ul><h2 id="Rebalancing-Strategy"><a href="#Rebalancing-Strategy" class="headerlink" title="Rebalancing Strategy"></a>Rebalancing Strategy</h2><ul><li>Recalculate our universe and indicators to search for the buy and sell signals every day.</li><li>We keep 10 stocks that have buy-in signals and with the highest PBRatio.</li><li>We assign weight to each position evenly.</li><li>We don’t adjust the weight of each stock until we close these positions.</li><li>The secondary model will be re-trained monthly, weekly, and daily.</li></ul><h2 id="Backtest-time-frame"><a href="#Backtest-time-frame" class="headerlink" title="Backtest time frame"></a>Backtest time frame</h2><p>Backtest Date: <code>2018, 12 ,29</code> ~ <code>2022, 09, 24</code></p><h2 id="Execution-and-backtest"><a href="#Execution-and-backtest" class="headerlink" title="Execution and backtest"></a>Execution and backtest</h2><h3 id="Scenarios"><a href="#Scenarios" class="headerlink" title="Scenarios"></a>Scenarios</h3><p>There are two strategies in our arsenal and I’m going to try them out. I’m also going to take the frequency of updating our model into consideration by retraining the model with the up-to-date data every month, week, and day. Therefore, there are going to be six scenarios and two basic scenarios as our benchmark strategy in our backtests.</p><p><strong><em>1. MACD strategy benchmark</em></strong><br><strong><em>2. MACD strategy + Update monthly</em></strong><br><strong><em>3. MACD strategy + Update weekly</em></strong><br><strong><em>4. MACD strategy + Update daily</em></strong><br><strong><em>5. MACD+RSI strategy benchmark</em></strong><br><strong><em>6. MACD+RSI strategy + Update monthly</em></strong><br><strong><em>7. MACD+RSI strategy + Update weekly</em></strong><br><strong><em>8. MACD+RSI strategy + Update daily</em></strong></p><h3 id="Backtesting-results"><a href="#Backtesting-results" class="headerlink" title="Backtesting results"></a>Backtesting results</h3><div class="table-container"><table><thead><tr><th>Strategy</th><th>Total Trades</th><th>PSR</th><th>Unrealized</th><th>Fee</th><th>Return</th><th>Sharpe</th><th>MDD</th><th>Win rate</th><th>Alpha</th><th>Beta</th><th>Annual variance</th></tr></thead><tbody><tr><td>MACD Benchmark</td><td>838</td><td>23.299%</td><td>-$29,616.40</td><td>-$4,091.44</td><td><strong>146.89%</strong></td><td>0.787</td><td>42.300%</td><td><strong>67%</strong></td><td>0.119</td><td>1.053</td><td>0.087</td></tr><tr><td>MACD Monthly</td><td>928</td><td>14.622%</td><td>-$30,950.28</td><td>-$4,372.03</td><td><font color="scarlet">79.55%</font></td><td>0.587</td><td>44.700%</td><td><font color="scarlet">66%</font></td><td>0.038</td><td>1.067</td><td>0.068</td></tr><tr><td>MACD Weekly</td><td>834</td><td>21.410%</td><td>$-25,909.75</td><td>-$3,761.04</td><td><font color="green">150.54%</font></td><td>0.773</td><td>41.200%</td><td><font color="green">68%</font></td><td>0.125</td><td>1.074</td><td>0.096</td></tr><tr><td>MACD Daily</td><td>832</td><td>28.575%</td><td>$-36,755.89</td><td>-$4,177.46</td><td><font color="green">182.07%</font></td><td>0.88</td><td>42.500%</td><td><font color="green">68%</font></td><td>0.154</td><td>1.02</td><td>0.09</td></tr><tr><td>MACD+RSI Benchmark</td><td>1270</td><td>18.732%</td><td>$-14,361.51</td><td>-$6,592.32</td><td><strong>96.85%</strong></td><td>0.665</td><td>43.200%</td><td><strong>58%</strong></td><td>0.063</td><td>1.014</td><td>0.067</td></tr><tr><td>MACD+RSI Monthly</td><td>941</td><td>14.348%</td><td>$-7,308.52</td><td>-$4,382.58</td><td><font color="scarlet">72.05%</font></td><td>0.575</td><td>46.900%</td><td><font color="scarlet">56%</font></td><td>0.036</td><td>0.946</td><td>0.057</td></tr><tr><td>MACD+RSI Weekly</td><td>829</td><td>1.204%</td><td>$-436.44</td><td>-$3,535.95</td><td><font color="scarlet">-7.91%</font></td><td>0.03</td><td>56.000%</td><td><font color="scarlet">54%</font></td><td>-0.077</td><td>0.771</td><td>0.042</td></tr><tr><td>MACD+RSI Daily</td><td>898</td><td>19.534%</td><td>$-7,414.81</td><td>-$4,494.80</td><td><font color="green">92.44%</font></td><td>0.679</td><td>43.000%</td><td><font color="scarlet">56%</font></td><td>0.065</td><td>0.89</td><td>0.056</td></tr></tbody></table></div><h1 id="Beyond-and-next"><a href="#Beyond-and-next" class="headerlink" title="Beyond and next"></a>Beyond and next</h1><p>The purpose of Meta-labeling is not just for correcting the false-positive prediction, but also for raising the F1 score of the model. By adding another machine learning layer beyond the primary non-machine learning model, Meta-labeling enables the capability of processing quantitative fundamental data, technical indicators, and even arbitrary data in a more systematic way. This combines human intuition/experience and the power of machines, enhancing the interpretability and robustness of the model.</p><p>Even though the backtesting results failed to demonstrate the overwhelming power of the meta-labeling, there are still a few other thoughts and ideas to extend our backtesting and to further optimize our Meta-labeling trading algorithm:</p><ul><li>Add company-wise fundamental data into our training data to let our secondary machine learning model know more about the conditions and hence make better decisions.</li><li>In our backtest scenario, we round the prediction result and make it either True or False. That means the threshold is 0.5 that prediction lower than 0.5 would be deemed as a potentially losing trade, and the number above 0.5 would have a higher chance to become a winning trade. One thing we can do is to raise the threshold bar from 0.5 to a higher number to make sure you have an even higher chance to win in this trade. But keep this in mind, it’s going to be a trade-off between the number of trades and you could let the winning opportunities slip through your fingers.</li><li>Find a better method to label your y-label in order to distinguish the stocks that are going to soar or decline. You could either raise the original <strong>3.0%</strong> to a bigger number or mark the top 20% winning stocks so that our y-label will not be restricted to only the winning stocks during the bear market.</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>The book <strong><em>Advances in Financial Machine Learning</em></strong> by <em>Marcos Lopes De Prado</em></li><li><a href="http://www.sefidian.com/2021/06/26/labeling-financial-data-for-machine-learning/">Labeling financial data for Machine Learning</a> by <em>Amir Masoud Sefidian</em></li><li><a href="https://www.youtube.com/watch?v=ZCFmZFBtqsQ">Meta-Labeling: Theory and Framework - Youtube video</a> by <a href="https://hudsonthames.org/"><em>Hudson &amp; Thames</em></a></li></ul><hr><blockquote><p>If you enjoy reading this, feel free to <a src='https://medium.com/@mikelhsia/membership'> join Medium membership program</a> to read more about Quantitative Trading Strategy.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/10/21/2022-10-15-meta-label/cover.jpeg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p&gt;The Triple barrier method and meta-labeling technique were together introduced in the book &lt;strong&gt;&lt;em&gt;Advances in Financial Machine Learning&lt;/em&gt;&lt;/strong&gt; by &lt;em&gt;Marcos Lopez De Prado&lt;/em&gt;. It seems that the combination of these two tools makes a great pair to either stabilize or further increase your portfolio growth. In this post, I’m going to quote my old research result (&lt;a href=&quot;https://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/&quot;&gt;here&lt;/a&gt;) from last time as the fundamental strategy benchmark, and apply these two techniques to see what beneficial impact we could bring to this strategy.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    <category term="Machine Learning" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/Machine-Learning/"/>
    
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>【ML algo trading】 VI - Employ the power of ensemble learning to increase your portfolio return</title>
    <link href="http://mikelhsia.github.io/2022/08/20/2022-08-20-votingclassifier/"/>
    <id>http://mikelhsia.github.io/2022/08/20/2022-08-20-votingclassifier/</id>
    <published>2022-08-20T03:45:58.000Z</published>
    <updated>2022-08-25T02:21:08.673Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/08/20/2022-08-20-votingclassifier/cover.jpg" class="" width="800"><p>When it comes to using machine learning algorithm to pick the stocks that are most likely to produce a good return, it is similar to seeking the opinion of an investment consultant. However, it can be unsettling to make your investment decision after listening to just one consultant. Now is the moment to get second opinions and hire more investment advisors to make sure the investment concept is reliable, doable, and profitable.</p><p>The same principle that you consult other machine learning algorithms to confirm the predictions made by these models are applied in ensemble learning. When you have collected all of the final data from these models, you may take your time relaxing in your nice chair like a big boss, analyzing the results, and making your important and sacred decision.</p><a id="more"></a><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>In the previous articles <a href="https://mikelhsia.github.io/2021/04/22/2021-04-22-machine-learning-intro/">1</a> <a href="https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/">2</a> <a href="https://mikelhsia.github.io/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/">3</a> <a href="https://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/">4</a> and <a href="https://mikelhsia.github.io/2022/06/10/2022-06-10-adcanced-optimization/">5</a>, we have built the machine learning script to predict the winners in the stock market using only the XGBoost model. Nevertheless, there are many algorithms out there for us to try and evaluate. So the most important question for us becomes much more complex. We need to build multiple machine learning models, use <code>GridSearch</code> to find the best hyperparameters, train/fit many different machine learning models, evaluate each model with the same metrics, pick the best-performing model for us to use, and …….</p><img data-src="/2022/08/20/2022-08-20-votingclassifier/or_do_we.png" class="" width="600"><h1 id="How-are-we-going-to-do-this"><a href="#How-are-we-going-to-do-this" class="headerlink" title="How are we going to do this?"></a>How are we going to do this?</h1><h2 id="Ensemble-learning"><a href="#Ensemble-learning" class="headerlink" title="Ensemble learning"></a>Ensemble learning</h2><p>Ensemble learning is a method to combine the predictions from different machine learning models. We gave these machine learning models the name <code>weak learners</code>, as compared to our finalize machine learning model, these <code>weak learners</code> contribute only a part of their efforts to produce the final predictions. By saying that, the ensemble learning model is a more powerful predictor by using a <code>strong learner</code> to assemble the results from many <code>weak learners</code>, so that our final predictor is able to waive the variances from some of the machine learning models and also prevent the overfitting of a singular model. Below is the list of the ensemble learning techniques:</p><img data-src="/2022/08/20/2022-08-20-votingclassifier/ensemble_types.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Different types of ensemble learning techniques</i></p><h2 id="Pause-Let’s-narrow-it-down"><a href="#Pause-Let’s-narrow-it-down" class="headerlink" title="Pause!! Let’s narrow it down"></a>Pause!! Let’s narrow it down</h2><p>Among these ensemble learning techniques, Bagging and Boosting are the most commonly known techniques. They are even used in the modern machine learning algorithm such as the Adaboost model or the XGBoost model that we used in our previous articles. However, to cover all these techniques would probably bore you to death. Therefore, we’re going to introduce two techniques in this article, <strong>Average Voting</strong> and <strong>Stacking</strong>. Also, as explaining the basic theory is not my strength, I’ll put less effort into explaining and more effort into describing the details of the backtests and coding details.</p><h3 id="Average-Voting"><a href="#Average-Voting" class="headerlink" title="Average Voting"></a>Average Voting</h3><p>As the name implies, average voting is to average the predicted scores/probabilities from your <code>weak learners</code> and output the final scores/probabilities. For example, you have three <code>weak learners</code> classifier models trained and produced the final predicted probabilities of getting the positive return tomorrow.</p><div class="table-container"><table><thead><tr><th>Classifier Model</th><th>Stock 1</th><th>Stock 2</th><th>Stock 3</th></tr></thead><tbody><tr><td>A</td><td>0.9</td><td>0.9</td><td>0.7</td></tr><tr><td>B</td><td>0.7</td><td>0.3</td><td>0.7</td></tr><tr><td>C</td><td>0.6</td><td>0.7</td><td>0.7</td></tr><tr><td><strong>Averaged possibility</strong></td><td><strong>0.73</strong></td><td><strong>0.63</strong></td><td><strong>0.7</strong></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Possibilities of getting the positive return tomorrow (Soft voting)</i></p><p>If we look at models A, B, and C respectively, we probably end up buying Stock 2 as it has a relatively high probability to receive a positive return from models A and C. After employing the average voting technique, the probability of Stock 2 now drops to 66% and Stock 1 probability would top Stock 2, indicating that Stock 1 would actually have a higher probability to receive a positive return than the other two stocks. This is so-called <strong>Soft Voting</strong>.</p><p>There is also <strong>Hard Voting</strong>, which takes binary inputs, True or False, into account instead of the probabilities. Taking the same example as above, we add one more condition that the output would be 1 (True) only when the possibility is over 0.7. The final result would be quite different.</p><div class="table-container"><table><thead><tr><th>Classifier Model</th><th>Stock 1</th><th>Stock 2</th><th>Stock 3</th></tr></thead><tbody><tr><td>A</td><td>0.9 (1)</td><td>0.9 (1)</td><td>0.7 (1)</td></tr><tr><td>B</td><td>0.7 (1)</td><td>0.3 (0)</td><td>0.7 (1)</td></tr><tr><td>C</td><td>0.6 (0)</td><td>0.7 (1)</td><td>0.7 (1)</td></tr><tr><td><strong>Voter</strong></td><td><strong>2 Positives &amp; 1 Negative</strong></td><td><strong>2 Positives &amp; 1 Negative</strong></td><td><strong><em>3 Positives</em></strong></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Possibilities of getting the positive return tomorrow (Hard voting)</i></p><p>By looking at the total number of the voters who vote positive, the final winner would be Stock 3 as it has 3 people who think it’s going to receive a positive return tomorrow. Therefore the <strong>Hard Voting</strong> would recommend Stock 3, yet the <strong>Soft Voting</strong> would recommend Stock 2. The concept is quite straightforward, but this technique does help the model to mitigate the impact of the high variance of one single model.</p><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><p>Other than average voting, <strong>Stacking</strong> processes the predictions from the <code>weak learners</code> in a more advanced way. <strong>Stacking</strong> treats the outputs of its <code>weak learners</code> as features and stacks them together into secondary training data. The secondary training data will be used as the inputs for the final estimator (a.k.a. meta-model), and then computes the final prediction.</p><img data-src="/2022/08/20/2022-08-20-votingclassifier/stacking.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Stacking technique illustration</i></p><p>As illustrated above, classification models A, B, and C use the same training data to train the model and then produce predictions A, predictions B, and predictions C. The final estimator treats these predictions as new features to compute the final prediction.</p><h1 id="Walk-through-the-strategies"><a href="#Walk-through-the-strategies" class="headerlink" title="Walk through the strategies"></a>Walk through the strategies</h1><p>We now have the general idea of these two ensemble learning techniques, let’s move on to the backtest so that we can understand the power of ensemble learning. In this series of backtests, we are going to use the same dataset to train 1. XGBoost, 2. LogisticRegression, 3. SVM, and 4. Deep Learning with 2 layers of hidden layers. After conducting the backtests using these models respectively, we will combine these models together and apply <strong>Average Voting</strong> and <strong>Stacking</strong> techniques respectively to see whether the performances are improved or not.</p><h2 id="Universe-and-training-data"><a href="#Universe-and-training-data" class="headerlink" title="Universe and training data"></a>Universe and training data</h2><p>I’m still using <code>ZZ500</code> as our universe and the same set of features as the training data. If you are interested in knowing how to define the universe and what features I’ve been using, you can check out my previous articles regarding machine learning and factor analysis.</p><h2 id="Backtest-timeframe"><a href="#Backtest-timeframe" class="headerlink" title="Backtest timeframe"></a>Backtest timeframe</h2><p>My backtest timeframe is from <code>2020-04 ~ 2022-07</code>. For each month, I would need 60 months’ data as the training data to train the model. Therefore, it would require 27 (validation data) + 60 (training data) = 87 months = ~ 8 years of stock data.</p><h2 id="Backtest-scenarios"><a href="#Backtest-scenarios" class="headerlink" title="Backtest scenarios"></a>Backtest scenarios</h2><p>Here are the four models that I employed in this backtest. Again, I’m not the professor of the machine learning algorithm that can turn you into a machine learning expert with what I know. Instead, I’m going to put some quick descriptions and the materials that help me understand the basics of these ML models.</p><p><strong><em>1. XGBoost</em></strong><br>This is the decision-tree-base model that I’ve been using since the first article. The advantage of this algorithm is it’s <strong><em>extremely fast</em></strong>. This model took 1/5 of the time to train compared to other models. Below are the <a href="https://www.youtube.com/c/joshstarmer/videos">StatQuest</a> videos that help me to understand what XGBoost is about:</p><ul><li><a href="https://www.youtube.com/watch?v=3CC4N4z3GJc">Gradient Boost Part 1 (of 4): Regression Main Ideas</a></li><li><a href="https://www.youtube.com/watch?v=2xudPOBz-vs">Gradient Boost Part 2 (of 4): Regression Details</a></li><li><a href="https://www.youtube.com/watch?v=jxuNLH5dXCs">Gradient Boost Part 3 (of 4): Classification</a></li><li><a href="https://www.youtube.com/watch?v=StWY5QWMXCw">Gradient Boost Part 4 (of 4): Classification Details</a></li><li><a href="https://www.youtube.com/watch?v=OtD8wVaFm6E&amp;t=12s">XGBoost Part 1 (of 4): Regression</a></li><li><a href="https://www.youtube.com/watch?v=8b1JEDvenQU&amp;t=1153s">XGBoost Part 2 (of 4): Classification</a></li><li><a href="https://www.youtube.com/watch?v=ZVFeW798-2I">XGBoost Part 3 (of 4): Mathematical Details</a></li><li><a href="https://www.youtube.com/watch?v=oRrKeUCEbq8">XGBoost Part 4 (of 4): Crazy Cool Optimizations</a></li></ul><p><strong><em>2. LogisticRegression</em></strong><br>Logistic Regression is very much like the Linear regression that I talked about in <a href="https://mikelhsia.github.io/2021/01/31/2021-01-31-factor-analysis/">【Factor analysis】 Vol. 1. Introduction the idea of factor analysis</a>. It uses various ordinal features to predict the probability of whether a thing will happen or not. To transform the probability into a Boolean value that stands for whether a certain incidence will happen or not, an activation function (such as Sigmoid or Softmax) will be applied. Here are the materials for you to know more about logistic regression:</p><ul><li><a href="https://www.youtube.com/watch?v=yIYKR4sgzI8">StatQuest: Logistic Regression</a></li><li><a href="https://www.youtube.com/watch?v=vN5cNN2-HWE">Logistic Regression Details Pt1: Coefficients</a></li><li><a href="https://www.youtube.com/watch?v=BfKanl1aSG0">Logistic Regression Details Pt 2: Maximum Likelihood</a></li><li><a href="https://www.youtube.com/watch?v=M59JElEPgIg&amp;t=355s">The SoftMax Derivative, Step-by-Step!!!</a></li></ul><p><strong><em>3. SVM</em></strong><br>I have introduced the concept of SVM <a href="https://mikelhsia.github.io/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/">here</a>. SVM is a variant of logistic regression. Instead of finding the exact line to separate all the 0’s and the 1’s, we include an extra hyperplane into the model. We hope that by adding this hyperplane,  we will be able to clearly separate the data into different groups. The method for inserting this hyperplane is referred to as a ‘kernel.’</p><ul><li><a href="https://www.youtube.com/watch?v=efR1C6CvhmE">Support Vector Machines Part 1 (of 3): Main Ideas!!!</a></li><li><a href="https://www.youtube.com/watch?v=Toet3EiSFcM">Support Vector Machines Part 2: The Polynomial Kernel (Part 2 of 3)</a></li><li><a href="https://www.youtube.com/watch?v=Qc5IyLW_hns">Support Vector Machines Part 3: The Radial (RBF) Kernel (Part 3 of 3)</a></li></ul><p><strong><em>4. Neural Networks</em></strong><br>The neural network is a type of deep learning algorithm. It uses numerous nodes to simulate the neuron in a neural system of a person, that each neuron makes individual solution and combine these solutions to make the final solution. Below are the related articles to talk about the NN model:</p><ul><li><a href="https://www.TensorFlow.org/guide">TensorFlow Guide</a></li><li><a href="https://www.youtube.com/watch?v=L35fFDpwIM4">Tensors for Neural Networks, Clearly Explained!!!</a></li><li><a href="https://www.youtube.com/watch?v=CqOfi41LfDw&amp;t=34s">Neural Networks Pt. 1: Inside the Black Box</a></li><li><a href="https://www.youtube.com/watch?v=IN2XmBhILt4">Neural Networks Pt. 2: Backpropagation Main Ideas</a></li><li><a href="https://www.youtube.com/watch?v=68BZ5f7P94E">Neural Networks Pt. 3: ReLU In Action!!!</a></li><li><a href="https://www.youtube.com/watch?v=83LYR-1IcjA">Neural Networks Pt. 4: Multiple Inputs and Outputs</a></li><li><a href="https://www.youtube.com/watch?v=KpKog-L9veg">Neural Networks Part 5: ArgMax and SoftMax</a></li><li><a href="https://www.youtube.com/watch?v=6ArSys5qHAU">Neural Networks Part 6: Cross Entropy</a></li><li><a href="https://www.youtube.com/watch?v=xBEh66V9gZo">Neural Networks Part 7: Cross Entropy Derivatives and Backpropagation</a></li><li><a href="https://www.youtube.com/watch?v=HGwBXDKFk9I">Neural Networks Part 8: Image Classification with Convolutional Neural Networks (CNNs)</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span>():</span></span><br><span class="line">  model = tf.keras.Sequential()</span><br><span class="line">  model.add(tf.keras.layers.Dense(<span class="number">256</span>, activation=<span class="string">&quot;relu&quot;</span>, input_shape=(<span class="number">179</span>, ), name=<span class="string">&quot;dense_1&quot;</span>))</span><br><span class="line">  model.add(tf.keras.layers.Dropout(<span class="number">0.1</span>),)</span><br><span class="line">  model.add(tf.keras.layers.Dense(<span class="number">256</span>, activation=<span class="string">&quot;relu&quot;</span>, name=<span class="string">&quot;dense_2&quot;</span>))</span><br><span class="line">  model.add(tf.keras.layers.Dropout(<span class="number">0.1</span>)),</span><br><span class="line">  model.add(tf.keras.layers.Dense(<span class="number">1</span>, activation=<span class="string">&quot;sigmoid&quot;</span>, name=<span class="string">&quot;predictions&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Compile model</span></span><br><span class="line">  model.compile(</span><br><span class="line">    optimizer=<span class="string">&#x27;adam&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>,</span><br><span class="line">    metrics=[</span><br><span class="line">      tf.keras.metrics.AUC(),</span><br><span class="line">      tf.keras.metrics.BinaryAccuracy(),</span><br><span class="line">    ],</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p style="text-align:center; color: grey;">  <i>My neural network model set up</i></p><p><strong><em>5. Average Voting Algorithm</em></strong><br>As previously explained, <strong>Average Voting</strong> essentially averages out the predicted scores/possibilities participated in machine learning models. Therefore, it’s relatively easy to implement the average voting model by putting your model into a list as an <code>estimator</code> parameter. The tricky part is, that the TensorFlow library that the neural network model uses is originally developed by <em>Google</em>, and the scikit-learn library that built the <code>VotingClassifier</code> is not. These two models are not naturally compatible and your neural network model can’t be tucked into the <code>estimator</code> parameter directly. Fortunately, TensorFlow also provides the function to wrap our NN model into a format that the scikit-learn library can understand. Hence, remember to wrap your NN model before you start building your <strong>Average Voting Algorithm</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TensorFlow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">nn_model = tf.keras.wrappers.scikit_learn.KerasClassifier(</span><br><span class="line">    build_fn=get_model,</span><br><span class="line">    epochs=<span class="number">40</span>,</span><br><span class="line">    verbose=<span class="literal">False</span>,</span><br><span class="line">)</span><br><span class="line">nn_model._estimator_type = <span class="string">&#x27;classifier&#x27;</span></span><br><span class="line"></span><br><span class="line">scaled_nn_model = make_pipeline(</span><br><span class="line">    RobustScaler(),</span><br><span class="line">    nn_model</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p style="text-align:center; color: grey;">  <i>Use `tf.keras.wrapper.scikit_learn` to wrap our NN model</i></p><p>Once you have your models ready, you simply need to put them together into a list and add the wrapper to the <code>VotingClassifier</code> function. Here we use <code>voting=&#39;soft&#39;</code> to smooth the variance of the model predictions.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># Instantiate the VotingClassifier class</span></span><br><span class="line">voting_model = VotingClassifier(estimators=[</span><br><span class="line">    (<span class="string">&#x27;xgboost_model&#x27;</span>, xgb_model),</span><br><span class="line">    (<span class="string">&#x27;scaled_lr&#x27;</span>, scaled_lr_model),</span><br><span class="line">    (<span class="string">&#x27;scaled_svm&#x27;</span>, scaled_svm_model),</span><br><span class="line">    (<span class="string">&#x27;scaled_nn&#x27;</span>, scaled_nn_model),</span><br><span class="line">  ],</span><br><span class="line">  voting=<span class="string">&#x27;soft&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train the voting model</span></span><br><span class="line">voting_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the prediction</span></span><br><span class="line">y_predict = voting_model.predict(X_test)</span><br></pre></td></tr></table></figure><p style="text-align:center; color: grey;">  <i>VotingClassifier basic instruction</i></p><p><strong><em>6. Stacking</em></strong><br>In our <strong>StackingClassifier</strong>, we use the XGBoost model,  the Support Vector Machine model, and Neural Network models as our base estimators. As for the final estimator to produce the final prediction, we use the Logistic Regression model with the parameters needed. Once the model is instantiated, we can use this instance as the rest of scikit-learn model to <code>fit</code> and to <code>predict</code>. Make sure you include the hyperparameters before you build your base learner models.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> StackingClassifier</span><br><span class="line">base_learners = [</span><br><span class="line">  (<span class="string">&#x27;xgboost_model&#x27;</span>, xgb_model),</span><br><span class="line">  (<span class="string">&#x27;scaled_svm&#x27;</span>, scaled_svm_model),</span><br><span class="line">  (<span class="string">&#x27;scaled_nn&#x27;</span>, scaled_nn_model),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">model = StackingClassifier(</span><br><span class="line">  estimators=base_learners,</span><br><span class="line">  final_estimator=LogisticRegression()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_predict = model.predict(X_test)</span><br></pre></td></tr></table></figure><p style="text-align:center; color: grey;">  <i>Basic set up of StackingClassifier</i></p><h2 id="Backtest-results"><a href="#Backtest-results" class="headerlink" title="Backtest results"></a>Backtest results</h2><h3 id="Backtest-results-summary"><a href="#Backtest-results-summary" class="headerlink" title="Backtest results summary"></a>Backtest results summary</h3><img data-src="/2022/08/20/2022-08-20-votingclassifier/backtest_results.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Backtest results summary</i></p><p>Even though the annual returns of both VotingClassifier and StackingClassifier are not higher than the other machine learning model, the Sharpe Ratio and the Maximum Drawdown are relatively lower. The win rate of the VotingClassifier scenario even increases to 61%, indicating our model is more powerful in its predictability to pick the stocks that are more possible to gain positive returns. To gain a more intuitive sense of how the ensemble learning method impacts our model, let’s look at the stratified and the return diagrams.</p><div class="table-container"><table><thead><tr><th>Scenario</th><th>Stratified Diagram</th><th>Return Diagram</th></tr></thead><tbody><tr><td>XGBoost</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/1-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/1-return.png" class="" width="300"></td></tr><tr><td>Logistic Regression</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/2-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/2-return.png" class="" width="300"></td></tr><tr><td>SVM</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/3-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/3-return.png" class="" width="300"></td></tr><tr><td>Neural Network</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/4-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/4-return.png" class="" width="300"></td></tr><tr><td>Average Voting</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/5-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/5-return.png" class="" width="300"></td></tr><tr><td>Stacking</td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/6-group.png" class="" width="300"></td><td><img data-src="/2022/08/20/2022-08-20-votingclassifier/6-return.png" class="" width="300"></td></tr></tbody></table></div><p>It’s quite clear that our ensemble learning methods (<strong><em>Average Voting</em></strong> and <strong><em>Stacking</em></strong>) less fluctuate than the rest of the models. By comparing the same bear market period from <code>2022-02</code>~<code>2022-04</code>, our loss appears a lot less than the non-ensemble learning methods.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>For the <strong><em>Average Voting</em></strong> ensemble learning method, it seems to produce a better result and improve the predictability of our model. However, there are a lot fewer places we can step in to better fine-tune the model. On the contrary, there is much more room for us to find out the best combination of the base estimators when we look at the <strong><em>Stacking</em></strong> ensemble learning method. Hence, one thing we can try is using the result from <strong><em>Average Voting</em></strong> as a benchmark and using <strong><em>Stacking</em></strong> as a tool to see whether we can build a much more powerful model to better predict the market.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://neptune.ai/blog/ensemble-learning-guide">A Comprehensive Guide to Ensemble Learning: What Exactly Do You Need to Know?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/08/20/2022-08-20-votingclassifier/cover.jpg&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;p&gt;When it comes to using machine learning algorithm to pick the stocks that are most likely to produce a good return, it is similar to seeking the opinion of an investment consultant. However, it can be unsettling to make your investment decision after listening to just one consultant. Now is the moment to get second opinions and hire more investment advisors to make sure the investment concept is reliable, doable, and profitable.&lt;/p&gt;
&lt;p&gt;The same principle that you consult other machine learning algorithms to confirm the predictions made by these models are applied in ensemble learning. When you have collected all of the final data from these models, you may take your time relaxing in your nice chair like a big boss, analyzing the results, and making your important and sacred decision.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    <category term="Machine Learning" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/Machine-Learning/"/>
    
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>【ML algo trading】 V - Raise your trading win rate through feature engineering</title>
    <link href="http://mikelhsia.github.io/2022/06/10/2022-06-10-adcanced-optimization/"/>
    <id>http://mikelhsia.github.io/2022/06/10/2022-06-10-adcanced-optimization/</id>
    <published>2022-06-10T08:21:42.000Z</published>
    <updated>2022-08-24T18:00:02.298Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/06/10/2022-06-10-adcanced-optimization/cover.jpeg" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Photo by <a href="https://medium.com/r?url=https%3A%2F%2Funsplash.com%2F%40brett_jordan%3Futm_source%3Dmedium%26utm_medium%3Dreferral">Brett Jordan</a> on <a href="https://medium.com/r/?url=https%3A%2F%2Funsplash.com%3Futm_source%3Dmedium%26utm_medium%3Dreferral">Unsplash</a></i></p><p>From the <a href="https://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/">previous article</a>, we’ve learned several indicators that we can calculate and use to evaluate the performances of your algorithm trading strategies. Given these indicators, we’re able to see how we can further polish our strategy and make it more seemingly profitable. Therefore, let’s work on our features to see how we can improve our machine learning trading strategy.</p><a id="more"></a><p>There are a few feature engineering techniques that we’re going to use in this series of backtests and it is beneficial to get a big picture of how to apply these techniques. I’m not going to go through these techniques in detail as there are too many capable persons who have done so. Therefore, I’ll be only focusing on backtesting the trading strategies using these techniques and how they can impact the performance of the strategy.</p><ul><li><a href="https://www.geeksforgeeks.org/feature-encoding-techniques-machine-learning/">Encoding</a></li><li><a href="https://towardsdatascience.com/6-different-ways-to-compensate-for-missing-values-data-imputation-with-examples-6022d9ca0779">Imputing</a></li><li><a href="https://towardsdatascience.com/a-data-scientists-practical-guide-to-using-kmeans-ff180878e13b">Kmean</a></li></ul><p>Also, I’m using the algorithm trading script that I built from my previous articles below. So we don’t need to build everything from the scratch.</p><blockquote><p><strong>Previous articles</strong></p><ul><li><a href="https://mikelhsia.github.io/2021/04/22/2021-04-22-machine-learning-intro/">【Machine Learning】 Part I - 10 minutes to learn what I know about machine learning in quantitative trading</a></li><li><a href="https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/">【Machine Learning】 Part II - How to build a machine learning boilerplate?</a></li><li><a href="https://mikelhsia.github.io/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/">【Machine Learning】 Part III - 5 myths about practicing quant trading with machine learning</a></li><li><a href="https://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/">【Machine Learning】 Part IV - How to analyze how good my machine learning strategy is?</a></li></ul></blockquote><h1 id="Train-of-thought"><a href="#Train-of-thought" class="headerlink" title="Train of thought"></a>Train of thought</h1><p>There are three scenarios that we’re going to use as the benchmark performances:</p><ol><li>Using XGBoost as ML model and 30-month data as training data</li><li>Using XGBoost as ML model and 60-month data as training data</li><li>Using AdaBoost as ML model and 60-month data as training data</li></ol><p>Here’s a quick but complete <a href="https://towardsdatascience.com/the-ultimate-guide-to-adaboost-random-forests-and-xgboost-7f9327061c4f">guide</a> to both XGBoost and AdaBoost. XGBoost is famous for its speed of processing and high accuracy. On the other hand, AdaBoost is slower than XGBoost, but is capable of mitigating the chances of overfitting. So we will adopt both of these models to reach a justifiable performance evaluation.</p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/summary.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Stats benchmark summary of three scenarios</i></p><div class="table-container"><table><thead><tr><th>XGBoost, 30 months</th><th>XGBoost, 60 months</th><th>AdaBoost, 60 months</th></tr></thead><tbody><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario1_benchmark.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario2_benchmark.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario3_benchmark.png" class="" width="200"></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Stratified plotting of base scenarios return by probability to win</i></p><p>From the above table and charts, <strong>XGBoost with a 30-month data</strong> scenario is apparently the most lucrative scenario, and the scenario of using <strong>AdaBoost with 60-month data</strong> seems to work poorly compared to other scenarios. Now let’s first look at what could bring by adding <code>industry</code> feature to our feature set.</p><h2 id="Adding-industry-feature-Encoding"><a href="#Adding-industry-feature-Encoding" class="headerlink" title="Adding industry feature - Encoding"></a>Adding <code>industry</code> feature - Encoding</h2><h3 id="Why-adding-industry-feature"><a href="#Why-adding-industry-feature" class="headerlink" title="Why adding industry feature"></a>Why adding <code>industry</code> feature</h3><p>It’s a well-known fact that stocks in the same industry have similar wax and wane due to the reason that they are running a similar business, using similar materials, producing similar products, and providing similar services. It’s a common belief that this cyclical characteristic of stocks needs to be factored into our machine learning prediction model in order to reflect this phenomenon.</p><p><code>industry</code> feature contains string-like data such as ‘Technology’, ‘Utilities’, or ‘Manufacturing’. However, both XGBoost and AdaBoost are tree-based classifiers that only accept ordinal numbers as features in training data. Therefore, we need to transform these string-like data into numbers so that our classifiers can understand the data.</p><h3 id="One-hot-encoding"><a href="#One-hot-encoding" class="headerlink" title="One-hot encoding"></a>One-hot encoding</h3><p>The technique to transform string-like data into ordinal data is called <strong>encoding</strong>. Typically we apply <strong>Label Encoding</strong>, in which we use one number to label one string in the <code>Industry</code> column. One implicit drawback of it is that <strong>Label Encoding</strong> might suggest that the bigger number is more important than the smaller number. Taking the below table as an example, is <code>&#123;&#39;Electric&#39; = 4&#125;</code> really more important than <code>&#123;&#39;Technology&#39; = 1&#125;</code> in the transformed training data set?</p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/wrong_encoding.png" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Label encoding doesn't work in this case</i></p><p>Here’s where <strong>One-hot Encoding</strong> comes into play. <strong>One-hot Encoding</strong> is a labeling technique that essentially uses one full column to present one single value in the original <code>Industry</code> column. The transformed data would have <em>N</em> new columns when there is <em>N</em> unique value in the <code>Industry</code> column. By doing this, we can remove the ordinal implication from <strong>Label Encoding</strong>.</p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/right_encoding.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>One-hot encoding transformation</i></p><h3 id="Backtest-results"><a href="#Backtest-results" class="headerlink" title="Backtest results"></a>Backtest results</h3><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/one_hot_summary.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i> Performance summary of three base scenarios with one-hot transformed industry feature</i></p><div class="table-container"><table><thead><tr><th>XGBoost, 30 months</th><th>XGBoost, 60 months</th><th>AdaBoost, 60 months</th></tr></thead><tbody><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario1_benchmark.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario2_benchmark.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/scenario3_benchmark.png" class="" width="200"></td></tr><tr><td><div style="text-align: center;">One-hot encoded</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">One-hot encoded</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">One-hot encoded</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td></tr><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/30_one_hot.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/60_one_hot.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/60_ada_one_hot.png" class="" width="200"></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Stratified plotting of one-hot encoded enhanced scenario returns by probability to win</i></p><p>The performance of the two scenarios using XGBoost actually improved quite a bit in terms of the portfolio return, win rate, and even the Machine Learning score like F1, AUC, and MCC. These backtest results possibly suggest that accounting <code>industry</code> feature into our machine learning model does help generate a better-trained model.</p><h2 id="Dealing-with-missing-data-NA-Imputer"><a href="#Dealing-with-missing-data-NA-Imputer" class="headerlink" title="Dealing with missing data (NA) - Imputer"></a>Dealing with missing data (NA) - Imputer</h2><p>Previously in the post <a href="https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/">【Machine Learning】 Part II - How to build a machine learning boilerplate?</a>, the way we deal with the missing data is to drop all of them to avoid adding human-biased data. This is actually a luxury move for data scientists as the amount of the data is usually quite limited. If we can gently cast some fairy dust and revive those dumped data, the amount of data could be doubled or even tripled, and then train our model to be more accurate.</p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/fairy_dust.png" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><h3 id="Imputer-What-is-it"><a href="#Imputer-What-is-it" class="headerlink" title="Imputer? What is it?"></a>Imputer? What is it?</h3><p>Imputer is a word actually found in <code>sklearn</code> machine learning python package, and the meaning of the word hardly tells me what it does. Imputer in <code>sklearn</code> is a sub-package to fill the missing data in various ways. There are <strong>SimpleImputer</strong> that fills the missing data with the mean of all the numbers, <strong>KNNImputer</strong> that separate data into different groups and fills the missing data with the mean of numbers in the same group, and also <strong>IterativeImputer</strong> that fills the missing data by estimation instead of the mean. In this post, <strong>SimpleImputer</strong> would be the tool that we’re using to fill the missing data.</p><h3 id="Three-scenarios-to-fill-the-missing-data"><a href="#Three-scenarios-to-fill-the-missing-data" class="headerlink" title="Three scenarios to fill the missing data"></a>Three scenarios to fill the missing data</h3><p>Even though we’re using the simple <strong>SimpleImputer</strong>, there are still ways we can fill the missing data in a more sensible way.</p><ul><li>Drop all the columns that have missing data<ul><li>This is the original method how we deal with the missing data in our machine learning model. The missing data is dropped instead of filling any arbitrary number so that we don’t add any personal bias to the dataset.</li></ul></li><li>Fill all the data by column<ul><li>We fill every the missing data together so that all the missing numbers of the same feature will be filled in the mean of all available numbers.</li></ul></li><li>Fill the missing data by symbol<ul><li>In our training data, we have features such as company quarterly sales, gross profit, and cash/debt ratio(refer to <a href="https://mikelhsia.github.io/2021/02/23/2021-02-11-factor-analysis-3/">Factor analysis Part III</a>). These company-specific fundamental numbers can be very different from one company to another due to the nature of the industry or company itself. For example, company A quarterly sales are 1M, 1.5M, 2M in Q1, Q2, and Q3 respectively. On the other hand, the quarterly sales of company B could be 20B in Q1, 21B in Q2, but Q3 data is missing. It won’t make any sense if we fill the missing Q3 of company B with the mean of (1M, 1.5M, 2M, 20B, 21B), right? That’s why it is better we fill the missing data according to the existing data of the company itself.</li></ul></li></ul><h3 id="Backtest-results-1"><a href="#Backtest-results-1" class="headerlink" title="Backtest results"></a>Backtest results</h3><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/impute_summary.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i> Performance summary of three base scenarios with imputed data</i></p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/impute0.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>XGBoost, 30-month data performance stratified plot</i></p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/impute1.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>XGBoost, 60-month data performance stratified plot</i></p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/impute2.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>AdaBoost, 60-month data performance stratified plot</i></p><p>From the first summary table, it’s quite clear that the performances of the data-imputed scenarios are worse than the performance of the drop-missing-data scenario. Not only the annual return dropped 20~30%, and also the win rate, MDD, MCC score, and other figures drop significantly compared to the benchmark scenario. Then we move on to the stratified plot of our three base scenarios. Either the fill-everything scenario or the fill-missing-data-by-company scenario has greatly contributed to the ability to effectively separate the most probable winning group (group 1, red line) from the other groups. We might now be able to extract and form our preliminary conclusion that <code>&quot;SimpleImputer&quot; might not work in these scenarios but add more noises to the model, further decreasing the precision and accuracy of our model.</code> You can also try out the <strong>KNNImputer</strong> or <strong>IterativeImputer</strong> to see whether can achieve a better outcome.</p><h2 id="Combine-features-gt-Kmean"><a href="#Combine-features-gt-Kmean" class="headerlink" title="Combine features -&gt; Kmean"></a>Combine features -&gt; Kmean</h2><h3 id="What-is-Kmean-and-how-to-decide-“K”"><a href="#What-is-Kmean-and-how-to-decide-“K”" class="headerlink" title="What is Kmean and how to decide “K”"></a>What is Kmean and how to decide “K”</h3><p><a href="https://en.wikipedia.org/wiki/K-means_clustering">K-mean</a> is a method/technique that aims to cluster all the data into <em>K</em> groups by analyzing the given features. I’m not going to go through the details and how to conduct your own k-mean clustering, as there are so many people doing so on <a href="https://medium.com/">medium</a> and other ML platforms. I’m only going to reveal and illustrate the backtest outcomes to you.</p><p> What’s the benefit of conducting k-mean clustering? In the financial ML model, there are so many fundamental data such as sales, gross profit, and cash-to-debt ratio of every individual company. However, it’s a bit too complicated to take all these fundamental figures into account while training our ML model. Therefore, instead of using these fundamental figures as they were, it would be easier, more meaningful, and more effective if we can categorize them into several groups before we feed the data into the machine learning model.</p><h3 id="Combining-features"><a href="#Combining-features" class="headerlink" title="Combining features"></a>Combining features</h3><p>Let’s take the example that we used in our backtest, that we combine features <code>ROA</code>, <code>asset turnover</code>, <code>Sharpe ratio since the last 20 days</code>, and <code>Sharpe ratio since the last 60 days</code>. Instead of feeding these figures right into the machine learning model, we use the k-mean clustering method to categorize them into <em>K</em> groups and name the group feature <code>profitability_of_the_company</code>. Wouldn’t that make more sense for the model to know how profitable the company is rather than knowing the fundamental figures of the company? But remember, that the ordinal number is not suitable for the category type of data. Make sure you use <strong>One-hot encoding</strong> to separate the profitability type into features so that you’ll be able to feed these data into the model in a correct way.</p><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/kmean.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Using Kmean to produce meaningful features</i></p><h3 id="Backtest-results-2"><a href="#Backtest-results-2" class="headerlink" title="Backtest results"></a>Backtest results</h3><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/kmean_summary.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i> Performance summary of three base scenarios with imputed data and additional kmean clustering</i></p><div class="table-container"><table><thead><tr><th>Drop missing data</th><th>Impute everything</th><th>Impute missing data by company</th></tr></thead><tbody><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/1-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/1-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/1-2.png" class="" width="200"></td></tr><tr><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td></tr><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-1-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-1-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-1-2.png" class="" width="200"></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>XGBoost, 30-month data performance stratified plot</i></p><div class="table-container"><table><thead><tr><th>Drop missing data</th><th>Impute everything</th><th>Impute missing data by company</th></tr></thead><tbody><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/2-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/2-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/2-2.png" class="" width="200"></td></tr><tr><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td></tr><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-2-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-2-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-2-2.png" class="" width="200"></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>XGBoost, 60-month data performance stratified plot</i></p><div class="table-container"><table><thead><tr><th>Drop missing data</th><th>Impute everything</th><th>Impute missing data by company</th></tr></thead><tbody><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/3-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/3-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/3-2.png" class="" width="200"></td></tr><tr><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td><td><div style="text-align: center;">Added kmean feature</div><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/arrow_down.png" class="" width="20"></td></tr><tr><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-3-0.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-3-1.png" class="" width="200"></td><td><img data-src="/2022/06/10/2022-06-10-adcanced-optimization/post-3-2.png" class="" width="200"></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>AdaBoost, 60-month data performance stratified plot</i></p><p>Again, let’s first look at the summary table. There are only two out of nine scenarios that have better annual returns after adopting the kmean clustering method. Our <code>profitability_of_the_company</code> factor doesn’t seem to be an effective way to raise the probability of win rate in the trading strategy. Fortunately, the experiment doesn’t have to stop right here. There are hundreds of features that we can test and try to see how to produce an effective, explainable feature that corresponds to our trading idea.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Among all three feature engineering techniques that we have adopted into our strategy, it seems that <strong>One-hot encodes</strong> the <code>industry</code> feature does enhance the predicting ability in our trading model. On the other hand, we can use <strong>KNNImputer</strong> as an alternative for <strong>SimpleImputer</strong>, and maybe try more combinations to create our new feature from the existing features.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/06/10/2022-06-10-adcanced-optimization/cover.jpeg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;Photo by &lt;a href=&quot;https://medium.com/r?url=https%3A%2F%2Funsplash.com%2F%40brett_jordan%3Futm_source%3Dmedium%26utm_medium%3Dreferral&quot;&gt;Brett Jordan&lt;/a&gt; on &lt;a href=&quot;https://medium.com/r/?url=https%3A%2F%2Funsplash.com%3Futm_source%3Dmedium%26utm_medium%3Dreferral&quot;&gt;Unsplash&lt;/a&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;From the &lt;a href=&quot;https://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/&quot;&gt;previous article&lt;/a&gt;, we’ve learned several indicators that we can calculate and use to evaluate the performances of your algorithm trading strategies. Given these indicators, we’re able to see how we can further polish our strategy and make it more seemingly profitable. Therefore, let’s work on our features to see how we can improve our machine learning trading strategy.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    <category term="Machine Learning" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/Machine-Learning/"/>
    
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>Looking for no-loss trading strategy? Here&#39;s the strategy that you should look at.</title>
    <link href="http://mikelhsia.github.io/2022/04/18/2022-04-20-forex-grid-trading-system/"/>
    <id>http://mikelhsia.github.io/2022/04/18/2022-04-20-forex-grid-trading-system/</id>
    <published>2022-04-18T04:03:36.000Z</published>
    <updated>2022-04-21T07:47:00.621Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/grid_system.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><p>Grid trading strategy is famous for its simplicity and ease of execution, and you don’t even have to guess where the market is going. No technical analysis and indicators are needed or recognize any patterns among endless candlesticks. It was once known as the <em>‘no-loss strategy’</em>.</p><p>But, is this true that there is a strategy that causes you no risk?</p><p>Today we’re going to look at what grid trading strategy is about, and we will conduct a series of backtesting against the Forex market to see whether it is the holy grail of our trading strategies.</p><a id="more"></a><hr><h1 id="Talking"><a href="#Talking" class="headerlink" title="Talking"></a>Talking</h1><h2 id="Forex-FX-and-Forex-trading"><a href="#Forex-FX-and-Forex-trading" class="headerlink" title="Forex (FX) and Forex trading"></a>Forex (FX) and Forex trading</h2><p><strong>Forex (FX)</strong> is short for Foreign Exchange, which is the global electronic marketplace for proprietary institutions or public companies/individuals to trade international currencies and currency derivatives. Prior to the Internet age, trading in the forex market is exclusive to large financial institutions, corporations, central banks, hedge funds, and extremely wealthy individuals as the information isn’t public and timely enough for the rest of the people. Once the internet emerged, the availability of the information empowers any individual to trade the foreign currency at a fair price whenever they need to. For example, if you’re living in the UK and you would like to buy a piece of furniture from the states, you want the furniture to be received in China and then pay the money to the US dealers. Hence, you need to convert your GBP to USD on the Forex market so that you can pay USD to the US dealers.</p><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/exchange.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. I. International tradings require foreign currency exchange</i></p><p>There are a few things that the Forex market differs from the stock markets:</p><ol><li>Forex opens 24/7, therefore the exchange rate changes even during weekends.</li><li>The Forex brokerages open only within a specific timeframe, meaning your investment could variate drastically and you cannot do anything about it if you own the overnight positions.</li><li>The currencies traded on the market in pairs, such as EUR/USD, AUD/JPY, GBP/CAD, …. For example, EUR/USD’s current quote is at 1.0791, meaning you would be able to buy 1 Euro with 1.0791 USD.</li><li>As the Forex rate volatility is relatively way smaller than the equity stocks, most of the Forex agencies provide a leveraged account that allows you to play leveraged trade in the Forex market.</li></ol><p>As the example illustrated above, there will be people or institutions who demand specific currencies to fulfill their personal or business needs. Therefore, as an individual investor, you are able to offer your capital there with an exchange rate $r_{Today}$ for anyone who needs your capital. By the time you need your capital back into your pocket, you then go to the market and recall your investment with the exchange rate $r_{Later}$. What’s in for you? When the invested currency goes higher, you will be able to earn the difference between $r_{Today}$ and $r_{Later}$ while converting that currency back to the currency you own. The loss would also incur if the exchange rate goes in the opposite direction.</p><p>That being said, trading foreign exchange is actually pretty similar to trading equity in the stock market. You always try to buy low and sell high.</p><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/Forex_trading.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. II. The historical candlesticks diagram of GBP/CHF</i></p><h2 id="Forex-grid-trading-strategy"><a href="#Forex-grid-trading-strategy" class="headerlink" title="Forex grid trading strategy"></a>Forex grid trading strategy</h2><p>The grid trading system’s central idea is to build a <em>“price grid”</em> around the reference quote price, usually yesterday’s close price, and buy (long/short) when the price trigger one of the bars in your grid and closes the position when you have gained a small piece of the profit. You trade like that when the price moves up and down over and over again. In the end, you’ll be able to accumulate small pieces into a big chunk of profit. This essentially is an extended version of the <em>“mean-reversion trading strategy”</em>. <a href="https://quantpedia.com/">Quantpedia</a> has a very nice piece to articulate what a grid trading system is about <a href="https://quantpedia.com/a-primer-on-grid-trading-strategy/">here</a>.</p><p>Let’s visualize the grid trading system so that it’s easier to understand:</p><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/grid_system.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. III. The grid trading system</i></p><p>The above trading system deploys three bars above the reference price and three below. Each bar has the same distance from the other. If the price first goes bearish and hit the bottom of the day, by that time we will have already three long positions purchased at prices <em>b1, b2, and b3</em>. Once the market starts reversing and the price goes above the reference price bar, three orders will be sold at prices <em>s1, s2, and s3</em> respectively. In this case, you will make $\text{(s1-b1) + (s2-b2) + (s3-b3)}$ as your total return.</p><p>The uptrend continues, you’ll build another three short positions <em>b’1, b’2, and b’3</em> when the price reaches today’s high. These three positions will be closed when the price drop below the reference price.</p><p>I believe you now get the idea. The two essential ideas of this trading strategy are:</p><ol><li>The more fluctuation in price, the more we profit.</li><li>The average price should stay relatively stable without soaring or plummeting too fast.</li></ol><p>The below chart is extracted from one of my backtest, and it perfectly illustrates what kind of trend we’re looking for to profit from implementing the grid trading strategy.<br><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/desire_trend.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. IV. The grid trading system</i></p><p>Most people believe the foreign exchange market is the best place that fit the two conditions we describe above. That’s why we’re going to backtest the grid trading strategy using Forex. Also, since the rules are relatively clear and simple, that makes the grid trading strategy is the best candidate to run/trade automatically with several of the conditions in place beforehand.</p><hr><h1 id="Doing"><a href="#Doing" class="headerlink" title="Doing"></a>Doing</h1><h2 id="Strategy-implementation"><a href="#Strategy-implementation" class="headerlink" title="Strategy implementation"></a>Strategy implementation</h2><h3 id="Strategy-setups-for-our-backtests"><a href="#Strategy-setups-for-our-backtests" class="headerlink" title="Strategy setups for our backtests"></a>Strategy setups for our backtests</h3><p>Let’s first start with identifying the parameters we need in this strategy:</p><ul><li><strong>Reference price</strong><ul><li>We use the close price before the previous market closed.</li></ul></li><li><strong>Grid number</strong><ul><li>10 bars above the reference price bar, and 10 bars below the reference price bar</li></ul></li><li><strong>Grid range</strong><ul><li>Grid range indicates the price range that we’re monitoring. We deploy the 20 bars across this price range. Therefore, setting a proper range would be critical to the system. If you have a pretty wide gap between bars, you’ll get fewer triggers when the price moves. On the contrary, if you have a fairly narrow gap, the price could easily penetrate your grid range and never fall back to where it was, causing a huge cost to your portfolio.</li><li>Here we use 2 times the standard deviation of the close price in the past three months as our grid range.</li></ul></li><li><strong>Leverage ratio</strong><ul><li>Most of the Forex brokerages offer N<em> leveraged accounts, meaning you’ll be able to deposit 1 dollar in your account and invest 1 </em> N dollars in the Forex market. For example, <a href="https://www.oanda.com/apply/?lang=zh-tw">Oanda</a> offers 100x leveraged account type to premium customers. In this example, let’s set it to 50x for now.</li></ul></li><li><strong>Position allocation</strong><ul><li>We have set up two different methods to allocate your assets in each bar:<ul><li><strong>Average</strong>: We allocate the same amount of capital to each order on every bar.</li><li><strong>Double down</strong>: As the current quote price goes further away from the reference price, we double down the amount of the position in each order. Let’s take <strong><em>Ill. III. The grid trading system</em></strong> for example, in limit order b1 and b’1, we placed 1 hand, in b2 and b’2 we place 2 hands, and in b3 and b’3 we place 4 hands. [1, 2, 4, 8, 16, ….]</li></ul></li></ul></li></ul><h3 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h3><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h3 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h3><p>I’m not going to use the concept of the <code>universe</code> in the backtesting of this strategy. Instead, I’m going to backtest the following foreign currency pair to see which currency pair best fits the nature of the grid trading strategy.</p><ul><li>GBP/CHF</li><li>AUD/CAD</li><li>GBP/CAD</li><li>USD/JPY</li><li>AUD/JPY</li><li>EUR/GBP</li><li>GBP/USD</li></ul><h3 id="Backtest-time-frame"><a href="#Backtest-time-frame" class="headerlink" title="Backtest time frame"></a>Backtest time frame</h3><p><strong>Backtest Date:</strong> <code>2021, 1 ,1</code> ~ <code>2022, 4, 16</code></p><h3 id="Signal-generation"><a href="#Signal-generation" class="headerlink" title="Signal generation"></a>Signal generation</h3><p>The triggering signal is very straightforward. As I mentioned in the <strong>Forex grid trading strategy</strong> section, the long/short limit order will be automatically triggered when the current close price touches the grid bar. However, in order to simplify the logic and to make everything automated so that the order can be generated in a timely manner, I’ve added my own tweaks to this grid trading system.</p><p>Referring to chart in <strong><em>Ill. III. The grid trading system</em></strong>, we see [b1, s1], [b2, s2], …, [b’1, s’1], [b’2, s’2], … as order pair. The first one in the pair is the long/short limit orders that we will place before the market starts. As long as any of the limit orders is fulfilled, the second one in the pair will be automatically triggered and generate another limit order waiting to close that position in order to gain profit. Vice versa, the fulfillment of the second limit order in the pair will also trigger the system to generate another open limit order waiting to catch the next opportunity. By doing this, we just need to set up 10 pairs of these on the long side and 10 pairs of these on the short side. See the following image for a quick illustration.</p><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/system_detail.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. V. The grid trading system - system detail</i></p><p>On the monthly basis, we will create 20 pairs of these to catch any movement. By the end of the month, we cancel all these open orders and close all the positions we hold. Then the next day before the market open, we readjust our reference price and recalculate the standard deviation of the past 90 days again as our grid range. By doing this, we’re going to make sure the current price won’t drift too far away from our grid if there’s a bull or bear market in the currency we’re trading against.</p><p>Stop-loss control is also a crucial part to be installed in every trading system. I’m placing three different scenarios of stop loss to see how they work out:</p><ul><li><strong>Don’t stop loss at all</strong>: <code>Let the profit fly</code>. We don’t set up any stop-loss point.</li><li><strong>Normal top loss</strong>: We monitor the distance between the current price and the reference price. If the current price deviates away from the reference price by over 20%, then we can reckon that there’s either an uptrend or downtrend that happens, which could cause a huge loss to our portfolio. If this happens, we liquidate all holding positions and close the rest of the opening limit orders. We’re not going to do any trade that month.</li><li><strong>Stop loss and rescale</strong>: In this scenario, right after we liquidate all existing positions and cancel open orders, we readjust all the parameters, including reference price and grid range, and deploy the grid again using the updated parameters instead of ceasing all the trading activities. We hope doing this would help us capture the new opportunities as soon as possible after the momentum of price rising/dropping ends.</li></ul><h2 id="Backtest-result"><a href="#Backtest-result" class="headerlink" title="Backtest result"></a>Backtest result</h2><div class="table-container"><table><thead><tr><th><strong>Currency</strong></th><th><strong>Level_method</strong></th><th><strong>Vol_method</strong></th><th><strong>Stop_loss</strong></th><th><strong>Rescale</strong></th><th><strong>Return</strong></th><th><strong>PSR</strong></th><th><strong>MDD</strong></th><th><strong>Total_trades</strong></th><th><strong>Sharpe_ratio</strong></th><th><strong>Win_rate</strong></th></tr></thead><tbody><tr><td>GBPCHF</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>83.33%</td><td>42.549%</td><td>80%</td><td>1446</td><td>1.264</td><td>74%</td></tr><tr><td>GBPCHF</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>18.68%</td><td>22.167%</td><td>72%</td><td>1104</td><td>0.478</td><td>72%</td></tr><tr><td>GBPCHF</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-6.34%</td><td>13.999%</td><td>74.3%</td><td>1531</td><td>0.218</td><td>71%</td></tr><tr><td>GBPCHF</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-76.1%</td><td>24.781%</td><td>99.5%</td><td>5574</td><td>0.856</td><td>71%</td></tr><tr><td>GBPCHF</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-16.05%</td><td>6.052%</td><td>39.7%</td><td>2087</td><td>-0.129</td><td>71%</td></tr><tr><td>GBPCHF</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-91.48%</td><td>0.027%</td><td>94.2%</td><td>8288</td><td>-0.928</td><td>70%</td></tr><tr><td>GBPCHF</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>11.72%</td><td>24.113%</td><td>70.4%</td><td>1442</td><td>0.587</td><td>97%</td></tr><tr><td>GBPCHF</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-24.58%</td><td>0.686%</td><td>35%</td><td>1104</td><td>-0.635</td><td>98%</td></tr><tr><td>GBPCHF</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-33.25%</td><td>0.323%</td><td>43.1%</td><td>1531</td><td>-0.763</td><td>97%</td></tr><tr><td>GBPCHF</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-61.84%</td><td>19.401%</td><td>98.6%</td><td>5573</td><td>0.477</td><td>94%</td></tr><tr><td>GBPCHF</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>11.68%</td><td>19.159%</td><td>21.1%</td><td>2087</td><td>0.38</td><td>96%</td></tr><tr><td>GBPCHF</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-62.32%</td><td>0.883%</td><td>96%</td><td>8288</td><td>-0.755</td><td>96%</td></tr><tr><td>AUDCAD</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>16.9%</td><td>21.526%</td><td>42.4%</td><td>959</td><td>0.473</td><td>66%</td></tr><tr><td>AUDCAD</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-24.29%</td><td>5.07%</td><td>49.1%</td><td>814</td><td>-0.187</td><td>68%</td></tr><tr><td>AUDCAD</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-24.44%</td><td>5.904%</td><td>56.2%</td><td>1056</td><td>-0.138</td><td>69%</td></tr><tr><td>AUDCAD</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-41.20%</td><td>10.311%</td><td>74.3%</td><td>4368</td><td>0.074</td><td>73%</td></tr><tr><td>AUDCAD</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-40.6%</td><td>0.005%</td><td>43.2%</td><td>1467</td><td>-1.261</td><td>69%</td></tr><tr><td>AUDCAD</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-78.65%</td><td>0.041%</td><td>88.9%</td><td>8324</td><td>-1.105</td><td>71%</td></tr><tr><td>AUDCAD</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>41.58%</td><td>32.301%</td><td>34.1%</td><td>959</td><td>0.764</td><td>98%</td></tr><tr><td>AUDCAD</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-4.95%</td><td>8.28%</td><td>21.7%</td><td>814</td><td>-0.017</td><td>98%</td></tr><tr><td>AUDCAD</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-8.17%</td><td>6.912%</td><td>32.1%</td><td>1096</td><td>-0.082</td><td>98%</td></tr><tr><td>AUDCAD</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>35.42%</td><td>28.118%</td><td>67.7%</td><td>4368</td><td>0.704</td><td>96%</td></tr><tr><td>AUDCAD</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-21.32%</td><td>0.265%</td><td>28.5%</td><td>1467</td><td>-0.934</td><td>98%</td></tr><tr><td>AUDCAD</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-49.27%</td><td>0.509%</td><td>65.8%</td><td>8324</td><td>-0.931</td><td>97%</td></tr><tr><td>GBPCAD</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>97.54%</td><td>49.78%</td><td>43.5%</td><td>1250</td><td>1.278</td><td>74%</td></tr><tr><td>GBPCAD</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>109.54%</td><td>65.971%</td><td>19.7%</td><td>1203</td><td>1.661</td><td>75%</td></tr><tr><td>GBPCAD</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>156%</td><td>78.098%</td><td>24.1%</td><td>1382</td><td>2.131</td><td>75%</td></tr><tr><td>GBPCAD</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>137.75%</td><td>49.858%</td><td>52.5%</td><td>5632</td><td>1.473</td><td>73%</td></tr><tr><td>GBPCAD</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-17.27%</td><td>2.41%%</td><td>30.2%</td><td>1913</td><td>-0.394</td><td>71%</td></tr><tr><td>GBPCAD</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-65.19%</td><td>0.226%</td><td>71.2%</td><td>8459</td><td>-0.971</td><td>73%</td></tr><tr><td>GBPCAD</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>25.43%</td><td>24.555%</td><td>39.1%</td><td>1250</td><td>0.564</td><td>99%</td></tr><tr><td>GBPCAD</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>28.3%</td><td>39.133%</td><td>12.2%</td><td>1203</td><td>0.865%</td><td>99%</td></tr><tr><td>GBPCAD</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>48.86%</td><td>58.341</td><td>10.7%</td><td>1382</td><td>1.296</td><td>99%</td></tr><tr><td>GBPCAD</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>255.36%</td><td>69.083%</td><td>55.7%</td><td>5632</td><td>2.202</td><td>97%</td></tr><tr><td>GBPCAD</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-8.46%</td><td>3.877%</td><td>20.6%</td><td>1913</td><td>-0.276</td><td>98%</td></tr><tr><td>GBPCAD</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-45.97%</td><td>0.601%</td><td>55%</td><td>8459</td><td>-0.982</td><td>98%</td></tr><tr><td>USDJPY</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-1.72%</td><td>0.014%</td><td>2.1%</td><td>805</td><td>-1.603</td><td>71%</td></tr><tr><td>USDJPY</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-0.22%</td><td>2.848%</td><td>0.6%</td><td>785</td><td>-0.373</td><td>72%</td></tr><tr><td>USDJPY</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-0.42%</td><td>1.26%</td><td>0.7%</td><td>1135</td><td>-0.596</td><td>72%</td></tr><tr><td>USDJPY</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-2.13%</td><td>0.062%</td><td>2.3%</td><td>4548</td><td>-1.347</td><td>72%</td></tr><tr><td>USDJPY</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-0.41%</td><td>0.020%</td><td>0.4%</td><td>1455</td><td>-1.242</td><td>72%</td></tr><tr><td>USDJPY</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-1.56%</td><td>0.001%</td><td>1.7%</td><td>8251</td><td>-2.611</td><td>71%</td></tr><tr><td>USDJPY</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-1.68%</td><td>0.006%</td><td>2%</td><td>805</td><td>-1.76%</td><td>98%</td></tr><tr><td>USDJPY</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-0.22%</td><td>0.74%</td><td>0.4%</td><td>785</td><td>-0.65</td><td>97%</td></tr><tr><td>USDJPY</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-0.37%</td><td>0.169%</td><td>0.5%</td><td>1135</td><td>-0.931</td><td>97%</td></tr><tr><td>USDJPY</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-1.91%</td><td>0.057%</td><td>2.3%</td><td>4548</td><td>-1.355</td><td>94%</td></tr><tr><td>USDJPY</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-0.24%</td><td>0.17%</td><td>0.3%</td><td>1455</td><td>-1.081</td><td>98%</td></tr><tr><td>USDJPY</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-0.58%</td><td>0.512%</td><td>0.8%</td><td>8251</td><td>-1.342</td><td>96%</td></tr><tr><td>AUDJPY</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-2.51%</td><td>0.048%</td><td>3.4%</td><td>621</td><td>-1.314</td><td>67%</td></tr><tr><td>AUDJPY</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-0.78%</td><td>1.384%</td><td>1.5%</td><td>573</td><td>-0.597</td><td>67%</td></tr><tr><td>AUDJPY</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-1.55%</td><td>0.23%</td><td>2.3%</td><td>898</td><td>-1.013</td><td>67%</td></tr><tr><td>AUDJPY</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-4.13%</td><td>0.032%</td><td>5%</td><td>3883</td><td>-1.45</td><td>71%</td></tr><tr><td>AUDJPY</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-0.78%</td><td>0.003%</td><td>0.9%</td><td>1303</td><td>-1.446</td><td>67%</td></tr><tr><td>AUDJPY</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-2.56%</td><td>0.001%</td><td>3%</td><td>8211</td><td>-2.624</td><td>70%</td></tr><tr><td>AUDJPY</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-2.05%</td><td>0.048%</td><td>2.9%</td><td>621</td><td>-1.287</td><td>97%</td></tr><tr><td>AUDJPY</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-0.33%</td><td>2.78%</td><td>0.7%</td><td>573</td><td>-0.415</td><td>96%</td></tr><tr><td>AUDJPY</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>-0.71%</td><td>0.632%</td><td>1.1%</td><td>898</td><td>-0.8</td><td>96%</td></tr><tr><td>AUDJPY</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-3.47%</td><td>0.057%</td><td>4.4%</td><td>3883</td><td>-1.334</td><td>93%</td></tr><tr><td>AUDJPY</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-0.41%</td><td>0.174%</td><td>0.6%</td><td>1303</td><td>-1.09</td><td>97%</td></tr><tr><td>AUDJPY</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-1%</td><td>0.263%</td><td>1.6%</td><td>8211</td><td>-1.495</td><td>97%</td></tr><tr><td>EURGBP</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>193.48%</td><td>55.86%</td><td>59.3%</td><td>1342</td><td>1.777</td><td>69%</td></tr><tr><td>EURGBP</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>184.33%</td><td>64.133%</td><td>53.2%</td><td>1325</td><td>1.84</td><td>70%</td></tr><tr><td>EURGBP</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>236.89%</td><td>71.59%</td><td>50.1%</td><td>1451</td><td>2.168%</td><td>71%</td></tr><tr><td>EURGBP</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-73.2%</td><td>14.02%</td><td>94.5%</td><td>4041</td><td>0.244</td><td>69%</td></tr><tr><td>EURGBP</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-66.65%</td><td>0%</td><td>67.4%</td><td>1120</td><td>-1.394</td><td>63%</td></tr><tr><td>EURGBP</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-91.09%</td><td>0.013%</td><td>91.2%</td><td>8343</td><td>-0.948</td><td>70%</td></tr><tr><td>EURGBP</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>255.97%</td><td>71.420%</td><td>42.5%</td><td>1339</td><td>2.178</td><td>98%</td></tr><tr><td>EURGBP</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>216.28%</td><td>93.866%</td><td>19.4%</td><td>1325</td><td>2.811</td><td>98%</td></tr><tr><td>EURGBP</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>226.02%</td><td>94.772%</td><td>19.4%</td><td>1451</td><td>2.905</td><td>98%</td></tr><tr><td>EURGBP</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-36.14%</td><td>20.836%</td><td>91.2%</td><td>4037</td><td>0.53</td><td>96%</td></tr><tr><td>EURGBP</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-48.93%</td><td>0%</td><td>49.4%</td><td>1120</td><td>-1.949</td><td>97%</td></tr><tr><td>EURGBP</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-73.37%</td><td>0.084%</td><td>73.4%</td><td>8343</td><td>-1.016</td><td>96%</td></tr><tr><td>GBPUSD</td><td>average</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-21.81%</td><td>13.698%</td><td>75.7%</td><td>814</td><td>0.223</td><td>72%</td></tr><tr><td>GBPUSD</td><td>average</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>-0.3%</td><td>15.694%</td><td>63.5%</td><td>783</td><td>0.301</td><td>74%</td></tr><tr><td>GBPUSD</td><td>average</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>37.20%</td><td>27.093%</td><td>52.8%</td><td>1016</td><td>0.678</td><td>76%</td></tr><tr><td>GBPUSD</td><td>average</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-60.85%</td><td>12.303%</td><td>91.1%</td><td>5090</td><td>0.169</td><td>73%</td></tr><tr><td>GBPUSD</td><td>average</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-39.26%</td><td>0.47%</td><td>47.2%</td><td>1651</td><td>-0.744</td><td>71%</td></tr><tr><td>GBPUSD</td><td>average</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-90.26%</td><td>0.002%</td><td>93.4%</td><td>8325</td><td>-1.192</td><td>70%</td></tr><tr><td>GBPUSD</td><td>double</td><td>STD</td><td>FALSE</td><td>FALSE</td><td>-2.78%</td><td>15.241%</td><td>55.2%</td><td>814</td><td>0.276%</td><td>98%</td></tr><tr><td>GBPUSD</td><td>double</td><td>STD</td><td>TRUE</td><td>FALSE</td><td>11.13%</td><td>17.60%</td><td>40%</td><td>785</td><td>0.355</td><td>98%</td></tr><tr><td>GBPUSD</td><td>double</td><td>STD</td><td>TRUE</td><td>TRUE</td><td>13.85%</td><td>18.86%</td><td>38.6%</td><td>1018</td><td>0.395</td><td>98%</td></tr><tr><td>GBPUSD</td><td>double</td><td>ATR</td><td>FALSE</td><td>FALSE</td><td>-15.88%</td><td>20.194%</td><td>89.3%</td><td>5090</td><td>0.472</td><td>93%</td></tr><tr><td>GBPUSD</td><td>double</td><td>ATR</td><td>TRUE</td><td>FALSE</td><td>-19.0%</td><td>2.947%</td><td>38.5%</td><td>1651</td><td>-0.378</td><td>97%</td></tr><tr><td>GBPUSD</td><td>double</td><td>ATR</td><td>TRUE</td><td>TRUE</td><td>-71.33%</td><td>0.1%</td><td>83.4%</td><td>8325</td><td>-1.181</td><td>98%</td></tr></tbody></table></div><h2 id="Post-analysis"><a href="#Post-analysis" class="headerlink" title="Post-analysis"></a>Post-analysis</h2><p>Across all scenarios and all foreign currency pairs, we can see that the strategy returns range from <font color='green'>230%</font> to <font color='red'>-90%</font>. The Sharpe ratios range from <font color='green'>2.2</font> to <font color='red'>-2.6</font>. It seems that the grid trading strategy is not very stable in terms of capturing profit. On the other hand, not surprising that the win rate is as high as 70% to 97%. These stats can clearly infer that our strategy can efficiently capture the profit when the price fluctuates. Sadly those trades that didn’t win actually cause us humongous losses.</p><p>Let’s do another round of analysis to look into the details of all the scenarios.</p><p>First, let’s look at the difference between using standard deviation and using <a href="https://www.investopedia.com/terms/a/atr.asp">ATR (Average True Range)</a> indicator as our grid range. Apparently, the standard deviation is more outstanding in terms of predicting the proper range of price change.<br><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/std_vs_atr.png" class="" width="400"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. VI. STD v.s. ATR on Returns (%)</i></p><p>We don’t see much difference between using average allocation and double down allocation to control our position allocation on each bar.<br><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/ave_vs_dou.png" class="" width="400"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. VII. Average allocation v.s. double down allocation on Returns (%)</i></p><p>Lastly, let’s take a look at whether the stop-loss mechanism will help improve the quality of our trades. The strategy returns in all scenarios unanimously reduced a great certain percentage. In the meantime, the MDD (Max Drop Down) was also greatly reduced when applying the stop loss method. Unexpectedly, the stop loss and rescale method even deteriorate both the strategy return and MDD compared to the scenarios applying the stop-loss method.<br><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/stoploss.png" class="" width="400"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. VIII. Stoploss on Returns (%)</i></p><img data-src="/2022/04/18/2022-04-20-forex-grid-trading-system/stoploss_mdd.png" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Ill. VIII. Stoploss on MDD (%)</i></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In short, the grid trading strategy has done what we ask it to capture all the profitable opportunities when the price fluctuates among our monitoring grid range. However, when the price moves in one direction in a short period of time, the potential cost could cost us the entire portfolio. The global economy and international politics are the origins of this sudden price change which we cannot predict. Unless we’re able to produce a stop loss method or hedge instrument to help us mitigate the risk and endure the sudden price movement, the grid trading strategy wouldn’t be able to help us consistently capture the <strong>risk-free</strong> profit.</p><p>To do that, here are a few topics that we can explore to further optimize our grid trading strategy:</p><ul><li>Better stop loss method</li><li>Using technical indicators to help identify and avoid the upward/downward trends.</li><li>Try to experiment with different foreign currency pairs, as each currency pair has its own characteristic. Some possess high volatility, and some are relatively stable.</li></ul><p>That’ll be all for this post. Cheers.</p><hr><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://quantpedia.com/a-primer-on-grid-trading-strategy/">A primer on grid trading strategy</a></li><li><a href="https://quantpedia.com/whats-the-relation-between-grid-trading-and-delta-hedging/">What’s the relation between grid trading and delta hedging</a></li><li><a href="http://blog.sina.com.cn/s/blog_69e73f710100kd6x.html">Fundamental of grid trading strategy</a></li><li><a href="https://forexwithanedge.com/grid-trading/">Grid trading</a></li><li><a href="https://baijiahao.baidu.com/s?id=1703235910517684547&amp;wfr=spider&amp;for=pc">How to pick the right currency pair to trade as a Forex beginners?</a></li><li><a href="https://www.youtube.com/watch?v=fHPPnZcsDEo">Grid trading bot Part 2</a></li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">from datetime import datetime</span><br><span class="line">import re</span><br><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">class ReferenceType(Enum):</span><br><span class="line">    AVERAGE &#x3D; 1</span><br><span class="line">    PREVIOUS_CLOSE &#x3D; 2</span><br><span class="line"></span><br><span class="line">class VolatilityType(Enum):</span><br><span class="line">    STANDARD_DEVIATION &#x3D; 1</span><br><span class="line">    HIGH_LOW &#x3D; 2    # This trigger very little orders, ineffective.</span><br><span class="line">    ATR &#x3D; 3</span><br><span class="line"></span><br><span class="line">class PositionAmountType(Enum):</span><br><span class="line">    AVERAGE &#x3D; 1</span><br><span class="line">    INCREMENTAL &#x3D; 2</span><br><span class="line">    DOUBLEUP &#x3D; 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FXMomentumAlgorithm(QCAlgorithm):</span><br><span class="line">    def Initialize(self):</span><br><span class="line">        self.SetStartDate(2020, 12, 28)</span><br><span class="line">        # self.SetStartDate(2017, 12, 28)</span><br><span class="line">        self.SetEndDate(datetime.now())</span><br><span class="line">        self.SetCash(100000)</span><br><span class="line">        self.resolution &#x3D; Resolution.Minute</span><br><span class="line">        self._grid_number &#x3D; 10</span><br><span class="line">        self._leverage_ratio &#x3D; 50</span><br><span class="line">        self._reference_price &#x3D; None</span><br><span class="line">        self._std &#x3D; None</span><br><span class="line">        self._stop_loss &#x3D; None</span><br><span class="line">        self._cash_preserve_ratio &#x3D; 0.99</span><br><span class="line">        self._cash_per_position &#x3D; None</span><br><span class="line"></span><br><span class="line">        self.IS_READY &#x3D; False</span><br><span class="line">        self.REFERENCE_PRICE_METHOD &#x3D; ReferenceType.PREVIOUS_CLOSE</span><br><span class="line">        self.POSITION_AMOUNT_METHOD &#x3D; PositionAmountType.AVERAGE</span><br><span class="line">        self.VOLATILITY_METHOD &#x3D; VolatilityType.STANDARD_DEVIATION</span><br><span class="line">        self.VOLATILITY_MULTIPLIER &#x3D; 2</span><br><span class="line">        self.STOP_LOSS_MODE &#x3D; False</span><br><span class="line">        self.STOP_LOSS_RESCALE &#x3D; False</span><br><span class="line">        self.STOP_LOSS_MULTIPLIER &#x3D; 1.2 # 10% more on upper side and 10% less on lower side</span><br><span class="line"></span><br><span class="line">        # self.pair &#x3D; &#39;GBPCHF&#39;</span><br><span class="line">        # self.pair &#x3D; &#39;AUDCAD&#39;</span><br><span class="line">        # self.pair &#x3D; &#39;GBPCAD&#39;</span><br><span class="line">        # self.pair &#x3D; &#39;USDJPY&#39;</span><br><span class="line">        # self.pair &#x3D; &#39;AUDJPY&#39;</span><br><span class="line">        self.pair &#x3D; &#39;EURGBP&#39;</span><br><span class="line">        # self.pair &#x3D; &#39;GBPUSD&#39;</span><br><span class="line"></span><br><span class="line">        self.forex &#x3D; self.AddForex(</span><br><span class="line">            self.pair,</span><br><span class="line">            self.resolution,</span><br><span class="line">            Market.Oanda,</span><br><span class="line">            True,</span><br><span class="line">            self._leverage_ratio</span><br><span class="line">        )</span><br><span class="line">        # self.Debug(f&#39;Our Leverage: &#123;self.forex.MarginModel.GetLeverage(self.forex)&#125;&#39;)</span><br><span class="line"></span><br><span class="line">        ################################################</span><br><span class="line">        # Adding Schedule event</span><br><span class="line">        self.Schedule.On(</span><br><span class="line">            self.DateRules.MonthStart(self.pair),</span><br><span class="line">            self.TimeRules.AfterMarketOpen(self.pair, 0),</span><br><span class="line">            self.openMarket</span><br><span class="line">        )</span><br><span class="line">        self.Schedule.On(</span><br><span class="line">            self.DateRules.MonthEnd(self.pair),</span><br><span class="line">            self.TimeRules.BeforeMarketClose(self.pair, 5),</span><br><span class="line">            self.closeMarket</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def OnData(self, data):</span><br><span class="line">        if not self.IS_READY or self.pair not in data:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        if not self.STOP_LOSS_MODE:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # Stop loss</span><br><span class="line">        if data[self.pair].Close &lt; (self._reference_price - self._stop_loss) or data[self.pair].Close &gt; (self._reference_price + self._stop_loss):</span><br><span class="line">            # self.Debug(f&#39;&#123;self.Time&#125;: Break out and clean the open orders&#39;)</span><br><span class="line">            # Liquidate all positions and close all open orders</span><br><span class="line">            self.Liquidate(self.pair)</span><br><span class="line">            if self.STOP_LOSS_RESCALE:</span><br><span class="line">                self.openMarket()</span><br><span class="line"></span><br><span class="line">    def setParameters(self):</span><br><span class="line">        history &#x3D; self.History([self.pair], 93, Resolution.Daily)</span><br><span class="line">        history &#x3D; history.droplevel(0)</span><br><span class="line"></span><br><span class="line">        # Set up reference price</span><br><span class="line">        if self.REFERENCE_PRICE_METHOD &#x3D;&#x3D; ReferenceType.PREVIOUS_CLOSE:</span><br><span class="line">            # Get close of previous day</span><br><span class="line">            self._reference_price &#x3D; self.History(</span><br><span class="line">                [self.pair],</span><br><span class="line">                2880,</span><br><span class="line">                Resolution.Minute</span><br><span class="line">            ).droplevel(0).close[-1]</span><br><span class="line">        elif self.REFERENCE_PRICE_METHOD &#x3D;&#x3D; ReferenceType.AVERAGE:</span><br><span class="line">            # Daily moving average</span><br><span class="line">            self.Debug(&#39;Average mean&#39;)</span><br><span class="line">            self._reference_price &#x3D; history.close[-20:].mean()</span><br><span class="line"></span><br><span class="line">        # Cash amount per position</span><br><span class="line">        if self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.AVERAGE:</span><br><span class="line">            # Leveraged Equal weighted</span><br><span class="line">            self._cash_per_position &#x3D; (self.Portfolio.MarginRemaining * self._leverage_ratio * self._cash_preserve_ratio) &#x2F; (self._grid_number * 2)</span><br><span class="line">        elif self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.INCREMENTAL:</span><br><span class="line">            # Leveraged incremental weighted</span><br><span class="line">            self._cash_per_position &#x3D; (self.Portfolio.MarginRemaining * self._leverage_ratio * self._cash_preserve_ratio) &#x2F; (sum(range(1, self._grid_number+1)) * 2)</span><br><span class="line">        elif self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.DOUBLEUP:</span><br><span class="line">            # Leveraged double up weighted</span><br><span class="line">            self._cash_per_position &#x3D; (self.Portfolio.MarginRemaining * self._leverage_ratio * self._cash_preserve_ratio) &#x2F; ((2**self._grid_number - 1) * 2)</span><br><span class="line"></span><br><span class="line">        # Get volatility of previous day</span><br><span class="line">        if self.VOLATILITY_METHOD &#x3D;&#x3D; VolatilityType.STANDARD_DEVIATION:</span><br><span class="line">            # The 2 * Standardization &#x3D; 95%</span><br><span class="line">            self._std &#x3D; history.close.std() * self.VOLATILITY_MULTIPLIER</span><br><span class="line">        elif self.VOLATILITY_METHOD &#x3D;&#x3D; VolatilityType.HIGH_LOW:</span><br><span class="line">            # The high and low of the previous market open day</span><br><span class="line">            self._std &#x3D; abs(history.high.max() - history.low.min())</span><br><span class="line">        elif self.VOLATILITY_METHOD &#x3D;&#x3D; VolatilityType.ATR:</span><br><span class="line">            # ATR</span><br><span class="line">            self._std &#x3D; ta.ATR(history.high, history.low, history.close, timeperiod&#x3D;60)[-1]</span><br><span class="line"></span><br><span class="line">        self._stop_loss &#x3D; self._std * self.STOP_LOSS_MULTIPLIER</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def openMarket(self):</span><br><span class="line">        # self.Debug(f&#39;&#123;self.Time&#125; Market open. Order number (&#123;len(self.Transactions.GetOpenOrders(self.pair))&#125;)&#39;)</span><br><span class="line">        self.setParameters()</span><br><span class="line"></span><br><span class="line">        # Cancel all open orders before creating new orders</span><br><span class="line">        self.Liquidate(self.pair)</span><br><span class="line"></span><br><span class="line">        # Set up the grid limit order</span><br><span class="line"></span><br><span class="line">        for i in range(1, self._grid_number + 1):</span><br><span class="line">            qty &#x3D; int(self._cash_per_position * self.get_qty_multiplier(i) &#x2F; (self._reference_price - self._std &#x2F; self._grid_number * i))</span><br><span class="line">            order &#x3D; self.LimitOrder(</span><br><span class="line">                self.pair,</span><br><span class="line">                qty,</span><br><span class="line">                round(self._reference_price - self._std &#x2F; self._grid_number * i, 5),</span><br><span class="line">                f&#39;Long&#123;i&#125;&#39;</span><br><span class="line">            )</span><br><span class="line">            qty &#x3D; int(self._cash_per_position * self.get_qty_multiplier(i) &#x2F; (self._reference_price + self._std &#x2F; self._grid_number * i))</span><br><span class="line">            order &#x3D; self.LimitOrder(</span><br><span class="line">                self.pair,</span><br><span class="line">                -qty,</span><br><span class="line">                round(self._reference_price + self._std &#x2F; self._grid_number * i, 5),</span><br><span class="line">                f&#39;Short&#123;i&#125;&#39;</span><br><span class="line">            )</span><br><span class="line">        self.IS_READY &#x3D; True</span><br><span class="line"></span><br><span class="line">    def closeMarket(self):</span><br><span class="line">        # self.Debug(f&#39;&#123;self.Time&#125; Market close&#39;)</span><br><span class="line"></span><br><span class="line">        # Liquidate all positions by the end of the day</span><br><span class="line">        self.Liquidate(self.pair)</span><br><span class="line"></span><br><span class="line">        # self.Debug(f&#39;&#123;self.Time&#125; Market close. Order number (&#123;len(self.Transactions.GetOpenOrders(self.pair))&#125;)&#39;)</span><br><span class="line"></span><br><span class="line">    def OnOrderEvent(self, orderEvent):</span><br><span class="line">        order &#x3D; self.Transactions.GetOrderById(orderEvent.OrderId)</span><br><span class="line">        if orderEvent.Status &#x3D;&#x3D; OrderStatus.Filled:</span><br><span class="line">            # self.Debug(</span><br><span class="line">            #     &quot;&#123;0&#125;: &#123;1&#125; (&#123;2&#125;)&quot;.format(</span><br><span class="line">            #         self.Time,</span><br><span class="line">            #         orderEvent,</span><br><span class="line">            #         order.Tag</span><br><span class="line">            #     )</span><br><span class="line">            # )</span><br><span class="line"></span><br><span class="line">            match &#x3D; re.match(r&#39;(.*)(\d+)(.*)$&#39;, order.Tag)</span><br><span class="line"></span><br><span class="line">            if not match:</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            if match.group(1) &#x3D;&#x3D; &#39;Long&#39;:</span><br><span class="line">                i &#x3D; int(match.group(2))</span><br><span class="line">                if match.group(3) &#x3D;&#x3D; &#39;-Liquidate&#39;:</span><br><span class="line">                    qty &#x3D; int(self._cash_per_position * self.get_qty_multiplier(i) &#x2F; (self._reference_price - self._std &#x2F; self._grid_number * i))</span><br><span class="line">                    self.LimitOrder(</span><br><span class="line">                        self.pair,</span><br><span class="line">                        qty,</span><br><span class="line">                        round(self._reference_price - self._std &#x2F; self._grid_number * i, 5),</span><br><span class="line">                        f&#39;Long&#123;match.group(2)&#125;&#39;</span><br><span class="line">                    )</span><br><span class="line">                else:</span><br><span class="line">                    if (i - 1) &#x3D;&#x3D; 0:</span><br><span class="line">                        self.LimitOrder(</span><br><span class="line">                            self.pair,</span><br><span class="line">                            -abs(order.Quantity),</span><br><span class="line">                            round(self._reference_price, 5),</span><br><span class="line">                            f&#39;Long&#123;match.group(2)&#125;-Liquidate&#39;</span><br><span class="line">                        )</span><br><span class="line">                    elif i &gt; 1:</span><br><span class="line">                        self.LimitOrder(</span><br><span class="line">                            self.pair,</span><br><span class="line">                            -abs(order.Quantity),</span><br><span class="line">                            round(self._reference_price - self._std &#x2F; self._grid_number * (i - 1), 5),</span><br><span class="line">                            f&#39;Long&#123;match.group(2)&#125;-Liquidate&#39;</span><br><span class="line">                        )</span><br><span class="line">            elif match.group(1) &#x3D;&#x3D; &#39;Short&#39;:</span><br><span class="line">                i &#x3D; int(match.group(2))</span><br><span class="line">                if match.group(3) &#x3D;&#x3D; &#39;-Liquidate&#39;:</span><br><span class="line">                    qty &#x3D; int(self._cash_per_position * self.get_qty_multiplier(i) &#x2F; (self._reference_price + self._std &#x2F; self._grid_number * i))</span><br><span class="line">                    self.LimitOrder(</span><br><span class="line">                        self.pair,</span><br><span class="line">                        -qty,</span><br><span class="line">                        round(self._reference_price + self._std &#x2F; self._grid_number * i, 5),</span><br><span class="line">                        f&#39;Short&#123;match.group(2)&#125;&#39;</span><br><span class="line">                    )</span><br><span class="line">                    openOrders &#x3D; self.Transactions.GetOpenOrders(self.pair)</span><br><span class="line">                    for order in openOrders:</span><br><span class="line">                        if order.Tag in [f&#39;Short&#123;match.group(2)&#125;-Liquidate&#39;, f&#39;Short&#123;match.group(2)&#125;-Stoploss&#39;]:</span><br><span class="line">                            self.Transactions.CancelOrder(order.Id)</span><br><span class="line">                else:</span><br><span class="line">                    if (i - 1) &#x3D;&#x3D; 0:</span><br><span class="line">                        self.LimitOrder(</span><br><span class="line">                            self.pair,</span><br><span class="line">                            abs(order.Quantity),</span><br><span class="line">                            round(self._reference_price, 5),</span><br><span class="line">                            f&#39;Short&#123;match.group(2)&#125;-Liquidate&#39;</span><br><span class="line">                        )</span><br><span class="line">                    else:</span><br><span class="line">                        self.LimitOrder(</span><br><span class="line">                            self.pair,</span><br><span class="line">                            abs(order.Quantity),</span><br><span class="line">                            round(self._reference_price + self._std &#x2F; self._grid_number * (i - 1), 5),</span><br><span class="line">                            f&#39;Short&#123;match.group(2)&#125;-Liquidate&#39;</span><br><span class="line">                        )</span><br><span class="line">        self.IS_READY &#x3D; False</span><br><span class="line"></span><br><span class="line">    def get_qty_multiplier(self, grid_number):</span><br><span class="line">        if self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.AVERAGE:</span><br><span class="line">            # Even weighted</span><br><span class="line">            return 1</span><br><span class="line">        elif self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.INCREMENTAL:</span><br><span class="line">            # Incremental</span><br><span class="line">            return grid_number</span><br><span class="line">        elif self.POSITION_AMOUNT_METHOD &#x3D;&#x3D; PositionAmountType.DOUBLEUP:</span><br><span class="line">            # Double up weighted</span><br><span class="line">            if not isinstance(grid_number, (int)):</span><br><span class="line">                grid_number &#x3D; int(grid_number)</span><br><span class="line">            return 2**(grid_number - 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/04/18/2022-04-20-forex-grid-trading-system/grid_system.png&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;Grid trading strategy is famous for its simplicity and ease of execution, and you don’t even have to guess where the market is going. No technical analysis and indicators are needed or recognize any patterns among endless candlesticks. It was once known as the &lt;em&gt;‘no-loss strategy’&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But, is this true that there is a strategy that causes you no risk?&lt;/p&gt;
&lt;p&gt;Today we’re going to look at what grid trading strategy is about, and we will conduct a series of backtesting against the Forex market to see whether it is the holy grail of our trading strategies.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
    <category term="Grid trading" scheme="http://mikelhsia.github.io/tags/Grid-trading/"/>
    
    <category term="Forex" scheme="http://mikelhsia.github.io/tags/Forex/"/>
    
  </entry>
  
  <entry>
    <title>Yes or No? Adopting the Supertrend indicator in your trading strategies?</title>
    <link href="http://mikelhsia.github.io/2022/03/18/2022-03-22-supertrend-indicator/"/>
    <id>http://mikelhsia.github.io/2022/03/18/2022-03-22-supertrend-indicator/</id>
    <published>2022-03-17T17:20:43.000Z</published>
    <updated>2022-03-18T18:40:10.596Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/03/18/2022-03-22-supertrend-indicator/cover.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><p>I have to admit that my attention was drawn by the name of this indicator at the first glance. Therefore my interest in implementing a series of backtesting against this indicator was unavoidable. In today’s article, we’re going to introduce what Supertrend indicator is about and how to produce one yourself. After that, I will show you a series of backtest that I have performed and see what we can get out of them.</p><a id="more"></a><h1 id="Introduce-Supertrend-indicator"><a href="#Introduce-Supertrend-indicator" class="headerlink" title="Introduce Supertrend indicator"></a>Introduce Supertrend indicator</h1><h2 id="What-is-Supertrend"><a href="#What-is-Supertrend" class="headerlink" title="What is Supertrend"></a>What is Supertrend</h2><p>Supertrend indicator was created by Olivier Seban to help identify trends and to know when to buy or sell a financial asset. Similar to Bollinger Bands, Supertrend involves an upper band and a lower band that is derived from the close price in order to find out the signals to show the trend of prices. Essentially, it is a trend-following (lagging) indicator.</p><p>When we construct the Supertrend indicator strategy, the default parameters involve using Average True Range (ATR) with the period of 14 and another parameter of 2 as its multiplier. The average true range (ATR) plays a key role in Supertrend as the indicator uses ATR to compute its upper- and lower- band values in results triggering the buy and sell signals.</p><h2 id="Pros-and-cons-of-Supertrend"><a href="#Pros-and-cons-of-Supertrend" class="headerlink" title="Pros and cons of Supertrend"></a>Pros and cons of Supertrend</h2><p>However, Super Trend needs to be used in conjunction with other indicators like RSI, MACD, and any other technical indicators in order to produce more accurate and confirmed signals.  Moreover, Supertrend also works best with a trailing stop-loss for the existing trades and acts as strong support or resistance.to use in combination with other indicators like MACD and RSI. We can list its pros and cons below to quickly understand Supertrend:</p><ul><li>Advantages of SuperTrend Indicator<ul><li>The best thing about Supertrend is it sends out accurate signals.</li><li>The indicator offers a quick technical analysis to intraday traders.</li><li>It is easy to use and understand.</li></ul></li><li>Disadvantages<ul><li>The Supertrend is not appropriate for all situations, which works when the market is trending.</li><li>Supertrend is best for singling out the trend, but it needs to cooperate with other indicators to decide the best timing to trade.</li><li>Supertrend uses only the two parameters of ATR and multiplier. They are not sufficient under certain conditions to predict the accurate direction of the market.</li></ul></li></ul><h2 id="How-to-calculate-Supertrend-indicator"><a href="#How-to-calculate-Supertrend-indicator" class="headerlink" title="How to calculate Supertrend indicator"></a>How to calculate Supertrend indicator</h2><p>Here I’m using the research book from <a href="https://www.quantconnect.com/">QuantConnect</a> to demonstrate the calculation of Supertrend indicator.</p><h3 id="1-Retrieve-close-and-ATR-data"><a href="#1-Retrieve-close-and-ATR-data" class="headerlink" title="1. Retrieve close and ATR data"></a>1. Retrieve close and ATR data</h3><p>First of all, we need to retrieve the close price and the ATR indicator from historical data:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qb &#x3D; QuantBook()</span><br><span class="line">stock &#x3D; qb.AddEquity(&quot;AAPL&quot;)</span><br><span class="line">history &#x3D; qb.History(qb.Securities.Keys, 720, Resolution.Daily)</span><br><span class="line">atr &#x3D; qb.Indicator(AverageTrueRange(14), stock.Symbol, 720, Resolution.Daily)</span><br><span class="line"></span><br><span class="line">his &#x3D; history.swaplevel().droplevel(1)</span><br><span class="line">his[&#39;atr&#39;] &#x3D; atr[&#39;averagetruerange&#39;]</span><br><span class="line">his.dropna(inplace&#x3D;True)</span><br><span class="line"></span><br><span class="line">his[[&#39;close&#39;, &#39;atr&#39;]].head()</span><br></pre></td></tr></table></figure></p><img data-src="/2022/03/18/2022-03-22-supertrend-indicator/data.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><h3 id="2-The-basic-upper-and-lower-bands"><a href="#2-The-basic-upper-and-lower-bands" class="headerlink" title="2. The basic upper- and lower- bands"></a>2. The basic upper- and lower- bands</h3><p>Then we need to calculate the basic upperband and lowerband utilizing the daily 14-period ATR. These basic bands fundamentally are the volatility through using the ATR indicator to see the possible fluctuation against current close price. The formulas are as follows:</p><script type="math/tex; mode=display">\text{Basic upperband} = \frac{\text{High + Low}}{2} + \text{Multiplier} \times \text{ATR}</script><script type="math/tex; mode=display">\text{Basic lowerband} = \frac{\text{High + Low}}{2} - \text{Multiplier} \times \text{ATR}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">his[&#39;hl2&#39;] &#x3D; (his[&#39;high&#39;] + his[&#39;low&#39;])&#x2F;2</span><br><span class="line">his[&#39;basic_upper&#39;] &#x3D; his[&#39;hl2&#39;] + his[&#39;atr&#39;] * 2</span><br><span class="line">his[&#39;basic_lower&#39;] &#x3D; his[&#39;hl2&#39;] - his[&#39;atr&#39;] * 2</span><br><span class="line"></span><br><span class="line">his[[&#39;basic_upper&#39;, &#39;basic_lower&#39;, &#39;close&#39;]].plot(figsize&#x3D;(15,10))</span><br></pre></td></tr></table></figure><img data-src="/2022/03/18/2022-03-22-supertrend-indicator/close_atr_data.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><h3 id="3-Calculate-the-final-upper-and-lower-bands"><a href="#3-Calculate-the-final-upper-and-lower-bands" class="headerlink" title="3. Calculate the final upper- and lower- bands"></a>3. Calculate the final upper- and lower- bands</h3><p>This step is to smooth the basic upperband and lowerband. In many indicators, we use moving average or other techniques to smooth the bands. Here we’re trying to use a different way to smooth them.</p><script type="math/tex; mode=display">If\ \text{(Basic upperband < Previous final upperband)}\ or \ \text{(Previous close > Previous final upperband)}</script><script type="math/tex; mode=display">\text{Final upperband} = \text{Basic upperband}</script><script type="math/tex; mode=display">else</script><script type="math/tex; mode=display">\text{Final upperband} = \text{Previous final upperband}</script><script type="math/tex; mode=display">If\ \text{(Basic lowerband > Previous final lowerband)}\ or \ \text{(Previous close < Previous final lowerband)}</script><script type="math/tex; mode=display">\text{Final lowerband} = \text{Basic lowerband}</script><script type="math/tex; mode=display">else</script><script type="math/tex; mode=display">\text{Final upperband} = \text{Previous final lowerband}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">his[&#39;final_upper&#39;] &#x3D; his[&#39;basic_upper&#39;] - his[&#39;basic_upper&#39;]</span><br><span class="line">his[&#39;final_lower&#39;] &#x3D; his[&#39;basic_upper&#39;] - his[&#39;basic_upper&#39;]</span><br><span class="line"></span><br><span class="line">for i in range(len(his)):</span><br><span class="line">    if i &#x3D;&#x3D; 0:</span><br><span class="line">        his.loc[his.index.values[i], &#39;final_upper&#39;] &#x3D; 0</span><br><span class="line">    else:</span><br><span class="line">        if (his.loc[his.index.values[i], &#39;basic_upper&#39;] &lt; his.loc[his.index.values[i-1], &#39;final_upper&#39;]) | (his.loc[his.index.values[i-1], &#39;close&#39;] &gt; his.loc[his.index.values[i-1], &#39;final_upper&#39;]):</span><br><span class="line">            his.loc[his.index.values[i], &#39;final_upper&#39;] &#x3D; his.loc[his.index.values[i], &#39;basic_upper&#39;]</span><br><span class="line">        else:</span><br><span class="line">            his.loc[his.index.values[i], &#39;final_upper&#39;] &#x3D; his.loc[his.index.values[i-1], &#39;final_upper&#39;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(len(his)):</span><br><span class="line">    if i &#x3D;&#x3D; 0:</span><br><span class="line">        his.loc[his.index.values[i], &#39;final_lower&#39;] &#x3D; 0</span><br><span class="line">    else:</span><br><span class="line">        if (his.loc[his.index.values[i], &#39;basic_lower&#39;] &gt; his.loc[his.index.values[i-1], &#39;final_lower&#39;]) | (his.loc[his.index.values[i-1], &#39;close&#39;] &lt; his.loc[his.index.values[i-1], &#39;final_lower&#39;]):</span><br><span class="line">            his.loc[his.index.values[i], &#39;final_lower&#39;] &#x3D; his.loc[his.index.values[i], &#39;basic_lower&#39;]</span><br><span class="line">        else:</span><br><span class="line">            his.loc[his.index.values[i], &#39;final_lower&#39;] &#x3D; his.loc[his.index.values[i-1], &#39;final_lower&#39;]</span><br></pre></td></tr></table></figure><img data-src="/2022/03/18/2022-03-22-supertrend-indicator/final_data.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><h3 id="4-Define-the-Superband-indicator"><a href="#4-Define-the-Superband-indicator" class="headerlink" title="4. Define the Superband indicator"></a>4. Define the Superband indicator</h3><p>Lastly, we’re going to assemble the Superband with all the components that we have constructed above.</p><script type="math/tex; mode=display">If\ \text{(Close price < Final upperband)}\ and\ \text{(Previous Supertrend == Previous final upperband)}</script><script type="math/tex; mode=display">ext{Supertrend} = \text{Final upperband}</script><script type="math/tex; mode=display">If\ \text{(Close price > Final upperband)}\ and\ \text{(Previous Supertrend == Previous final upperband)}</script><script type="math/tex; mode=display">\text{Supertrend} = \text{Final lowerband}</script><script type="math/tex; mode=display">If\ \text{(Close price > Final lowerband)}\ and\ \text{(Previous Supertrend == Previous final lowerband)}</script><script type="math/tex; mode=display">\text{Supertrend} = \text{Final lowerband}</script><script type="math/tex; mode=display">If\ \text{(Close price < Final upperband)}\ and\ \text{(Previous Supertrend == Previous final lowerband)}</script><script type="math/tex; mode=display">\text{Supertrend} = \text{Final upperband}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">his[&#39;supertrend&#39;] &#x3D; his[&#39;basic_upper&#39;] - his[&#39;basic_upper&#39;]</span><br><span class="line"></span><br><span class="line">for i in range(len(his[&#39;supertrend&#39;])):</span><br><span class="line">    if i &#x3D;&#x3D; 0:</span><br><span class="line">        his.loc[his.index.values[i], &#39;supertrend&#39;] &#x3D; 0</span><br><span class="line">    elif (his.loc[his.index.values[i-1], &#39;supertrend&#39;] &#x3D;&#x3D; his.loc[his.index.values[i-1], &#39;final_upper&#39;]) and (his.loc[his.index.values[i], &#39;close&#39;] &lt; his.loc[his.index.values[i], &#39;final_upper&#39;]):</span><br><span class="line">        his.loc[his.index.values[i], &#39;supertrend&#39;] &#x3D; his.loc[his.index.values[i], &#39;final_upper&#39;]</span><br><span class="line">    elif (his.loc[his.index.values[i-1], &#39;supertrend&#39;] &#x3D;&#x3D; his.loc[his.index.values[i-1], &#39;final_upper&#39;]) and (his.loc[his.index.values[i], &#39;close&#39;] &gt; his.loc[his.index.values[i], &#39;final_upper&#39;]):</span><br><span class="line">        his.loc[his.index.values[i], &#39;supertrend&#39;] &#x3D; his.loc[his.index.values[i], &#39;final_lower&#39;]</span><br><span class="line">    elif (his.loc[his.index.values[i-1], &#39;supertrend&#39;] &#x3D;&#x3D; his.loc[his.index.values[i-1], &#39;final_lower&#39;]) and (his.loc[his.index.values[i], &#39;close&#39;] &gt; his.loc[his.index.values[i], &#39;final_lower&#39;]):</span><br><span class="line">        his.loc[his.index.values[i], &#39;supertrend&#39;] &#x3D; his.loc[his.index.values[i], &#39;final_lower&#39;]</span><br><span class="line">    elif (his.loc[his.index.values[i-1], &#39;supertrend&#39;] &#x3D;&#x3D; his.loc[his.index.values[i-1], &#39;final_lower&#39;]) and (his.loc[his.index.values[i], &#39;close&#39;] &lt; his.loc[his.index.values[i], &#39;final_lower&#39;]):</span><br><span class="line">        his.loc[his.index.values[i], &#39;supertrend&#39;] &#x3D; his.loc[his.index.values[i], &#39;final_upper&#39;]</span><br><span class="line"></span><br><span class="line">his[[&#39;close&#39;, &#39;supertrend&#39;]].plot(figsize&#x3D;(15,10))</span><br></pre></td></tr></table></figure><img data-src="/2022/03/18/2022-03-22-supertrend-indicator/supertrend.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><h1 id="Strategy-setups-for-our-backtests"><a href="#Strategy-setups-for-our-backtests" class="headerlink" title="Strategy setups for our backtests"></a>Strategy setups for our backtests</h1><p>After introducing what Superband is and how to calculate it, we’re now going to backtest this indicator in conjunction with other indicators and see how they perform.</p><h2 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h2><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h2 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h2><ol><li>Sort stocks by <code>PERatio</code>, <code>EPS</code>, <code>ROE</code>, <code>NetIncome</code> and take top 60%</li><li>Sort stocks by <code>PBRatio</code>, from high to low</li></ol><h2 id="Rebalancing-strategy"><a href="#Rebalancing-strategy" class="headerlink" title="Rebalancing strategy"></a>Rebalancing strategy</h2><ol><li>Recalculate our universe and indicators every day.</li><li>We keep 10 stocks that have buy-in signals and with the highest <code>PBRatio</code>.</li><li>We assign weight to each position evenly.</li><li>We don’t adjust the weight of each stock until we close these positions.</li></ol><h2 id="Backtest-time-frame"><a href="#Backtest-time-frame" class="headerlink" title="Backtest time frame"></a>Backtest time frame</h2><p><strong>Backtest Date:</strong> <code>2019, 1 ,10</code> ~ <code>2022, 2, 14</code></p><h2 id="Signal-generation"><a href="#Signal-generation" class="headerlink" title="Signal generation"></a>Signal generation</h2><p>There’s no technical indicator that can be 100% accurate and so is Supertrend. Therefore we are going to backtest the performance of it combining other famous indicators.</p><h3 id="1-Supertrend-momentum-strategy"><a href="#1-Supertrend-momentum-strategy" class="headerlink" title="1. Supertrend momentum strategy"></a>1. Supertrend momentum strategy</h3><p>In this strategy, we buy when the close breaks through the Supertrend indicator, and sell when the close price falls below the Supertrend indicator.</p><h3 id="2-Supertrend-mean-reversion-strategy"><a href="#2-Supertrend-mean-reversion-strategy" class="headerlink" title="2. Supertrend mean-reversion strategy"></a>2. Supertrend mean-reversion strategy</h3><p>Compared to the above strategy, we do everything in reverse. We buy when the close price falls below the Supertrend, and sell when the close price goes above the Supertrend.</p><h3 id="3-Supertrend-with-RSI-indicator"><a href="#3-Supertrend-with-RSI-indicator" class="headerlink" title="3. Supertrend with RSI indicator"></a>3. Supertrend with RSI indicator</h3><p>We buy when the close price goes above the Supertrend also when RSI is above 50, and sell when the close price is under Supertrend and when RSI is below 50.</p><h3 id="4-Supertrend-with-EMA20-indicator"><a href="#4-Supertrend-with-EMA20-indicator" class="headerlink" title="4. Supertrend with EMA20 indicator"></a>4. Supertrend with EMA20 indicator</h3><p>We buy when the close price goes above the Supertrend also when 20-day EMA is above the close price, and sell when 20-day EMA is below the close price.</p><h3 id="5-Supertrend-with-EMA200-indicator"><a href="#5-Supertrend-with-EMA200-indicator" class="headerlink" title="5. Supertrend with EMA200 indicator"></a>5. Supertrend with EMA200 indicator</h3><p>We buy when the close price goes above the Supertrend also when 200-day EMA is above the close price, and sell when 200-day EMA is below the close price.</p><h3 id="6-Supertrend-with-William-R-indicator"><a href="#6-Supertrend-with-William-R-indicator" class="headerlink" title="6. Supertrend with William R indicator"></a>6. Supertrend with William R indicator</h3><p>We buy when the close price goes above the Supertrend also when the <a href="https://www.investopedia.com/terms/w/williamsr.asp">William R indicator</a> is below -50, and sell when the close price is under Supertrend and when the William R indicator is above -50.</p><h3 id="7-Supertrend-with-Chande-momentum-oscillator"><a href="#7-Supertrend-with-Chande-momentum-oscillator" class="headerlink" title="7. Supertrend with Chande momentum oscillator"></a>7. Supertrend with Chande momentum oscillator</h3><p>We buy when the close price goes above the Supertrend also when the <a href="https://www.investopedia.com/terms/c/chandemomentumoscillator.asp">Chande momentum oscillator</a> is below -50, and sell when the close price is under Supertrend and when the Chande momentum oscillator is above 50.</p><h3 id="8-Supertrend-with-10-trailing-stop-loss"><a href="#8-Supertrend-with-10-trailing-stop-loss" class="headerlink" title="8. Supertrend with 10% trailing stop loss"></a>8. Supertrend with 10% trailing stop loss</h3><p>In addition to the setup of the first momentum strategy, we add a trail stop loss if the close price falls 10% in two consecutive days.</p><h2 id="Backtest-result"><a href="#Backtest-result" class="headerlink" title="Backtest result"></a>Backtest result</h2><div class="table-container"><table><thead><tr><th>Strategy</th><th>Total Trades</th><th>PSR</th><th>Unrealized</th><th>Fee</th><th>Net profit</th><th>Return</th><th>Sharpe</th><th>Average Win</th><th>Average Loss</th><th>Compounding annual return</th><th>MDD</th><th>Profit-loss ratio</th><th>Win rate</th><th>Alpha</th><th>Beta</th><th>Annual variance</th></tr></thead><tbody><tr><td>momentum</td><td>607</td><td>41.256%</td><td>$12622.29</td><td>-$2470.65</td><td>$132108.37</td><td>142.34%</td><td>1.007</td><td>1,83%</td><td>-0.75%</td><td>32.7%</td><td>32.9%</td><td>2.43</td><td>42%</td><td>0.152</td><td>0.684</td><td>0.064</td></tr><tr><td>momentum_trailing_loss</td><td>635</td><td>22.944%</td><td>$9576.2</td><td>-$2201</td><td>$59980.43</td><td>67.39%</td><td>0.698</td><td>1.32%</td><td>-0.69%</td><td>17.898%</td><td>30.2%</td><td>1.91</td><td>42%</td><td>0.017</td><td>0.603</td><td>0.042  </td></tr><tr><td>mean-reversion</td><td>366</td><td>21.47%</td><td>-$17538.55</td><td>-$1295.34</td><td>$83620</td><td>64.81%</td><td>0.665</td><td>1.09%</td><td>-1.33%</td><td>17.315%</td><td>35.2%</td><td>0.82</td><td>70%</td><td>0.013</td><td>0.873</td><td>0.046</td></tr><tr><td>rsi</td><td>607</td><td>41.256%</td><td>$12622.29</td><td>-$2470.65</td><td>$132108.37</td><td>142.34%</td><td>1.007</td><td>1,83%</td><td>-0.75%</td><td>32.7%</td><td>32.9%</td><td>2.43</td><td>42%</td><td>0.152</td><td>0.684</td><td>0.064</td></tr><tr><td>ema20</td><td>970</td><td>10.581%</td><td>$3031.88</td><td>-$3230.26</td><td>$32780.4</td><td>34.6%</td><td>0.433</td><td>1.05%</td><td>-0.46%</td><td>9.437%</td><td>30.6%</td><td>2.26</td><td>35%</td><td>0.01</td><td>0.496</td><td>0.037</td></tr><tr><td>ema200</td><td>164</td><td>33.474%</td><td>-$3699</td><td>-$640.42</td><td>$161398.96</td><td>157.22%</td><td>0.913</td><td>6.00%</td><td>-1.20%</td><td>35.251%</td><td>38.5%</td><td>4.98</td><td>36%</td><td>0.087</td><td>1.013</td><td>0.108</td></tr><tr><td>william_r</td><td>28</td><td>24.792%</td><td>$63412</td><td>-$68</td><td>$19756</td><td>83.14%</td><td>0.733</td><td>4.90%</td><td>-1.44%</td><td>21.336%</td><td>41.00%</td><td>3.39</td><td>56%</td><td>-0.011</td><td>0.891</td><td>0.058</td></tr><tr><td>chande_momentum</td><td>0</td><td>0</td><td>$0</td><td>$0</td><td>$0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0   </td></tr></tbody></table></div><h2 id="Takeout-from-the-backtest-results"><a href="#Takeout-from-the-backtest-results" class="headerlink" title="Takeout from the backtest results"></a>Takeout from the backtest results</h2><p>The SPY return in our backtest period is around 74%. By looking at the statistics above, all the backtests seem very promising. But all the PSR (Probabilistic Sharpe Ratio) are fairly low (<em>See <a href="https://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/">here</a> if you don’t know what PSR stands for</em>). Also, the win rate in every backtest scenario is hardly over 50%. All these facts indicate that our Supertrend strategies don’t work really well.</p><p>There are other things that we can try to add to optimize our strategies:</p><ul><li>Find the appropriate universe that fit the nature of the Supertrend indicator.</li><li>Fine-tune the parameters used in our indicators</li><li>Combine the Supertrend indicator with other indicators.</li></ul><p>Of course, exploring the combination of different indicators could be a good way to level up your backtest score. But make sure you don’t go too extreme and go overfitting. Remember, history won’t repeat itself in the stock market. What we’re doing here is simply trying to find a way that can help us better confirm the time when the trend changes.</p><hr><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://wire.insiderfinance.io/backtest-supertrend-crossover-strategy-with-elasticsearch-ab048a3c6b8">Backtest supertrend crossover strategy</a></li><li><a href="https://www.elearnmarkets.com/blog/supertrend-indicator-strategy-trading/">Supertrend Indicator : How to use for Intraday trading?</a></li><li><a href="https://www.tradingfuel.com/supertrend-indicator-formula-and-calculation/">What is the SuperTrend Indicator</a></li><li><a href="https://medium.com/codex/step-by-step-implementation-of-the-supertrend-indicator-in-python-656aa678c111">A Step-By-Step Guide to Implementing the SuperTrend Indicator in Python</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/03/18/2022-03-22-supertrend-indicator/cover.png&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;I have to admit that my attention was drawn by the name of this indicator at the first glance. Therefore my interest in implementing a series of backtesting against this indicator was unavoidable. In today’s article, we’re going to introduce what Supertrend indicator is about and how to produce one yourself. After that, I will show you a series of backtest that I have performed and see what we can get out of them.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Momentum" scheme="http://mikelhsia.github.io/tags/Momentum/"/>
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>【ML algo trading】 IV - How to analyze how good my machine learning strategy is?</title>
    <link href="http://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/"/>
    <id>http://mikelhsia.github.io/2022/02/19/2022-02-17-machine-learning-performance-evaluation/</id>
    <published>2022-02-19T06:51:12.000Z</published>
    <updated>2022-08-24T18:00:02.297Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/02/19/2022-02-17-machine-learning-performance-evaluation/cover.jpeg" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><p>Phew! With all the hard work of fetching data, processing factors, splitting training and testing datasets, selecting the right model to train, you finally have your machine learning model trained and be able to test how powerful it is. You’re very excited to feed a bunch of test data and got a 100%+ rate of return. What a success! But be careful, <code>rate of return</code> is not the sole factor to evaluate the quality of your trading strategy. There are other metrics that help you to understand the strengths and weaknesses of your trading strategy, and you can improve your trading behavior based on these metrics.</p><a id="more"></a><p>Here are a group of metrics that I would like to recommend to you as I’ve calculated and adopted them in my own quantitative trading projects. These metrics are objective enough for you to evaluate the quality of your strategy, and they are relatively easy enough to calculate in your own framework. So, bear with me and hear me out.</p><blockquote><p>Previous reading:</p><ul><li><a href="https://mikelhsia.github.io/2021/04/22/2021-04-22-machine-learning-intro/">【Machine Learning】 Part I - 10 minutes to learn what I know about machine learning in quantitative trading</a></li><li><a href="https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/">【Machine Learning】 Part II - How to build a machine learning boilerplate?</a></li><li><a href="https://mikelhsia.github.io/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/">【Machine Learning】 Part III - 5 myths about practicing quant trading with machine learning</a></li></ul></blockquote><h2 id="General-Characteristics-of-your-strategy"><a href="#General-Characteristics-of-your-strategy" class="headerlink" title="General Characteristics of your strategy"></a>General Characteristics of your strategy</h2><ul><li><strong>Average Capacity</strong> is the maximum number of stocks that you would like to be included in your portfolio. This is actually not a metric to evaluate the quality of your performance, but it’s very likely to influence the performance of your strategy, considering holding more stocks in your portfolio potentially increases the diversity.</li><li><strong>Average AUM</strong> stands for <em>Asset Under Management</em>. This indicates how much money is currently available for trading stocks.</li><li><strong>Average holding period</strong> could range from minutes to years, depending on the nature of your trading strategy and on the observing window length. If your strategy is observing daily MACD cross, the minimum average holding period of your strategy is 1 day.</li></ul><h2 id="Performance-related-metrics"><a href="#Performance-related-metrics" class="headerlink" title="Performance-related metrics"></a>Performance-related metrics</h2><ul><li><strong>Annualized rate of return</strong> is the most common metric to evaluate your strategy. It’s an obvious decision to make to choose between a strategy that produces 30% and a strategy that makes 300% annually. However, how do we prioritize the strategies that one makes 30% and the other one makes 33%? There we need other metrics to come into play to help us differentiate good and bad strategies.<script type="math/tex; mode=display">\text{Annualized rate of return} = \frac{\text{Money made annually}}{\text{Total amount of money invested initially}}</script></li><li><strong>Win rate</strong>. Simple as that. It means how many trades made you profit among all the trades you made.<script type="math/tex; mode=display">\text{Win rate} = \frac{\text{The number of trades that make positive return}}{\text{The number of total trades made}}</script></li></ul><h2 id="Risk-related-metrics"><a href="#Risk-related-metrics" class="headerlink" title="Risk related metrics"></a>Risk related metrics</h2><ul><li><strong>Annualized volatility</strong> is a traditional method to evaluate the risk of your portfolio. This essentially evaluated how volatile your portfolio value was. The higher the volatility, the more likely your portfolio value will be influenced by the market or the macroeconomic. This risk can be mitigated by adding stocks from different industries to diversify your portfolio.</li><li><strong>Max Drawdown</strong> indicates the maximum percentage loss during the observation periods.<script type="math/tex; mode=display">\text{Max Drawdown} = \frac{\text{Through Value} - \text{Peak Value}}{\text{Peak Value}}</script></li></ul><img data-src="/2022/02/19/2022-02-17-machine-learning-performance-evaluation/maxdrawdown.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Code snippet to calculate the Max Drawdown</i></p><h2 id="Efficiency-related-metrics"><a href="#Efficiency-related-metrics" class="headerlink" title="Efficiency related metrics"></a>Efficiency related metrics</h2><ul><li><strong>Sharpe Ratio</strong>‘s calculation is relatively easy as dividing the portfolio excess return by the standard deviation of the portfolio excess return. However, it is probably the first metric you’re going to look at when evaluating the strategy. It stands for the excess return that you’re going to get by taking each unit of risk, which is volatility.<script type="math/tex; mode=display">\text{Sharpe Ratio} = \frac{\text{Portfolio's excess return}}{\text{Standard deviation of the portfolio's excess return}}</script>$\text{where Portfolio’s excess return} = \text{Portfolio return} - \text{Risk-free rate}$</li><li><strong>Information Ratio</strong> is similar to the Sharpe ratio, but it is used to evaluate the ability to outperform the selected benchmark.<script type="math/tex; mode=display">\text{Information ratio} = \frac{\text{Portfolio return} - \text{Benchmark return}}{\text{Standard deviation of difference between portfolio and benchmark return}}</script></li><li><strong>Sortino Ratio</strong> is a variant of the Sharpe ratio. It evaluates the portfolio’s return given solely the downside risk, as the upside volatility is beneficial and we don’t worry about the upside volatility.<script type="math/tex; mode=display">\text{Sortino Ratio} = \frac{\text{Portfolio's excess return}}{\text{Standard deviation of the downside}}</script></li><li><strong>Calmar Ratio</strong> is a useful way to evaluate the portfolio return against the maximum risk within the given time period. If the maximum drawdown is huge, you will get a relatively small Calmar ratio. This could potentially mean that your portfolio is relatively vulnerable when black swan incidents.<script type="math/tex; mode=display">\text{Calmar Ratio} = \frac{\text{Average Annual Rate of Return}}{\text{Maximum Drawdown}}</script></li><li><strong>Probabilistic Sharpe Ratio (PSR)</strong> is kind of an improvement version of the Sharpe ratio based on the statistical theory. Instead of calculating the Sharpe ratio using the given time series of return, PSR uses the skewness and kurtosis to generate an estimated normal distribution of the rate of return. Therefore, you are able to know the probability of your portfolio getting the estimated rate of return. You can check <a href="https://quantdare.com/probabilistic-sharpe-ratio/">here</a> for more details.<img data-src="/2022/02/19/2022-02-17-machine-learning-performance-evaluation/psr.png" class="" width="800"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Code snippet to calculate the PSR</i></p></li></ul><h2 id="Classification-scores-Machine-learning-strategy-specific"><a href="#Classification-scores-Machine-learning-strategy-specific" class="headerlink" title="Classification scores (Machine learning strategy specific)"></a>Classification scores (Machine learning strategy specific)</h2><ul><li><strong>Accuracy</strong> is the ratio of correctly predicted positive observations to the total positive observations.<script type="math/tex; mode=display">Accuracy = \frac{TP+TN}{TP+TN+FP+FN}</script></li><li><strong>Precision</strong> is the ratio of correctly predicted positive observation and total predicted positive observation. It shows how precise our model is.<script type="math/tex; mode=display">Precision = \frac{TP}{TP+FP}</script></li><li><strong>Recall</strong> is the ratio of the correct predicted positive observation and the total observation in the class.<script type="math/tex; mode=display">Recall = \frac{TP}{TP+FN}</script></li><li><strong>F1-Score</strong> is the weighted average of recall and precision.<script type="math/tex; mode=display">\text{F1-Score} = \frac{2*(Recall * Precision)}{Recall + Precision}</script></li><li><strong>AUC(Area Under roc Curve)</strong> is a metric that represents the classification ability of a machine learning model. An excellent model has AUC near to the 1 which means it has a good measure of separability. A model has an AUC near 0 which means it predicts the positive as the negative and vice versa. But it doesn’t necessary mean this model is poor. It still tells us that this model is able to separate the right and wrong samples. If a model has AUC equal to 0.5, that means this model is useless as it has no ability to predict the outcome. See more details <a href="https://towardsdatascience.com/understanding-auc-roc-curve-68b2303cc9c5">here</a></li><li><strong>Matthews correlation coefficient (MCC)</strong> is a relatively general measure of “accuracy” of a predictive model that can give insights about how much we can rely on the model.<script type="math/tex; mode=display">\text{MCC} = \frac{(TP \times TN) - (FP \times FN)}{\sqrt{(TP+FP)(TP+FN)(TN+FP)(TN+FN)}}</script></li><li><strong>Average return from hits</strong> is the average rate of return from bets that generate profit.</li><li><strong>Average return from misses</strong> is the average rate of return from bets that generate loss.</li></ul><h2 id="Others-metrics"><a href="#Others-metrics" class="headerlink" title="Others metrics"></a>Others metrics</h2><ul><li><strong>Stratified Analysis</strong> to me is avery important steps in my research process. It tells me whether my model is capable of picking the stocks that have the highest return among all stocks.<img data-src="/2022/02/19/2022-02-17-machine-learning-performance-evaluation/stratified.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Stratified analysis diagram</i></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">group_number &#x3D; 6</span><br><span class="line">group_label &#x3D; [f&#39;R&#123;x&#125;&#39; for x in range(group_number, 0, -1)]</span><br><span class="line"></span><br><span class="line">data[&#39;rate&#39;] &#x3D; data.groupby(&#39;date&#39;)[&#39;score&#39;].apply(lambda x : pd.cut(x, bins&#x3D;group_number, labels&#x3D;group_label))</span><br><span class="line">data[&#39;log_rtn&#39;] &#x3D; np.log(test[&#39;rtn&#39;] + 1)</span><br><span class="line"></span><br><span class="line">x &#x3D; data.groupby([&#39;date&#39;, &#39;rate&#39;])[&#39;log_rtn&#39;].apply(lambda x: x.sum()&#x2F;len(x)).reset_index().set_index([&#39;rate&#39;, &#39;date&#39;])</span><br><span class="line">z &#x3D; pd.DataFrame(index&#x3D;x.loc[&#39;R1&#39;].index)</span><br><span class="line"></span><br><span class="line">for i in range(1,group_number+1):</span><br><span class="line">    try:</span><br><span class="line">        z[f&#39;R&#123;i&#125;&#39;] &#x3D; x.loc[f&#39;R&#123;i&#125;&#39;,:].cumsum()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">plt.figure(figsize&#x3D;(15, 10))</span><br><span class="line">plt.xticks(rotation&#x3D;90)</span><br><span class="line">plt.yticks(rotation&#x3D;45)</span><br><span class="line"></span><br><span class="line">sns.lineplot(data&#x3D;z, dashes&#x3D;False)</span><br></pre></td></tr></table></figure><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Code snippet to generate stratified analysis diagram</i></p><ul><li><p><strong>Benchmark performance diagram</strong> is simply to put your portfolio return on the chart against your selected benchmark return. In fact, there are a lot of things that can be found in this comparison. It tells whether you’re portfolio still grows when the benchmark return decline, whether your portfolio can grow faster in the bull market period, and many other things.</p><img data-src="/2022/02/19/2022-02-17-machine-learning-performance-evaluation/benchmark.png" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">  <i>Portfolio return v.s. benchmark return</i></p></li><li><p><strong>PnL</strong> is the profit and loss during the entire observation period.</p></li><li><strong>Turnover fee</strong> is the sum of the transaction fees that costs you while trading with this strategy. If you’re trading too frequently, your profit could be offset by this seemingly insignificant cost. The turnover fee could be calculated by the product of the number of total trades and the transaction fees per trade.</li><li><strong>Beta and Alpha</strong> both derive from the CAPM model. Alpha stands for the excess return of your strategy, and beta represents the systematic return.<script type="math/tex; mode=display">Return_{Portfolio} - Return_{Riskfree} = \beta \times (Return_{Market} - Return_{Riskfree}) + \alpha</script></li></ul><p>These are the metrics that I’ve been using while evaluating my trading strategy. Please do tell me what other metrics you think are useful.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/02/19/2022-02-17-machine-learning-performance-evaluation/cover.jpeg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;Phew! With all the hard work of fetching data, processing factors, splitting training and testing datasets, selecting the right model to train, you finally have your machine learning model trained and be able to test how powerful it is. You’re very excited to feed a bunch of test data and got a 100%+ rate of return. What a success! But be careful, &lt;code&gt;rate of return&lt;/code&gt; is not the sole factor to evaluate the quality of your trading strategy. There are other metrics that help you to understand the strengths and weaknesses of your trading strategy, and you can improve your trading behavior based on these metrics.&lt;/p&gt;</summary>
    
    
    
    <category term="Machine Learning" scheme="http://mikelhsia.github.io/categories/Machine-Learning/"/>
    
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>Quants! Learn from your foe - &quot;Value Investing&quot;</title>
    <link href="http://mikelhsia.github.io/2022/01/03/2022-01-10-value-investing-part1/"/>
    <id>http://mikelhsia.github.io/2022/01/03/2022-01-10-value-investing-part1/</id>
    <published>2022-01-03T14:57:10.000Z</published>
    <updated>2022-01-04T14:37:17.183Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2022/01/03/2022-01-10-value-investing-part1/cover.jpg" class="" width="600"><p>Value investing is an investing strategy that has been popular for decades. The main idea involves picking quality stocks among distressed companies, buying and holding them for the long-term (over several years), and expecting the good quality stocks to remain good and rebound from the valley. In short, value investing is to <b><i>buy good companies at a good price</i></b>. In this post, we’re going to go through the framework that some of the value investors use to evaluate the company value.</p><a id="more"></a><h1 id="What-exactly-is-Value-Investing"><a href="#What-exactly-is-Value-Investing" class="headerlink" title="What exactly is Value Investing?"></a>What exactly is Value Investing?</h1><p>Warren Buffett is probably the most well-known value investor today, but there are also many other value investors in the field, such as Benjamin Graham (Buffett’s mentor), Charlie Munger (Buffett’s business partner), and Joel Greenblatt. Among them, Benjamin Graham is highly praised as the “<em>Father of Value Investing</em>“ and has a significant place in the field. There are also famous case studies such as Buffett’s bet on Coca-Cola in 1988 and Geico in 1951, which both generate a massive return. In addition, the previous post of <a href="https://mikelhsia.github.io/2020/08/21/2020-08-21-magic-formula-vs-Acquirer-Multiples/">An investment strategy that takes you three days a year</a> was also derived from the <a href="https://www.thebalance.com/what-is-magic-formula-investing-4150688">magic formula</a> that was created by <em>Joel Greenblatt</em>.</p><img data-src="/2022/01/03/2022-01-10-value-investing-part1/coca.png" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>The stock price of Coca-Cola since 1988</i></p><p>Value investors advocate the idea of finding the stocks whose market value (stock price) are traded way lower than their company intrinsic value. By using the data from fundamental analysis and company annual reports every year, value investors would use their framework to calculate the company intrinsic value with assuming growth rate for the upcoming years. If the gap (which was so called “<em>safety margin</em>“) between the market value and the calculated intrinsic value is larger enough, it is believed that the discounted market value is simply due to public opinions and emotions. The company itself is still healthy enough to generate positive net income to grow continuously, pumping its stock price back to where it should be or even higher.</p><p>In recent years, analysts and investors are saying that the value stocks are no longer attractive and throwing themselves into growth stocks’ arms such as FAANG, Tesla, Roku, and so on. However, there are still others who believe that the value investing was still profitable because:</p><ol><li>The economic cycle is extended. So the stocks you invested simply need more time to rebound. See <a href="https://www.schroders.com/en/uk/the-value-perspective/blog/all-blogs/why-we-still-believe-in-value-investing/">here</a></li><li>The profit was diluted because the value investing strategy is too well-known and was adopted by too many investors and investing institutions. See <a href="https://www.forbes.com/sites/simonmoore/2021/01/03/is-value-investing-dead-not-so-fast-says-a-recent-study/?sh=38edf83e1cd4">here</a></li></ol><img data-src="/2022/01/03/2022-01-10-value-investing-part1/value_vs_growth.png" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Value stocks v.s. growth stocks in recent years</i></p><p>Either way, I believe that there are some ideas inheres within the value investing strategy itself which are still valuable and beneficial in adopting them into the quantitative strategies. So now, let’s have a look.</p><h1 id="The-evaluation-framework-of-Value-Investing"><a href="#The-evaluation-framework-of-Value-Investing" class="headerlink" title="The evaluation framework of Value Investing"></a>The evaluation framework of Value Investing</h1><p>There are a lot of methodologies and frameworks that were developed within Value Investing. The book “<strong><em>Value Investing: From Graham to Buffett and Beyond</em></strong>“ by <em>Bruce C.N. Greenwald</em>, <em>Judd Kahn</em>, <em>Paul D. Sonkin</em>, and <em>Michael van Biema</em> promotes a framework that separates the whole evaluation process into several stages: 1. calculate the Asset Value (AV) of the company, 2. calculate the Earnings Power Value (EPV) of the company, 3. compare to the market value and see whether we’ll be able to make the decision to invest in this company or not.</p><h2 id="Asset-Value-AV"><a href="#Asset-Value-AV" class="headerlink" title="Asset Value (AV)"></a>Asset Value (AV)</h2><p>The Asset Value is calculated to evaluate the actual value of the company, including tangible assets and intangible assets. Tangible assets include <em>PPE</em>, <em>marketable securities</em>, <em>inventory</em>, and so on. They can be found in the balance sheet in the annual/quarter report. However, the one-the-book asset value doesn’t reflect its value right now, so we need to make adjustments on these items in order to find out the current value of the company asset.</p><p>Intangible assets include <em>goodwill</em>, <em>brand value</em>, <em>workforce</em>, <em>product portfolio</em>, <em>clients/contracts</em>, and everything. As most of these assets are not documented in the balance sheet, we need to figure out a way to estimate the ballpark amount of these items. For example, the workforce cost is already included in the SG&amp;A in the balance sheet but not the HR cost on recruiting this workforce. Therefore, if there is a company A that has 1,000 blue-collar workers, we can take the US average wages of blue-collar workers to calculate the total cost.</p><script type="math/tex; mode=display">1,000 \times \$ 33,762 = \$ 33\ million</script><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>According to <a href='https://www.comparably.com/salaries/salaries-for-blue-collar-worker'>www.comparably.com</a></i></p><p>We assume the cost to recruit the workforce is 10% of the total cost of the workforce, then we’ll be able to calculate the cost of the recruitment to be:</p><script type="math/tex; mode=display">\$ 33\ million \times 0.1 = \$ 3.3\ million</script><p>This would be one of the adjustments that we made while calculating the company asset value.</p><h2 id="Earnings-Power-Value-EPV"><a href="#Earnings-Power-Value-EPV" class="headerlink" title="Earnings Power Value (EPV)"></a>Earnings Power Value (EPV)</h2><p>Earnings Power Value essentially means the capability of a company to make money, and it’s not just any money that a company makes. We’re looking for <em>Net Operating Profit After Tax (NOPAT)</em>, meaning the income from financial activities and from investing activities. The NOPAT of a company could showcase the ability to earn net income through selling the company’s services or products. After all, selling services and goods to the customers is the major business activity of the company.</p><p>Also, we need to make sure the company can sustainably make this amount of money or more. If a company’s NOPAT fluctuates a lot, this would implicitly indicate that the company business is not stable enough to support sustainable growth.</p><p>A quick way to explain the way to calculate the EPV is:</p><script type="math/tex; mode=display">\begin{align*}&\ \ \ \ \ \text{Revenue}\\-&\ \ \ \ \ \text{Operating expense}\\-&\ \ \ \ \ \text{Depreciation and amortization charges}\\-&\ \ \ \ \ \text{Tax}\\--&--------------\\&\ \ \ \ \ \text{Net operating profit after tax}\\\end{align*}</script><p>Lastly, since we have been able to approximately evaluate the NOPAT of the company we can use <a href="https://www.investopedia.com/terms/d/dcf.asp">DCF (Discounted Cash Flow)</a> model to calculate the EPV of the company. We use the <em><a href="https://www.investopedia.com/terms/w/wacc.asp">Weighted Average Cost of Capital (WACC)</a></em> as the discount rate in our calculation so that we take the actual cost of working capital into account. Then, we will get a number that represents the value of an investment that can generate this NOPAT steadily.</p><script type="math/tex; mode=display">EPV = \frac{NOPAT(Net Operating Profit After Tax)}{\text{WACC(Weighted Average Cost of Capital)}}</script><h2 id="The-final-call-on-the-decision"><a href="#The-final-call-on-the-decision" class="headerlink" title="The final call on the decision"></a>The final call on the decision</h2><p>Once we have our AV and EPV ready, we can start making our final call on whether we should long this investment or not. Here’s a general principle to follow:</p><ul><li>If AV is higher than EPV, meaning the industry is declining and this company won’t be able to make enough profit as it’s mismanagement of its assets.</li><li>If AV is equal to EPV, meaning this company is able to efficiently manage its asset to generate enough profit.</li><li>If AV is below the EPV, meaning this company’s management team has a superior ability to manage its asset. Also, this indicates that this company has sufficient power to build the barriers to entry to outcompete the other competitors in this industry.</li></ul><p>Then, we compare the EPV with the market value of the company to see whether this company is currently undervalued or overvalued. If it is undervalued, maybe this is the timing for us to enter this trade.</p><img data-src="/2022/01/03/2022-01-10-value-investing-part1/value.png" class="" width="350"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>AV, EPV, and market value</i></p><h1 id="Wrap-up"><a href="#Wrap-up" class="headerlink" title="Wrap up"></a>Wrap up</h1><p>What I have demonstrated above is only a part of the value investing methodology. There are more technics, assumptions, and methodologies involved that are too complex to be tuck into one single post. So I’ll stop it right here so that you can discover more by yourself.</p><p>A lot of people say that Value Investing is dying. But I think value investing is a tool and mindset, and also an essence of analysts’ experience. There are a lot of valuable thoughts that can be extracted and be applied to quantitative trading. For example, stock-picking to form your stock pool, evaluating a company to see it is under- or overvalued, and also processing the fundamental data to make it more meaningful to conduct a second analysis. I believe learning how value investors think would definitely benefit your capability to build an even better quantitative trading strategy.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2022/01/03/2022-01-10-value-investing-part1/cover.jpg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p&gt;Value investing is an investing strategy that has been popular for decades. The main idea involves picking quality stocks among distressed companies, buying and holding them for the long-term (over several years), and expecting the good quality stocks to remain good and rebound from the valley. In short, value investing is to &lt;b&gt;&lt;i&gt;buy good companies at a good price&lt;/i&gt;&lt;/b&gt;. In this post, we’re going to go through the framework that some of the value investors use to evaluate the company value.&lt;/p&gt;</summary>
    
    
    
    <category term="Value Investing" scheme="http://mikelhsia.github.io/categories/Value-Investing/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Fundamental Analysis" scheme="http://mikelhsia.github.io/tags/Fundamental-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Four strategies of using RSI indicator to better time your market entry</title>
    <link href="http://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/"/>
    <id>http://mikelhsia.github.io/2021/11/03/2021-11-06-rsi-indicator/</id>
    <published>2021-11-03T04:09:19.000Z</published>
    <updated>2021-11-09T04:14:24.294Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/11/03/2021-11-06-rsi-indicator/cover.jpeg" class="" width="600"><p>We talked about how to use MACD indicator and other secondary indicators to tell when to long certain stocks in the previous articles. If you haven’t read them yet, below are the links to catch up on where we left. But, is this the end of the optimization of our trading strategy? In this article, we’re going to demonstrate the power of RSI indicators and see how this indicator can be a help to our current trading strategy.</p><ul><li><a href="https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/">How to save your silver bullets with MACD strategy?</a></li><li><a href="https://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/">Optimize your MACD strategies with advanced indicators</a></li></ul><a id="more"></a><h1 id="Train-of-thought-How-to-optimize-our-trading-strategy"><a href="#Train-of-thought-How-to-optimize-our-trading-strategy" class="headerlink" title="Train of thought - How to optimize our trading strategy"></a>Train of thought - How to optimize our trading strategy</h1><img data-src="/2021/11/03/2021-11-06-rsi-indicator/train_of_thought.png" class="" width="300"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Train of thought</i></p><h3 id="1-Where-to-start"><a href="#1-Where-to-start" class="headerlink" title="1. Where to start?"></a>1. Where to start?</h3><p>The definition of optimizing the trading strategy can be simplified as increasing the money you make in this very trading strategy. It always comes down to two directions: either profit more, or you lose less compared to our benchmark strategy. Instead of spending more time studying the topic of stopping loss, I decided to give it one more shot to add another momentum indicator to see whether that can better time the entry.</p><h3 id="2-What-I-have-in-the-trading-strategy"><a href="#2-What-I-have-in-the-trading-strategy" class="headerlink" title="2. What I have in the trading strategy"></a>2. What I have in the trading strategy</h3><p>The <a href="https://www.tradingview.com/support/solutions/43000502344-macd-moving-average-convergence-divergence/">MACD</a> indicator I have adopted in our strategy is a momentum indicator, indicating the stock price trend by using 9-day EMA and 26-day EMA. When the fast EMA(9-day EMA) crosses above the slow EMA(26-day EMA), it gives us the idea that the stock price seems to have the tendency to go upward.</p><h3 id="3-What-we-can-add-to-the-trading-strategy"><a href="#3-What-we-can-add-to-the-trading-strategy" class="headerlink" title="3. What we can add to the trading strategy"></a>3. What we can add to the trading strategy</h3><p>Since we have the future tendency indicator, I believe we also need to indicator to point us where the stock price is at compared to the stock price these days. There are many options, such as SMA (Simple Moving Average), oscillators, <a href="https://www.tradingview.com/support/solutions/43000501840-bollinger-bands-bb/">Bollinger Bands</a>, we can choose from. Here, we pick the RSI indicator to apply to our strategy.</p><h3 id="4-What-is-RSI"><a href="#4-What-is-RSI" class="headerlink" title="4. What is RSI?"></a>4. What is RSI?</h3><p>The <strong>Relative Strength Index (RSI)</strong> is a momentum indicator used in technical analysis that measures the magnitude of recent price movement and evaluates overbought or oversold conditions in the price of a stock or other asset. The MACD, on the other hand, measures the momentum of those price moves. This means that an asset could be overbought or oversold but is still able to show positive momentum in that direction. When both indicators concur, we get a better idea of what is the state of the current stock price, enhance the confidence of our bet side, and hopefully increase our win rate and total profit. In short, the indicator constructed in our trading strategy would consist of:</p><ul><li>MACD: Prediction of the future trend</li><li>Awesome Oscillator: Confirmation of the future trend</li><li>RSI: Past price history and movement</li></ul><h3 id="5-Formula-of-RSI-Calculation-of-RS-and-RSI"><a href="#5-Formula-of-RSI-Calculation-of-RS-and-RSI" class="headerlink" title="5. Formula of RSI / Calculation of RS and RSI"></a>5. Formula of RSI / Calculation of RS and RSI</h3><p>Let’s quickly go through the calculation of RSI:</p><script type="math/tex; mode=display">RS = \frac{\text{Average of Upward Price Change}}{\text{Average of Downward Price Change}}</script><script type="math/tex; mode=display">RSI = 100 - \frac{100}{1 + RS}</script><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>The formula of RSI / Calculation of RS and RSI</i></p><p>Let’s see how to calculate a 14-day period. We say there is a stock that has \$2 growth for eight days in this 14-day period, and -\$2 decrease for six days. So we will get our RS value by doing:</p><blockquote><p>$RS = \frac{2 \times 8}{14} \div \frac{2 \times 6}{14} = 1.333$</p></blockquote><p>Our RSI will be:</p><blockquote><p>$RSI = 1 - \frac{100}{1+1.333} = 57.13$</p></blockquote><p>As the RSI indicator is in a form of the oscillator, it ranges from 0~100. A stock would usually be considered as oversold when if the RSI is lower than 30, indicating a bullish price momentum in order to revert the RSI back to the average range. On the other hand, a stock would be deemed as overbought when the RSI is higher than 70. Just like the below stock price of Amazon (<em>AMZN</em>)</p><img data-src="/2021/11/03/2021-11-06-rsi-indicator/amzn.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>AMZN stock price</i></p><h3 id="6-Limitations-of-RSI"><a href="#6-Limitations-of-RSI" class="headerlink" title="6. Limitations of RSI"></a>6. Limitations of RSI</h3><p>RSI is one of the most popular day trading strategy indicators since it was developed in 1978. You can find tons of articles on the internet about what RSI can achieve. However, when a market is in a strong trend, RSI loses its usefulness. Why? Because RSI can remain overbought or oversold for long periods providing the trader misleading signals.</p><p>Below is the stock price of Tesla (<em>TSLA</em>) since September, 2021. The RSI in the red rectangle stays above 70-line for over a month and has no signs of reverting. This is the exact example illustrating that the strong bullish momentum would generate wrong signals.</p><img data-src="/2021/11/03/2021-11-06-rsi-indicator/tsla.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>TSLA stock price since September, 2021</i></p><p>In other words, blindly executing a trade based on overbought or oversold signals is definitely not a good idea. Indicators are tools to help you quickly have a big picture of the specific stock, but they won’t help you enough if you don’t understand the market context or company-specific risk.</p><hr><h1 id="Strategy-setups-for-our-backtests"><a href="#Strategy-setups-for-our-backtests" class="headerlink" title="Strategy setups for our backtests"></a>Strategy setups for our backtests</h1><p>After introducing what RSI is and what are we going to use it for, let’s get back to the business: constructing our trading and preparing for the backtest. This strategy is going to use the strategy we built before in <a href="https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/">here</a> and <a href="https://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/">here</a></p><h2 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h2><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h2 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h2><ol><li>Sort stocks by <code>PERatio</code>, <code>EPS</code>, <code>ROE</code>, <code>NetIncome</code> and take top 60%</li><li>Sort stocks by <code>PBRatio</code>, from high to low</li></ol><h2 id="Rebalancing-strategy"><a href="#Rebalancing-strategy" class="headerlink" title="Rebalancing strategy"></a>Rebalancing strategy</h2><ol><li>Recalculate our universe and indicators every day.</li><li>We keep 10 stocks that have buy-in signals and with the highest <code>PBRatio</code>.</li><li>We assign weight to each position evenly.</li><li>We don’t adjust the weight of each stock until we close these positions.</li></ol><h2 id="Signal-generation"><a href="#Signal-generation" class="headerlink" title="Signal generation"></a>Signal generation</h2><p>As written in the title of this article, we’re going to introduce four different RSI strategies and see how our trading strategy can benefit by adding any one of them. Now, we quickly talk about how each type of RSI indicator strategy:</p><h3 id="1-The-Moving-Average-of-RSI"><a href="#1-The-Moving-Average-of-RSI" class="headerlink" title="1. The Moving Average of RSI"></a>1. The Moving Average of RSI</h3><p>The very first strategy is that we use SMA (<em>Simple Moving Average</em>) to smooth the RSI.</p><script type="math/tex; mode=display">RSI_{SMA}= \frac{RSI_n + RSI_{n-1} + ... + RSI_1}{n}</script><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Formula of SMA</i></p><p>The benefit of applying SMA on the RSI we have acquired is that we can reduce the frequency of our threshold to be triggered. A lot of times that the threshold was reached because the anomaly/abnormal price movements were generated due to a certain of market events. You can tell from the below chart, that the smoothed RSI line triggered twice only compared to the original RSI line that triggered five times.</p><img data-src="/2021/11/03/2021-11-06-rsi-indicator/sma.png" class="" width="700"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>RSI V.S. smoothed RSI</i></p><ul><li>Buy signal: Original buy signal + SMA of RSI &lt; 30 (which tells us that this stock is potentially oversold at the moment)</li><li>Sell signal: Original sell signal</li></ul><blockquote><p>Note: We’re not going to add the RSI signal in our selling signal generation rule. Our intention is to buy when all signals confirmed the same direction, but sell when the future prediction indicator MACD tells us that the upward trending is over.</p><p>Note 2: You can check the previous articles <a href="https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/">here</a> and <a href="https://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/">here</a></p></blockquote><h3 id="2-RSI-stack"><a href="#2-RSI-stack" class="headerlink" title="2. RSI stack"></a>2. RSI stack</h3><p>The concept of the RSI stack is to use multiple consecutive time frames to further confirm the relative strength. Taking the example from the post <a href="https://alpaca.markets/learn/backtrader-01/">Alpaca &amp; Backtrader: Tools of the Trade (Part 1)</a>, you can see that the author uses <code>15m, 30m, 1h</code> three different time frames to confirm the relative strength is strong enough to start bidding on the reverting direction. Since here we are constructing our strategy to run on a daily basis, we use <code>1d, 2d</code> as the time frame to confirm the strength of the current trend.</p><ul><li>Buy signal: Original buy signal + $RSI_{n} &lt; 30$ + $RSI_{n-1} &lt; 30$</li><li>Sell signal: Original sell signal</li></ul><h3 id="3-The-RSI²-Leading-Indicator"><a href="#3-The-RSI²-Leading-Indicator" class="headerlink" title="3. The RSI² Leading Indicator"></a>3. The RSI² Leading Indicator</h3><p>As the RSI is derived directly from the stock price movements, so the RSI indicator value will highly depend on the market condition overall. Therefore <a href="https://python.plainenglish.io/the-rsi%C2%B2-leading-indicator-detecting-trend-exhaustion-early-in-trading-284a59dc1ea3">in this post</a> suggests that we can perform another RSI function over the original RSI, called $RSI^2$. This will tell us when will the original RSI meets the extreme conditions and start to revert to the opposite direction.</p><ul><li>Buy signal: Original buy signal + $RSI^2 &lt; 30$</li><li>Sell signal: Original sell signal</li></ul><h3 id="4-The-Stochastic-RSI-Indicator"><a href="#4-The-Stochastic-RSI-Indicator" class="headerlink" title="4. The Stochastic-RSI Indicator"></a>4. The Stochastic-RSI Indicator</h3><p>Stochastic Oscillator is a technique that normalizes our value into a range from 0 ~ 1. We usually time 100 to the result so that the number is more approachable, ranging from 0 ~ 100. The outcome tells us that we either stand at the top (&gt; 70) or at the bottom (&lt;30) in the range of historical RSI.</p><script type="math/tex; mode=display">\text{Stochastic RSI} = \frac{\text{Current RSI} - \text{Highest RSI since n periods}}{\text{Highest RSI since n periods} - \text{Lowest RSI since n periods}}</script><ul><li>Buy signal: Original buy signal + $\text{Stochastic RSI} &lt; 30$</li><li>Sell signal: Original sell signal</li></ul><h2 id="Other-parameters"><a href="#Other-parameters" class="headerlink" title="Other parameters"></a>Other parameters</h2><p><strong>Backtest Date:</strong> <code>2019, 1 ,10</code> ~ <code>2021, 10, 25</code></p><hr><h1 id="Backtest-results"><a href="#Backtest-results" class="headerlink" title="Backtest results"></a>Backtest results</h1><p>Below are the backtests that were performed according to our constructed strategies. In addition to those strategies we mentioned above, I have conducted another set of backtests using <strong>EMA</strong> (<em>Exponential Moving Average</em>) to calculate our RSI just for reference. The results are quite aligned between these two types of RSI calculations.</p><img data-src="/2021/11/03/2021-11-06-rsi-indicator/backtest_result.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Backtest results summary</i></p><h2 id="Backtest-diagrams"><a href="#Backtest-diagrams" class="headerlink" title="Backtest diagrams"></a>Backtest diagrams</h2><h3 id="1-The-Moving-Average-of-RSI-1"><a href="#1-The-Moving-Average-of-RSI-1" class="headerlink" title="1. The Moving Average of RSI"></a>1. The Moving Average of RSI</h3><div class="table-container"><table><thead><tr><th>SMA of RSI (Simple)</th><th>SMA of RSI (Exponential)</th></tr></thead><tbody><tr><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/sma_sim.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using SMA to construct RSI</i> </p></td><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/sma_ema.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using EMA to construct RSI</i> </p></td></tr></tbody></table></div><p>With the help from the RSI, Our net profit doesn’t seem to increase. Referring to both the backtest results and the diagram, there are fewer trading signals generated and the higher win rate compared to the benchmark strategy. However, the net profit slides drastically from 199.348% to around 100%. This could be a sign that there are too few valid trading signals were generated. Also, let’s look at the period after the outburst of COVID. There are no trades made for at least 5 months, meaning this strategy wasn’t able to capture the opportunities during the recovery of the economy. As survivors of post-market after the COVID outburst, we all know by now that the best opportunity is actually lying behind the downturn of the market.</p><h3 id="2-RSI-stack-1"><a href="#2-RSI-stack-1" class="headerlink" title="2. RSI stack"></a>2. RSI stack</h3><div class="table-container"><table><thead><tr><th>RSI Stack (Simple)</th><th>RSI Stack (Exponential)</th></tr></thead><tbody><tr><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/stack_sim.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using SMA to construct RSI</i> </p></td><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/stack_ema.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using EMA to construct RSI</i> </p></td></tr></tbody></table></div><p>The RSI stack doesn’t seem to really help confirm the direction and relative strength. Same as the SMA of RSI strategy, even though the win rate did rise to <code>80%</code> of total trades, the profitability of this strategy still doesn’t seem promising.</p><h3 id="3-The-RSI²-Leading-Indicator-1"><a href="#3-The-RSI²-Leading-Indicator-1" class="headerlink" title="3. The RSI² Leading Indicator"></a>3. The RSI² Leading Indicator</h3><div class="table-container"><table><thead><tr><th>SMA of RSI (Simple)</th><th>SMA of RSI (Exponential)</th></tr></thead><tbody><tr><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/square_sim.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using SMA to construct RSI</i> </p></td><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/square_ema.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using EMA to construct RSI</i> </p></td></tr></tbody></table></div><p>By looking at the stat <code>number of trades</code> and the diagram <code>HeldPositions</code>, we can confirm that now this strategy does generate enough signals to perform effective trading. The profitability has increased but the annual standard deviation has worsened. Even though the net profit looks attractive, all the stats and diagrams don’t profit enough confidence for us to go all-in.</p><h3 id="4-The-Stochastic-RSI-Indicator-1"><a href="#4-The-Stochastic-RSI-Indicator-1" class="headerlink" title="4. The Stochastic-RSI Indicator"></a>4. The Stochastic-RSI Indicator</h3><div class="table-container"><table><thead><tr><th>SMA of RSI (Simple)</th><th>SMA of RSI (Exponential)</th></tr></thead><tbody><tr><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/stoch_sim.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using SMA to construct RSI</i> </p></td><td><img data-src="/2021/11/03/2021-11-06-rsi-indicator/stoch_ema.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Results of using EMA to construct RSI</i> </p></td></tr></tbody></table></div><p>This RSI strategy looks relatively promising as both the stats and the diagrams outperform the benchmark and the other RSI strategies. Also, if you look at the diagram, we’re able to outperform the benchmark performance after the COVID outburst. This could potentially indicate that this strategy is capable of capturing the opportunities during the market growth, but is unable to profit from the bumpy market condition.</p><h1 id="Delivery"><a href="#Delivery" class="headerlink" title="Delivery"></a>Delivery</h1><p>One thing worth mentioning is that even though we have one successful backtest, it doesn’t 100% ensure that we’re going to get the same profit if we put this strategy to life.</p><p>Seems all our backtests don’t give us enough confidence to say whether it’s a good enough strategy to launch it. However, there are still a lot of possibilities of the RSI that can be explored. For example, so far we have used <code>cross above/under the threshold</code> as the trigger of the RSI signals. Yet, we can try staying put when we cross above/under the threshold and trigger our signals when the RSI <code>reverts back from the threshold</code> to confirm the trend is indeed happening. This exploration could take a serious amount of time. But like what <em>Larry Swedroe</em>, the Director of research for Buckingham Strategic Wealth once said, “<strong>when you are trying to time the markets, you have to be right twice: going in, and going out</strong>“. You need to double in the efforts so that you’ll get the comparable rewarding.</p><p><br><div style="border: 2pt solid lightgrey;border-radius: 4pt;box-shadow: 7px 7px lightgrey;padding: 1.3em;width:80%;margin:auto;"> <i><b style="font-size:1.3em;padding: 1.3em;color:grey;">"When you are trying to time the markets, you have to be right twice: going in, and going out"</b></i> <p style="font-size: 0.9em; text-align:right; color: grey;">    <i><b>Larry Swedroe</b><br> Director of research for Buckingham Strategic Wealth</i></p> </div><br></p><hr><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://tradingsim.com/blog/stochastic-rsi/">https://tradingsim.com/blog/stochastic-rsi/</a></li><li><a href="https://tradingsim.com/blog/relative-strength-index-rsi/">RSI Trade Settings Explained + 4 Unique Trading Strategies</a></li><li><a href="https://medium.com/the-investors-handbook/trading-techniques-the-moving-average-of-rsi-f489fca3b572">Trading Techniques — The Moving Average of RSI</a></li><li><a href="https://alpaca.markets/learn/backtrader-01/">RSI stack part I</a> &amp; <a href="https://alpaca.markets/learn/backtrader-02/">part II</a></li><li><a href="https://python.plainenglish.io/the-rsi%C2%B2-leading-indicator-detecting-trend-exhaustion-early-in-trading-284a59dc1ea3">The RSI² Leading Indicator. Detecting Trend Exhaustion Early in Trading.</a></li><li><a href="https://kaabar-sofien.medium.com/the-stochastic-rsi-indicator-the-full-guide-in-python-fb495e8820b7">The Stochastic-RSI Indicator</a></li><li><a href="https://medium.com/raposa-technologies/4-simple-rsi-trading-strategies-db7b9790c690">4 Simple RSI Trading Strategies</a></li><li><a href="https://medium.datadriveninvestor.com/trend-confirmation-strategy-using-the-rsi-in-python-96079b74e712">Trend Confirmation Strategy Using the RSI in Python.</a></li><li><a href="https://wire.insiderfinance.io/the-more-signals-the-better-stochastic-rsi-vs-rsi-b0740a17c584">The more signals the better? Stochastic RSI vs. RSI</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/11/03/2021-11-06-rsi-indicator/cover.jpeg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p&gt;We talked about how to use MACD indicator and other secondary indicators to tell when to long certain stocks in the previous articles. If you haven’t read them yet, below are the links to catch up on where we left. But, is this the end of the optimization of our trading strategy? In this article, we’re going to demonstrate the power of RSI indicators and see how this indicator can be a help to our current trading strategy.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/&quot;&gt;How to save your silver bullets with MACD strategy?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/&quot;&gt;Optimize your MACD strategies with advanced indicators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Momentum" scheme="http://mikelhsia.github.io/tags/Momentum/"/>
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>Is my trading strategy one step away from making a fortune? - From research to backtest</title>
    <link href="http://mikelhsia.github.io/2021/10/22/2021-10-23-rebalancing-strategy/"/>
    <id>http://mikelhsia.github.io/2021/10/22/2021-10-23-rebalancing-strategy/</id>
    <published>2021-10-21T17:03:31.000Z</published>
    <updated>2021-11-09T04:14:24.294Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/cover.jpeg" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><p>After reading the post <a href="https://python.plainenglish.io/how-to-improve-investment-portfolio-with-rebalancing-strategy-in-python-a58841ee8b5e">How to Improve Investment Portfolio with Rebalancing Strategy in Python</a> by <a href="https://teobguan2013.medium.com/?source=post_page-----a58841ee8b5e--------------------------------">Bee Guan Teo</a>, I was thrilled to know that this trading strategy can be that powerful and the portfolio return is greater than any of my existing trading strategies. Therefore I decided to give it a try and backtest this strategy to verify the profitability it claimed.</p><a id="more"></a><h1 id="Extracting-the-essences-of-the-strategy"><a href="#Extracting-the-essences-of-the-strategy" class="headerlink" title="Extracting the essences of the strategy"></a>Extracting the essences of the strategy</h1><p>First of all, we extracted several things from the <a href="https://python.plainenglish.io/how-to-improve-investment-portfolio-with-rebalancing-strategy-in-python-a58841ee8b5e">post</a> in order to formulate the skeleton of our backtest strategy.</p><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/diagnosis.jpeg" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Perform the autopsy on the trading strategy</i></p><h2 id="1-Platform"><a href="#1-Platform" class="headerlink" title="1. Platform"></a>1. Platform</h2><p>I’m using <a href="https://www.quantconnect.com/">QuantConnect</a> to backtest this seemingly lucrative strategy.</p><h2 id="2-Universe"><a href="#2-Universe" class="headerlink" title="2. Universe"></a>2. Universe</h2><p>Instead of using a fixed set of stocks as in the original article, I’m using the following rules to filter the stocks that are similar in nature:</p><ol><li>Rank all the stocks by <code>DollarVolume</code></li><li>Choose stocks that are in NASDAQ and NYSE</li><li>Filter out the stocks that are listed less than 180 days (3 months)</li><li>Filter out the companies whose market capitalization are less than 500 million dollars</li><li>Lastly, we sorted all the remaining stocks by Dollar Volume, and limit them to top either <code>100</code> or <code>200</code> stocks</li></ol><h2 id="3-Rebalancing-strategy"><a href="#3-Rebalancing-strategy" class="headerlink" title="3. Rebalancing strategy"></a>3. Rebalancing strategy</h2><ol><li>As instructed in the article, we keep maximum five stocks that are most likely to rise.</li><li>We assign weight to each position evenly.</li><li>We don’t adjust the weight of each stock until we close this positions.</li></ol><h2 id="4-Signal-generation"><a href="#4-Signal-generation" class="headerlink" title="4. Signal generation"></a>4. Signal generation</h2><p>The strategy described in the article essentially is a kind of momentum strategy. It assumes that the stocks will continue to have great performances when they have good performances in the previous month. By holding this assumption, the author suggested:</p><ol><li>Every month we long five stocks that have the best monthly return in the previous month.</li><li>In the next month, we abandon two stocks that have the worst performance and</li><li>Replace them with the other two stocks that have good monthly returns in the previous month.</li></ol><h2 id="5-Other-parameters"><a href="#5-Other-parameters" class="headerlink" title="5. Other parameters"></a>5. Other parameters</h2><p>Other than the size of our universe, we pick <code>backtest time frame</code> as another parameter for us to test against with. In the end, we’re going to conduct four backtests:</p><ol><li>Limit the number of stocks in the universe to <code>100</code> and backtest it for 2 years</li><li>Limit the number of stocks in the universe to <code>100</code> and backtest it for 5 years</li><li>Limit the number of stocks in the universe to <code>200</code> and backtest it for 2 years</li><li>Limit the number of stocks in the universe to <code>200</code> and backtest it for 5 years</li></ol><h1 id="Backtest-results"><a href="#Backtest-results" class="headerlink" title="Backtest results"></a>Backtest results</h1><div class="table-container"><table><thead><tr><th></th><th>Momentum-100-2y</th><th>Momentum-100-5y</th><th>Momentum-200-2y</th><th>Momentum-100-5y</th></tr></thead><tbody><tr><td>No. of trade</td><td>93</td><td>233</td><td>93</td><td>235</td></tr><tr><td>Return</td><td>577.34%</td><td>162.471%</td><td>230.94 %</td><td>738.94 %</td></tr><tr><td>Annual Return</td><td>178.398%</td><td>21.922%</td><td>89.750%</td><td>54.789%</td></tr><tr><td>Annual Standard Deviation</td><td>0.546</td><td>0.469</td><td>0.476</td><td>0.373</td></tr><tr><td>Max D.D.</td><td>46.5%</td><td>66.9%</td><td>37.800%</td><td>43.000%</td></tr><tr><td>Beta</td><td>0.947</td><td>1.127</td><td>0.846</td><td>1.107</td></tr><tr><td>Alpha</td><td>1.186</td><td>0.132</td><td>0.594</td><td>0.306</td></tr><tr><td>Sharpe Ratio</td><td>2.471</td><td>0.594</td><td>1.555</td><td>1.205</td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Backtest results summary</i></p><p>Wow! Even though the backtest time span has across 5 years, the annual return rates look promising, ranging from 21% to 178%. Sharpe ratios are also telling us that we’re making a good amount of money under reasonable risk. Even though the max drawdown is a bit intimidatingly high, the huge amount of compensation looks lucrative enough to take that degree of risk. In the end, by looking at the stats of these backtests, this strategy has the potential to make some hard coin!</p><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/coin.jpg" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><p>Hold on. Take a step back and don’t jump the gun. Let’s do a double check by looking at the return diagram of the described scenario respectively. See whether we can discover some patterns that are not hidden behind these numbers.</p><div class="table-container"><table><thead><tr><th>Duration \<br> # Universe</th><th>100</th><th>200</th></tr></thead><tbody><tr><td>2 years</td><td><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/test-100-2y.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Limit universe to contain 100 stocks<br>from 2019/12/02 to 2021/10/13</i> </p></td><td><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/test-200-2y.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Limit universe to contain 200 stocks<br>from 2019/12/02 to 2021/10/13</i> </p></td></tr><tr><td>5 years</td><td><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/test-100-5y.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Limit universe to contain 100 stocks<br>from 2016/12/02 to 2021/10/13</i> </p></td><td><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/test-200-5y.png" class="" width="600"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Limit universe to contain 200 stocks<br>from 2016/12/02 to 2021/10/13</i> </p></td></tr></tbody></table></div><p>Did you notice the pattern in the above four diagrams? Apparently, the majority of the portfolio return is generated starting the late 2020s. Any time before the late 2020s actually very little return over years. This fact indicates that the portfolio return over years is contributed by luck so that we can capture this uprising wave. From the asset sales volume distribution diagram in the backtest below, you can tell that most of the return is contributed by Tesla (<code>TSLA</code>), ROKU (<code>ROKU</code>), Advanced Micro Devices (<code>AMD</code>), and GameStop (<code>GME</code>), which are highly volatile and unpredictable <a href="https://en.wikipedia.org/wiki/Meme_stocks">MEME stocks</a>.</p><img data-src="/2021/10/22/2021-10-23-rebalancing-strategy/asset_sales_volume.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;"><i>Asset sales volume over time</i></p><p>It’s a fair question to ask that whether this type of opportunity will continue to be captured by this strategy. Also, what if your capital won’t sustain until the day you capture this opportunity? These are the objective questions that you need to ask yourself before you adopt this as an executable trading strategy. Other than those, <code>the number of trades</code> and <code>the backtest time span</code> are also the important KPIs that I keep my eyes on. I didn’t mean to judge whether this is a good or bad strategy, but knowing the answers to the above questions can help you adjust the position of this strategy in your investment portfolio.</p><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="Code-of-alpha-model-for-QuantConnect-platform"><a href="#Code-of-alpha-model-for-QuantConnect-platform" class="headerlink" title="Code of alpha model for QuantConnect platform"></a>Code of alpha model for QuantConnect platform</h2><p><em>(including signal generation)</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> AlgorithmImports <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SymbolData</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, algorithm, symbol</span>):</span></span><br><span class="line">        self.symbol = symbol</span><br><span class="line">        self.algorithm = algorithm</span><br><span class="line">        self.rolling_close = RollingWindow[float](<span class="number">2</span>)</span><br><span class="line">        hist = algorithm.History(</span><br><span class="line">            [self.symbol],</span><br><span class="line">            <span class="number">4</span>,</span><br><span class="line">            Resolution.Daily</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;close&#x27;</span> <span class="keyword">in</span> hist.columns:</span><br><span class="line">            self.rolling_close.Add(hist[<span class="string">&#x27;close&#x27;</span>][<span class="number">-2</span>])</span><br><span class="line">            self.rolling_close.Add(hist[<span class="string">&#x27;close&#x27;</span>][<span class="number">-1</span>])</span><br><span class="line">            <span class="comment"># algorithm.Debug(f&#x27;[&#123;self.symbol&#125;] - &#123;self.rolling_close[0]&#125; , &#123;self.rolling_close[1]&#125; init complete&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Update</span>(<span class="params">self, close</span>):</span></span><br><span class="line">        self.rolling_close.Add(close)</span><br><span class="line">        <span class="comment"># self.algorithm.Debug(f&#x27;[&#123;self.symbol&#125;] - &#123;self.rolling_close[0]&#125; , &#123;self.rolling_close[1]&#125; update complete&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Remove</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monthly_return</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (self.rolling_close[<span class="number">0</span>] - self.rolling_close[<span class="number">1</span>])/self.rolling_close[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopNReturnAlphaModel</span>(<span class="params">AlphaModel</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        capacity = <span class="number">10</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        replacement = <span class="number">5</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        resolution = Resolution.Daily</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        self.resolution = resolution</span><br><span class="line">        self._changes = <span class="literal">None</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.replacement = replacement</span><br><span class="line">        self.lastMonth = <span class="number">-1</span></span><br><span class="line">        self.symbol_data = dict()</span><br><span class="line">        self.trade_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Update</span>(<span class="params">self, algorithm, data</span>):</span></span><br><span class="line">        insights = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> algorithm.Time.month == self.lastMonth <span class="keyword">and</span> self.traded_flag == <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># algorithm.Debug(f&#x27;Time is &#123;algorithm.Time&#125;: Data is empty&#x27;)</span></span><br><span class="line">            <span class="keyword">return</span> insights</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.lastMonth = algorithm.Time.month</span><br><span class="line">            self.traded_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(data.Bars) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> insights</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            algorithm.Debug(<span class="string">f&#x27;Time from Update: <span class="subst">&#123;algorithm.Time&#125;</span>&#x27;</span>)</span><br><span class="line">            self.traded_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        addedSecuritiesSymbols = [x.Symbol <span class="keyword">for</span> x <span class="keyword">in</span> self._changes.AddedSecurities] <span class="keyword">if</span> self._changes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        removedSecuritiesSymbols = [x.Symbol <span class="keyword">for</span> x <span class="keyword">in</span> self._changes.RemovedSecurities] <span class="keyword">if</span> self._changes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> security <span class="keyword">in</span> algorithm.ActiveSecurities.Keys:</span><br><span class="line">            <span class="keyword">if</span> addedSecuritiesSymbols:</span><br><span class="line">                <span class="keyword">if</span> security <span class="keyword">in</span> addedSecuritiesSymbols:</span><br><span class="line">                    <span class="comment"># Add rolling window</span></span><br><span class="line">                    <span class="keyword">if</span> security <span class="keyword">not</span> <span class="keyword">in</span> self.symbol_data.keys():</span><br><span class="line">                        self.symbol_data[security] = SymbolData(algorithm, security)</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> self.symbol_data[security].rolling_close.IsReady:</span><br><span class="line">                            <span class="comment"># Not ready so remove again</span></span><br><span class="line">                            symbolData = self.symbol_data.pop(security, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Update rolling window</span></span><br><span class="line">                self.symbol_data[security].Update(data.Bars[security].Close)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> removedSecuritiesSymbols:</span><br><span class="line">            <span class="keyword">for</span> security <span class="keyword">in</span> removedSecuritiesSymbols:</span><br><span class="line">                <span class="comment"># Remove rolling window</span></span><br><span class="line">                <span class="keyword">if</span> security <span class="keyword">in</span> self.symbol_data.keys():</span><br><span class="line">                    symbolData = self.symbol_data.pop(security, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        sorted_symbol_data = &#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(</span><br><span class="line">            self.symbol_data.items(),</span><br><span class="line">            key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>].monthly_return,</span><br><span class="line">            reverse = <span class="literal">True</span></span><br><span class="line">        )[:self.capacity]&#125;</span><br><span class="line"></span><br><span class="line">        invested_stocks = dict()</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> algorithm.Portfolio:</span><br><span class="line">            <span class="keyword">if</span> s.Value.Invested:</span><br><span class="line">                invested_stocks[s.Key] = algorithm.Portfolio[s.Key].UnrealizedProfitPercent</span><br><span class="line"></span><br><span class="line">        invested_stocks = &#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(</span><br><span class="line">            invested_stocks.items(),</span><br><span class="line">            key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>],</span><br><span class="line">            reverse=<span class="literal">True</span></span><br><span class="line">        )&#125;</span><br><span class="line"></span><br><span class="line">        algorithm.Debug(<span class="string">f&#x27;Invested number: <span class="subst">&#123;len(invested_stocks)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        insightExpiry = Expiry.EndOfDay(algorithm.Time)</span><br><span class="line">        <span class="keyword">if</span> len(invested_stocks) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> sorted_symbol_data.keys():</span><br><span class="line">                insights.append(</span><br><span class="line">                    Insight.Price(</span><br><span class="line">                        str(s),</span><br><span class="line">                        insightExpiry,</span><br><span class="line">                        InsightDirection.Up,</span><br><span class="line">                        <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0.05</span></span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">                <span class="comment"># algorithm.Debug(f&#x27;Buying &#123;str(s)&#125;&#x27;)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>, self.replacement):</span><br><span class="line">                <span class="comment"># Close the positions that have the worse performances</span></span><br><span class="line">                worse_stock = invested_stocks.popitem()</span><br><span class="line">                insights.append(</span><br><span class="line">                    Insight.Price(</span><br><span class="line">                        str(worse_stock[<span class="number">0</span>]),</span><br><span class="line">                        insightExpiry,</span><br><span class="line">                        InsightDirection.Flat,</span><br><span class="line">                        <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0.05</span>    <span class="comment"># Weight</span></span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">                <span class="comment"># algorithm.Debug(f&#x27;Selling &#123;str(worse_stock[0])&#125;&#x27;)</span></span><br><span class="line"></span><br><span class="line">            open_positions = self.replacement</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> sorted_symbol_data.keys():</span><br><span class="line">                <span class="keyword">if</span> open_positions &gt; <span class="number">0</span> <span class="keyword">and</span> s <span class="keyword">not</span> <span class="keyword">in</span> invested_stocks.keys():</span><br><span class="line">                    insights.append(</span><br><span class="line">                        Insight.Price(</span><br><span class="line">                            str(s),</span><br><span class="line">                            insightExpiry,</span><br><span class="line">                            InsightDirection.Up,</span><br><span class="line">                            <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0.05</span>    <span class="comment"># Weight</span></span><br><span class="line">                        ),</span><br><span class="line">                    )</span><br><span class="line">                    open_positions -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># algorithm.Debug(f&#x27;Buying &#123;str(s)&#125;&#x27;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reset the changes</span></span><br><span class="line">        self._changes = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># algorithm.Debug(f&#x27;Sent out &#123;len(insights)&#125; on &#123;algorithm.Time&#125;&#x27;)</span></span><br><span class="line">        <span class="keyword">return</span> insights</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">OnSecuritiesChanged</span>(<span class="params">self, algorithm, changes</span>):</span></span><br><span class="line">        self._changes = changes</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/10/22/2021-10-23-rebalancing-strategy/cover.jpeg&quot; class=&quot;&quot; width=&quot;500&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;After reading the post &lt;a href=&quot;https://python.plainenglish.io/how-to-improve-investment-portfolio-with-rebalancing-strategy-in-python-a58841ee8b5e&quot;&gt;How to Improve Investment Portfolio with Rebalancing Strategy in Python&lt;/a&gt; by &lt;a href=&quot;https://teobguan2013.medium.com/?source=post_page-----a58841ee8b5e--------------------------------&quot;&gt;Bee Guan Teo&lt;/a&gt;, I was thrilled to know that this trading strategy can be that powerful and the portfolio return is greater than any of my existing trading strategies. Therefore I decided to give it a try and backtest this strategy to verify the profitability it claimed.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Momentum" scheme="http://mikelhsia.github.io/tags/Momentum/"/>
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>【Pair Trading】Part 3. The strategy that helps minimize your portfolio risk</title>
    <link href="http://mikelhsia.github.io/2021/09/30/2021-10-05-pair-trading-market-neutral/"/>
    <id>http://mikelhsia.github.io/2021/09/30/2021-10-05-pair-trading-market-neutral/</id>
    <published>2021-09-30T07:45:52.000Z</published>
    <updated>2021-11-03T04:22:05.167Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/cover.png" class="" width="800"><blockquote><p>Previous reading:</p><ul><li><a href="https://medium.com/@mikelhsia/pair-trading-introduction-to-pair-trading-strategy-c97a1d0897ff">【Pair Trading】Introduction to pair trading strategy</a></li><li><a href="https://medium.com/@mikelhsia/after-knowing-what-the-pair-trading-strategy-is-about-from-the-previous-post-were-going-to-use-98e41ef3ea5">【Pair Trading】In-depth analysis of 5 distance approach strategies in pair trading</a></li></ul></blockquote><p>In the previous post <a href="https://medium.com/@mikelhsia/after-knowing-what-the-pair-trading-strategy-is-about-from-the-previous-post-were-going-to-use-98e41ef3ea5">【Pair Trading】In-depth analysis of 5 distance approach strategies in pair trading</a>, we have conducted various research against each variation of distance approaches in pair trading strategy. Despite the research has given us probable insights whether there is an <strong>$\alpha$</strong> exists in the strategy we constructed, we still haven’t established our portfolio construction strategy. Here we introduce a concept called the “long-short equity (LSE)” strategy.</p><p>Therefore, the objectives of this post are consists of three:</p><ol><li>What is the long-short equity (LSE) strategy</li><li>Review our backtest results to see the impact of adopting the long-short strategy</li><li>What are the advanced strategies that we can explore</li></ol><a id="more"></a><h1 id="The-Long-short-equity-LSE-strategy"><a href="#The-Long-short-equity-LSE-strategy" class="headerlink" title="The Long-short equity (LSE) strategy"></a>The Long-short equity (LSE) strategy</h1><p>The long-short equity (LSE) strategy is an extension of the pair strategy which takes long positions in stocks that are expected to appreciate and takes short positions in stocks that are expected to depreciate. It’s a classic hedge fund investment strategy that is able to generate relatively higher risk-adjusted returns with lower volatility and smaller market-specific exposure compared to the traditional long-only portfolio.</p><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/long-short.jpg" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Long-short strategy</i></p><h1 id="Backtest-against-the-distance-approaches-selected"><a href="#Backtest-against-the-distance-approaches-selected" class="headerlink" title="Backtest against the distance approaches selected"></a>Backtest against the distance approaches selected</h1><p>Here we’re going to run backtests against the approaches we have spoken about in the previous post:</p><ul><li>Basic distance</li><li>High variance</li><li>Zero crossing</li><li>Pearson correlation</li></ul><p>In this series of backtests, we will adopt the <strong>long-only strategy</strong> (<em>buy the stocks that are most likely to rise</em>) against each of the four pair-trading approaches. In the meantime, we’re going to adopt the <strong>long-short strategy</strong> (<em>long the stocks that are expected to appreciate, and short other stocks that are expected to depreciate</em>) to backtest each pair-trading approach under the same conditions. By doing these, we can compare and see the impact of applying the long-short strategy.</p><h2 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h2><p>There are other setups including:</p><h3 id="1-Platform"><a href="#1-Platform" class="headerlink" title="1. Platform"></a>1. Platform</h3><p><a href="https://www.quantconnect.com/">QuantConnect</a></p><h3 id="2-Universe-selection"><a href="#2-Universe-selection" class="headerlink" title="2. Universe selection"></a>2. Universe selection</h3><ol><li>Rank all the stocks by <code>DollarVolume</code></li><li>Choose stocks that are in NASDAQ and NYSE</li><li>Filter out the stocks that are listed less than 180 days (3 months)</li><li>Filter out the companies whose market capitalization are less than 500 million dollars</li></ol><h3 id="3-Rebalancing-strategy"><a href="#3-Rebalancing-strategy" class="headerlink" title="3. Rebalancing strategy"></a>3. Rebalancing strategy</h3><ol><li>For the long-only strategy scenario, we buy 20 stocks that are most likely to rise.</li><li>For the long-short strategy scenario, we long 20 stocks that are most likely to rise and short 20 stocks that are most likely to drop.</li><li>We assign even weight to each position.</li><li>We don’t adjust the weight of the portfolio while we hold our positions.</li></ol><h3 id="4-Long-Short-signal-generation"><a href="#4-Long-Short-signal-generation" class="headerlink" title="4. Long/Short signal generation"></a>4. Long/Short signal generation</h3><p>We have all the details regarding how to trigger the long or short signals in <a href="https://medium.com/@mikelhsia/after-knowing-what-the-pair-trading-strategy-is-about-from-the-previous-post-were-going-to-use-98e41ef3ea5">this post here</a>. For those who haven’t read this post, the critical details have been summarized below:</p><ol><li><p>For basic distance, high variance, and zero-crossing methods, we use $\pm 1.5 \times std\ of\ spread$ as the upper bound and lower bound to trigger the buy/sell signals. Then we close the positions when the spread reverts back to the zero-line.</p><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/threshold.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;"> <i>Open when above the upper bound and below the lower bound, and close when reverting back to the zero-line.</i></p></li><li><p>For the Pearson Correlation method, we construct a benchmark portfolio for each stock by picking the 50 most correlated stocks. We long the stocks that its stock price movement deviated from its benchmark portfolio movement, and spread of the stock movement is negative. Vice versa, we short the stocks that the spread of the stock movement is positive against the benchmark portfolio movement.</p></li></ol><h2 id="Backtest-results"><a href="#Backtest-results" class="headerlink" title="Backtest results"></a>Backtest results</h2><h3 id="Backtest-of-basic-distance"><a href="#Backtest-of-basic-distance" class="headerlink" title="Backtest of basic distance"></a>Backtest of basic distance</h3><div class="table-container"><table><thead><tr><th></th><th>LO-BD</th><th>LS-BD</th><th>Impact</th></tr></thead><tbody><tr><td>Diagram</td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-LO-BD-2y.png" class="" width="600"></td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-MN-BD-2y.png" class="" width="600"></td><td></td></tr><tr><td>No. of trade</td><td>172</td><td>428</td><td><font color="red">+256</font></td></tr><tr><td>Return</td><td>67.45%</td><td>18.98%</td><td><font color="red">-48.47%</font></td></tr><tr><td>Annual Return</td><td>35.393%</td><td>10.754%</td><td><font color="red">-24.639%</font></td></tr><tr><td>Annual Standard Deviation</td><td>0.304</td><td>0.134</td><td><font color="green">-0.17</font></td></tr><tr><td>Max D.D.</td><td>38.4%</td><td>13.9%</td><td><font color="green">-24.5%</font></td></tr><tr><td>Beta</td><td>-0.161</td><td><font color="green">0.036</font></td><td></td></tr><tr><td>Alpha</td><td>0.381</td><td>0.09</td><td><font color="red">-0.372</font></td></tr><tr><td>Sharpe Ratio</td><td>1.136</td><td>0.731</td><td><font color="red">-0.405</font></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>LO: Long-Only strategy, LS: Long-Short strategy, BD: Basic Distance</i></p><h3 id="Backtest-of-zero-crossing"><a href="#Backtest-of-zero-crossing" class="headerlink" title="Backtest of zero crossing"></a>Backtest of zero crossing</h3><div class="table-container"><table><thead><tr><th></th><th>LO-ZC</th><th>LS-ZC</th><th>Impact</th></tr></thead><tbody><tr><td>Diagram</td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-LO-ZC-2y.png" class="" width="600"></td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-MN-ZC-2y.png" class="" width="600"></td><td></td></tr><tr><td>No. of trade</td><td>102</td><td>216</td><td><font color="red">+114</font></td></tr><tr><td>Return</td><td>35.98%</td><td>8.27%</td><td><font color="red">-27.71%</font></td></tr><tr><td>Annual Return</td><td>19.8%</td><td>4.779%</td><td><font color="red">-15.021%</font></td></tr><tr><td>Annual Standard Deviation</td><td>0.303</td><td>0.093</td><td><font color="green">-0.21</font></td></tr><tr><td>Max D.D.</td><td>45.0%</td><td>8.3%</td><td><font color="green">-36.7%</font></td></tr><tr><td>Beta</td><td>-0.204</td><td><font color="green">0.014</font></td><td></td></tr><tr><td>Alpha</td><td>0.262</td><td>0.041</td><td><font color="red">-0.221</font></td></tr><tr><td>Sharpe Ratio</td><td>0.714</td><td>0.47</td><td><font color="red">-0.244</font></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>LO: Long-Only strategy, LS: Long-Short strategy, ZC: Zero Crossing</i></p><h3 id="Backtest-of-high-variance"><a href="#Backtest-of-high-variance" class="headerlink" title="Backtest of high variance"></a>Backtest of high variance</h3><div class="table-container"><table><thead><tr><th></th><th>LO-HV</th><th>LS-HV</th><th>Impact</th></tr></thead><tbody><tr><td>Diagram</td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-LO-HV-2y.png" class="" width="600"></td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-MN-HV-2y.png" class="" width="600"></td><td></td></tr><tr><td>No. of trade</td><td>75</td><td>186</td><td><font color="red">+111</font></td></tr><tr><td>Return</td><td>39.1%</td><td>10.66%</td><td><font color="red">-28.44%</font></td></tr><tr><td>Annual Return</td><td>21.446%</td><td>6.136%</td><td><font color="red">-15.31%</font></td></tr><tr><td>Annual Standard Deviation</td><td>0.27</td><td>0.079</td><td><font color="green">-0.191</font></td></tr><tr><td>Max D.D.</td><td>41.00%</td><td>6.200%</td><td><font color="green">-34.80%</font></td></tr><tr><td>Beta</td><td>-0.143</td><td><font color="green">0.037</font></td><td></td></tr><tr><td>Alpha</td><td>0.25</td><td>0.046</td><td><font color="red">-0.204</font></td></tr><tr><td>Sharpe Ratio</td><td>0.806</td><td>0.677</td><td><font color="red">-0.129</font></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>LO: Long-Only strategy, LS: Long-Short strategy, HV: High Variance</i></p><h3 id="Backtest-of-Pearson-Correlation"><a href="#Backtest-of-Pearson-Correlation" class="headerlink" title="Backtest of Pearson Correlation"></a>Backtest of Pearson Correlation</h3><div class="table-container"><table><thead><tr><th></th><th>LO-PC</th><th>LS-PC</th><th>Impact</th></tr></thead><tbody><tr><td>Diagram</td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-LO-PC-2y.png" class="" width="600"></td><td><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/PT-C2-MN-PC-2y.png" class="" width="600"></td><td></td></tr><tr><td>No. of trade</td><td>72</td><td>1438</td><td><font color="red">+1366</font></td></tr><tr><td>Return</td><td>67.72%</td><td>3.9%</td><td><font color="red">-63.82%</font></td></tr><tr><td>Annual Return</td><td>35.522%</td><td>2.272%</td><td><font color="red">-33.25%</font></td></tr><tr><td>Annual Standard Deviation</td><td>0.406</td><td>0.197</td><td><font color="green">-0.209</font></td></tr><tr><td>Max D.D.</td><td>52.200%</td><td>33.90%</td><td><font color="green">-18.30%</font></td></tr><tr><td>Beta</td><td>-0.174</td><td><font color="green">-0.015</font></td><td>+0.159</td></tr><tr><td>Alpha</td><td>0.435</td><td>0.042</td><td><font color="red">-0.393</font></td></tr><tr><td>Sharpe Ratio</td><td>0.975</td><td>0.196</td><td><font color="red">-0.779</font></td></tr></tbody></table></div><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>LO: Long-Only strategy, LS: Long-Short strategy, PC: Pearson Correlation</i></p><h3 id="Summaries"><a href="#Summaries" class="headerlink" title="Summaries"></a>Summaries</h3><p>It’s quite clear to notice the impact after applying the long-short strategy. There are a few insights that we can extract from this series of backtests:</p><div class="table-container"><table><thead><tr><th></th><th>Summarized details</th></tr></thead><tbody><tr><td>Pros</td><td>1. As you short stocks while applying this strategy, you’re actually gaining and preserving more cash for your available cash pool. <br> 2. The volatility KPIs, such as annual standard deviation and max dropdown, are drastically decreased by a certain degree, making your portfolio less volatile.<br> 3. <strong><em>Beta</em></strong> is the indicator of whether your portfolio is highly related to the entire market. Your portfolio will be influenced less by the market fluctuation when the beta is close to 0. After applying the long-short strategy, you can tell that the beta has reduced to one-tenth in every scenario. Compare to the traditional long-only strategy, the long-short strategy suffers less influence during the recession, therefore your portfolio could rebound faster than the long-only strategy. <br><img data-src="/2021/09/30/2021-10-05-pair-trading-market-neutral/long-short-strategy.png" class="" width="400"> <p style="font-size: 0.8em; text-align:center; color: grey;"> <i>The opposite position would help hedge your losing positions, just like the dropdown happened in Apr. 2020 </i> </p></td></tr><tr><td>Cons</td><td>1. Despite it has the benefit of reducing the volatility of your portfolio, the long-short strategy would also hurt the return of your portfolio.<br> 2. How do we evaluate whether applying the long-short strategy brings us more goods than harms or vice versa? We can take a look at the KPI <strong><em>Sharpe ratio</em></strong>. Sharpe ratio indicates the ratio between the risk-free return and the volatility. The decrease in Sharpe ratios in all scenarios does tell us that the long-short strategy takes away more return that can’t be compensated by the ability to withstand the volatility it adds.<br> 3. As you can see in the previous backtest, that the number of transactions increased substantially afterwards in any scenario. The transactional cost of applying this strategy would increase compared to the traditional long-only strategy.</td></tr></tbody></table></div><h1 id="What-are-the-advanced-strategies-that-we-can-explore"><a href="#What-are-the-advanced-strategies-that-we-can-explore" class="headerlink" title="What are the advanced strategies that we can explore?"></a>What are the advanced strategies that we can explore?</h1><p>Ummmm…. It seems like the results we have above don’t really gonna make us enough money to pay our rent. Even though the pair trading strategy that we developed above will help us reduce the volatility of our portfolio return, but the reduced return would really annoy us as this strategy makes us less money. So what are the things we can do in order to optimize this strategy and make it a money-making strategy? Here are a few other variations that we can explore:</p><h2 id="Long-bias-strategy"><a href="#Long-bias-strategy" class="headerlink" title="Long-bias strategy"></a>Long-bias strategy</h2><p>The long-bias strategy would require holding 130% long positions of invested capital and 30% short positions, achieving 100% net in long positions. The benefit of this strategy is that you could obtain more capital (<em>30% more cash from the short position, plus the original 100% capital</em>) to leverage compared to the traditional long-only strategy, which can only leverage 100% of their capital.</p><h2 id="Market-neutral-strategy"><a href="#Market-neutral-strategy" class="headerlink" title="Market neutral strategy"></a>Market neutral strategy</h2><p>Market neutral strategy refers to a type of investment strategy where the investor aims to profit from both an increase and a decrease in paired stock prices. This strategy features zero $\beta$, which makes the portfolio return won’t be impacted by the market fluctuation by hedging the systematic risk.</p><p>The benefits of adopting this strategy are pretty similar to the observation we have above, that applying market neutral strategy will make our portfolio more resilient in combating the economic storm.</p><h2 id="Dollar-neutral-strategy"><a href="#Dollar-neutral-strategy" class="headerlink" title="Dollar neutral strategy"></a>Dollar neutral strategy</h2><p>Similar to market neutral strategy, dollar neutral strategy targets to long the same dollar amount in positions and to short the same dollar amount in positions, rendering leveraging a very little portion of your available cash. The benefit being, you can leverage your positive and negative insights to maximize your portfolio value with very little money needed to be invested.</p><h1 id="Final-words"><a href="#Final-words" class="headerlink" title="Final words"></a>Final words</h1><p>From the performed backtest, we get to know the outcomes of applying long-short strategies and how it impacts your portfolio performance. Long-short strategies and pair trading strategies are never a strategy that can bring you outstanding returns to brag about. However, it is a strategy that can become a gold mine that brings you money slowly and steadily over the long run.</p><hr><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://corporatefinanceinstitute.com/resources/knowledge/strategy/market-neutral/">What is Market Neutral?</a></li><li><a href="https://www.investopedia.com/terms/l/long-shortequity.asp">Long-Short Equity by Investopedia</a></li><li><a href="https://www.investopedia.com/articles/investing/111313/multiple-strategies-hedge-funds.asp">Multiple hedge fund strategies</a></li><li><a href="https://www.investopedia.com/terms/m/marketneutral.asp">Market Neutral</a></li><li><a href="https://www.alliancebernstein.com/CmsObjectABD/PDF/Research_WhitePaper/MarketNeutralWhitepaper06.08.12.pdf">Market-Neutral Strategies: An All-Weather Investment Option</a></li><li><a href="https://www.eurekahedge.com/Research/News/785/13030-Funds-What-is-Behind-the-Commercial-Offensive">130/30 Funds: What is Behind the Commercial Offensive?</a></li></ul><h2 id="Attached-backtest-summarized-report"><a href="#Attached-backtest-summarized-report" class="headerlink" title="Attached backtest summarized report"></a>Attached backtest summarized report</h2><div class="table-container"><table><thead><tr><th><strong>Scenario</strong></th><th><strong>No. of trade</strong></th><th><strong>Return</strong></th><th><strong>Annual Return</strong></th><th><strong>Annual Standard Deviation</strong></th><th><strong>Max DD</strong></th><th><strong>Beta</strong></th><th><strong>Alpha</strong></th><th><strong>Sharpe Ratio</strong></th></tr></thead><tbody><tr><td>LO-BD</td><td>172</td><td>67.45%</td><td>35.393%</td><td>0.304</td><td>38.4%</td><td>-0.161</td><td>0.381</td><td>1.136</td></tr><tr><td>MN-BD</td><td>428</td><td>18.98%</td><td>10.754%</td><td>0.134</td><td>13.900%</td><td>0.036</td><td>0.09</td><td>0.731</td></tr><tr><td>LO-ZC</td><td>102</td><td>35.98%</td><td>19.8%</td><td>0.303</td><td>45.00%</td><td>-0.204</td><td>0.262</td><td>0.714</td></tr><tr><td>MN-ZC</td><td>216</td><td>8.27%</td><td>4.779%</td><td>0.093</td><td>8.3%</td><td>0.014</td><td>0.041</td><td>0.47</td></tr><tr><td>LO-HV</td><td>75</td><td>39.17%</td><td>21.446</td><td>0.27</td><td>41.00%</td><td>-0.143</td><td>0.25</td><td>0.806</td></tr><tr><td>MN-HV</td><td>186</td><td>10.66%</td><td>6.136%</td><td>0.079</td><td>6.200%</td><td>0.037</td><td>0.046</td><td>0.677</td></tr><tr><td>LO-PC</td><td>752</td><td>67.72%</td><td>35.522%</td><td>0.406</td><td>52.200%</td><td>-0.174</td><td>0.435</td><td>0.975</td></tr><tr><td>MN-PC</td><td>1438</td><td>3.9%</td><td>2.272%</td><td>0.197</td><td>33.900%</td><td>-0.015</td><td>0.042</td><td>0.196</td></tr></tbody></table></div><p><strong><em>Do tell me if you feel like this post helped you to some extent or not</em></strong></p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/09/30/2021-10-05-pair-trading-market-neutral/cover.png&quot; class=&quot;&quot; width=&quot;800&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;Previous reading:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@mikelhsia/pair-trading-introduction-to-pair-trading-strategy-c97a1d0897ff&quot;&gt;【Pair Trading】Introduction to pair trading strategy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@mikelhsia/after-knowing-what-the-pair-trading-strategy-is-about-from-the-previous-post-were-going-to-use-98e41ef3ea5&quot;&gt;【Pair Trading】In-depth analysis of 5 distance approach strategies in pair trading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the previous post &lt;a href=&quot;https://medium.com/@mikelhsia/after-knowing-what-the-pair-trading-strategy-is-about-from-the-previous-post-were-going-to-use-98e41ef3ea5&quot;&gt;【Pair Trading】In-depth analysis of 5 distance approach strategies in pair trading&lt;/a&gt;, we have conducted various research against each variation of distance approaches in pair trading strategy. Despite the research has given us probable insights whether there is an &lt;strong&gt;$\alpha$&lt;/strong&gt; exists in the strategy we constructed, we still haven’t established our portfolio construction strategy. Here we introduce a concept called the “long-short equity (LSE)” strategy.&lt;/p&gt;
&lt;p&gt;Therefore, the objectives of this post are consists of three:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What is the long-short equity (LSE) strategy&lt;/li&gt;
&lt;li&gt;Review our backtest results to see the impact of adopting the long-short strategy&lt;/li&gt;
&lt;li&gt;What are the advanced strategies that we can explore&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Research" scheme="http://mikelhsia.github.io/tags/Research/"/>
    
    <category term="Pair Trading" scheme="http://mikelhsia.github.io/tags/Pair-Trading/"/>
    
  </entry>
  
  <entry>
    <title>【Pair Trading】Part 2. 5 in-depth analysis of distance approach in pair trading</title>
    <link href="http://mikelhsia.github.io/2021/08/30/2021-08-30-pair-trading-distance-approach/"/>
    <id>http://mikelhsia.github.io/2021/08/30/2021-08-30-pair-trading-distance-approach/</id>
    <published>2021-08-30T07:50:39.000Z</published>
    <updated>2021-10-12T12:21:24.471Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/cover.jpg" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i></i></p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>Previous readings</strong></th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/">【Pair Trading】Introduction to pair trading strategy</a></td></tr></tbody></table></div><p>After knowing what the pair trading strategy is about from the <a href="https://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/">previous post</a>, we’re going to use the <a href="https://www.quantconnect.com/">QuantConnect platform</a> to research and validate each variation of the <strong><em>distance method</em></strong>. The agenda of this post would be:</p><ol><li><strong>Introduction</strong>: what is the distance approach and what are its variants</li><li><strong>Research methodology</strong>: the methodology we use to conduct this research</li><li><strong>Research and performance analysis</strong>: Implement each variation and compare</li></ol><p>Let’s get it started!</p><a id="more"></a><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/get_started.jpg" class="" width="150"><hr><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The distance approach in pair trading was first popularized by Gatev, Goetzmann, and Rouwenhorst in their <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=141615">academic paper</a> in 2006. This was because of its effectiveness of selecting the paired stocks that track each other well back then. Along with the simplicity in calculating the distance which saves computation resources, this academic paper became the most cited paper of pair trading strategy and derived many different strategies to further discover the relationship between stocks in the stock pair.</p><h2 id="Basic-distance-approach"><a href="#Basic-distance-approach" class="headerlink" title="Basic distance approach"></a>Basic distance approach</h2><p>The basic idea of the distance approach is to use data in the formation period to calculate the <strong>Euclidean squared distances</strong> between each pair of normalized prices during the pair selection process. This <strong>Euclidean squared distance</strong> can be interpreted as the similarity of how do the stock normalized prices move in a defined period. The smaller the <strong>Euclidean squared distance</strong> of a stock pair is, the more similar movements these two assets have. Therefore, we’re going to pick the stock pair that has the smallest <strong>Euclidean squared distance</strong> as its spread should be stable enough to expect the spread will revert when rising to the peak or hitting the rock bottom.</p><script type="math/tex; mode=display">SSD (Sum\ of\ Squared\ Distance) = \sum \limits _{t=1} ^{N} ({P^1}_t - {P^2}_t)^2</script><p style="font-size: 0.8em; text-align:center; color: grey;">    <i><font >The formula of Euclidean squared distance</i></p><h2 id="Variants-of-distance-approach"><a href="#Variants-of-distance-approach" class="headerlink" title="Variants of distance approach"></a>Variants of distance approach</h2><p>Other than using <strong>Euclidean squared distance</strong> to evaluate how two assets are correlated, there are other methods evolving from the basic strategy such as Pearson’s correlation, distance correlation, angular distance, and so on. Also, there are other additional ideas added to the distance approach to discover what is the best-fit stock pair to be traded. The following methods were introduced in the below papers: <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=141615">Gatev et al. (2006): Pairs Trading: Performance of a Relative Value Arbitrage Rule</a>, <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1707125">Do and Faff(2011): Are Pairs Trading Profits Robust to Trading Costs?</a>, <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.547.8922&amp;rep=rep1&amp;type=pdf">Do and Faff (2012): Does Simple Pairs Trading Still Work?</a>. These approaches are:</p><ol><li>Selecting pairs that are in the same industry group</li><li>Selecting pairs with a higher number of zero-crossings</li><li>Selecting pairs with a higher historical variance</li><li>Selecting pairs with a higher Pearson’s correlation</li></ol><h1 id="Research-methodology"><a href="#Research-methodology" class="headerlink" title="Research methodology"></a>Research methodology</h1><p>To find out which one is the most effective method among distance approach and its variants, we have to set up a few rules to make sure that all backtests we are going to perform are tested under the same controlled environment:</p><ol><li>Use the constituents of the S&amp;P 500 index as our universe, meaning we will consider only the stocks that are in the S&amp;P 500 index.</li><li>Take <strong>12+12</strong> months’ daily close price of each stock in our defined universe. Data from the first 12-month period was used to form/train our pair trading model, and then the following 12 months’ data were used to backtest the model against the real-world scenario.</li><li>Normalize price data before we train our pair trading model. Let’s say we have stock A price ranging from \$100 ~ \$180, stock B price sits around \$20.00, and stock C price is over \$1000. The distances between pair A-B and pair B-C won’t be comparable because they don’t share the same starting point. Therefore normalizing price data removes the differences between two stock prices in order to make all pairs comparable.</li><li>As there are <strong>121,771</strong> pairs been generated, we reserve the top 10% and drop the remaining 90% of the under-performed pair in order not to waste time to analyze the pairs that are not significantly correlated.</li><li>Rank the stocks by the possibility of getting a positive return the next day (from high to low). The way to decide the possibility is different in every variant.</li><li>We calculate and analyze the expected return from two different angles in order to evaluate which strategy is better:<br> 6.1. <strong>Stratified analysis</strong>: Separate the stock pairs into 8 groups in order to see whether a higher possibility would actually result in a higher positive return.<br> 6.2. <strong>Long strategy analysis</strong>: Take the first 20 stocks to calculate the expected return so that we won’t take in too many noises into our performance analysis.</li><li>Generate trading signals:<br> 7.1. If the spread value exceeds 1.5 times of the historical deviations of the spread ($1.5\sigma$), generate a sell signal.<br> 7.2. If the spread value drops below 1.5 times of the historical deviations of the spread ($1.5\sigma$), generate a buy signal<br> 7.3. Close the open position when spread crosses over above or below the zero-line of the historical deviation.</li></ol><blockquote><p>Tips:</p><ol><li><code>itertools.combinations()</code> is a good util tool to create combinations contain two different symbols, for example <code>(&#39;AAPL&#39;,&#39;AMZN&#39;)</code></li><li>Normalization formula: $P_{Normalized} = \frac{P - min(P)}{max(P) - min(P)}$.</li><li>$min(P)$ and $max(P)$ are extracted from the formation period, and apply to the price data in backtest period</li></ol></blockquote><h1 id="Research-and-performance-analysis"><a href="#Research-and-performance-analysis" class="headerlink" title="Research and performance analysis"></a>Research and performance analysis</h1><p>Here we’re going to quickly talk about them and then we’ll conduct research and backtest against the basic distance approach and its variants.</p><h2 id="Basic-distance-approach-1"><a href="#Basic-distance-approach-1" class="headerlink" title="Basic distance approach"></a>Basic distance approach</h2><h3 id="Approach-description"><a href="#Approach-description" class="headerlink" title="Approach description"></a>Approach description</h3><p>We calculate the SSD of each pair and take the top 10% pairs which have the smallest SSD to conduct the performance analysis.</p><h3 id="Stratified-analysis"><a href="#Stratified-analysis" class="headerlink" title="Stratified analysis"></a>Stratified analysis</h3><p>Among 8 groups, group 1 contains the pairs that have the smallest SSD, and group 8 contains the pairs that have the biggest SSD. However, group 1 doesn’t seem to generate a positive expected return and group 8 doesn’t induce the relative huge loss as expected. The magnitude of SSD doesn’t seem to positively correlate to the expected return as we expect.</p><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/basic_stratified.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Basic distance approach stratified analysis</i></p><h3 id="Long-strategy-performance-analysis"><a href="#Long-strategy-performance-analysis" class="headerlink" title="Long strategy performance analysis"></a>Long strategy performance analysis</h3><p>If we long 20 the most stable stock pair by picking the pairs that have the smallest SSD, the portfolio still doesn’t generate a positive portfolio return over 12 months.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/basic_top.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Basic distance approach long strategy analysis (Top 20 stocks)</i></p><h2 id="Selecting-pairs-that-are-in-the-same-industry-group"><a href="#Selecting-pairs-that-are-in-the-same-industry-group" class="headerlink" title="Selecting pairs that are in the same industry group"></a>Selecting pairs that are in the same industry group</h2><p>This method holds an assumption that the paired stocks that are in the same industry are more likely to move together. So the idea here is to categorize each company by <a href="https://www.equitieslab.com/wiki/admin/morningstar-sector">Morning Star sector code</a> and pair the stocks within the same sector/industry group. Once we have these pairs from the same industry prepared, then we do exactly the same as the basic distance approach in order to analyze the portfolio performance.</p><h3 id="Stratified-analysis-1"><a href="#Stratified-analysis-1" class="headerlink" title="Stratified analysis"></a>Stratified analysis</h3><p>It’s still a mess. Our group 1 that suppose to make the most profit actually incurred the most loss. The lines that represented the accumulated return of each group tangled tightly instead of staying apart from each other.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/same_industry_stratified.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Same industry distance approach stratified analysis</i></p><h3 id="Stratified-analysis-by-sector"><a href="#Stratified-analysis-by-sector" class="headerlink" title="Stratified analysis by sector"></a>Stratified analysis by sector</h3><p>One more analysis we can do is to see which sector performs the worst. The sectors that perform the worst are <code>101</code> and <code>206</code>, which are the <code>Material</code> and the <code>Health care</code> sectors. Therefore by conducting the stratified analysis by sector, we could potentially initiate another strategy by removing the sectors that perform worse in the first place.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/same_industry_return_by_sector.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Expected return by sector</i></p><h3 id="Long-strategy-performance-analysis-1"><a href="#Long-strategy-performance-analysis-1" class="headerlink" title="Long strategy performance analysis"></a>Long strategy performance analysis</h3><p>It’s quite interesting to tell the line is very similar to the expected return above, meaning the top 20 pairs we picked could highly resemble the top 20 pairs in the basic distance approach. In terms of return, nothing gets improved. But one thing to be noticed is that by creating pairs within the same industry, we reduce the total pair from <strong>121,771</strong> pairs to <strong>13,207</strong> pairs and greatly reduce the time needed for the calculation.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/same_industry_top.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Same industry distance approach long strategy analysis (Top 20 stocks)</i></p><h2 id="Selecting-pairs-with-a-higher-number-of-zero-crossings"><a href="#Selecting-pairs-with-a-higher-number-of-zero-crossings" class="headerlink" title="Selecting pairs with a higher number of zero-crossings"></a>Selecting pairs with a higher number of zero-crossings</h2><p>It’s a good sign that the spread of the paired stocks is stable enough. However, if the spread of a certain pair is way too stable, there will be no chance for the traders to step in and make a profit. Therefore in this variant, among the top 10% pairs that have the smallest <strong>Euclidean squared distance</strong>, we further pick the pairs that had the highest number of crossing the zero-spread line. A high number of zero-crossing gives this pair enough energy to swing up and down, but without losing the ability to maintain its stability and come back to the zero-spread line.</p><p>Here’s a tip to share with you, that it’s fairly simple to calculate the number of zero-crossing if you have your spread in proper time-series format.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Both price_a and price_b are nd.array or pd.Series objects</span></span><br><span class="line">spread = pd.Series((price_a - price_b).reshape(<span class="number">-1</span>))</span><br><span class="line">num_of_zero_crossing = ((spread * spread.shift())&lt;<span class="number">0</span>).sum()</span><br></pre></td></tr></table></figure></p><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/zero-crossing.png" class="" width="500"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Why the number of zero-crossing matters</i></p><h3 id="Stratified-analysis-2"><a href="#Stratified-analysis-2" class="headerlink" title="Stratified analysis"></a>Stratified analysis</h3><p>Now we do see the differences by adding the zero-crossing criteria. The first two groups that have the highest number of zero-crossing did stand out in the accumulated performance. However, the expected return of low zero-crossing pairs doesn’t tell us that we can count on this to form a market-neutral strategy. Maybe a long-only strategy would be better off.</p><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/zerocrossing_stratified.png" class="" width="600"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Zero-crossing distance approach stratified analysis</i></p><h3 id="Long-strategy-performance-analysis-2"><a href="#Long-strategy-performance-analysis-2" class="headerlink" title="Long strategy performance analysis"></a>Long strategy performance analysis</h3><p>It does! THe long-only strategy definitely helps gradually accumulate our portfolio return. This diagram kind of proving our assumption that the high value of zero-crossing would single out the pairs that are more resilient and are capable of reverting back to the normal spread level.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/zerocrossing_top.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Zero-crossing distance approach long strategy analysis (Top 20 stocks)</i></p><h2 id="Selecting-pairs-with-higher-historical-variance"><a href="#Selecting-pairs-with-higher-historical-variance" class="headerlink" title="Selecting pairs with higher historical variance"></a>Selecting pairs with higher historical variance</h2><p>This variant actually used the same idea as above <code>Selecting pairs with a higher number of zero-crossings</code>. Instead of using the number of zero-crossings, this method takes the high variance as the sign of the spread between the paired stocks being fluctuated enough to be traded.</p><h3 id="Stratified-analysis-3"><a href="#Stratified-analysis-3" class="headerlink" title="Stratified analysis"></a>Stratified analysis</h3><p>Um…. Don’t even bother talking about this diagram. This result obviously tells us that this variant is not a fit for market neutral strategy.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/high_variance_stratified.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>High variance distance approach stratified analysis</i></p><h3 id="Long-strategy-performance-analysis-3"><a href="#Long-strategy-performance-analysis-3" class="headerlink" title="Long strategy performance analysis"></a>Long strategy performance analysis</h3><p>Even though the accumulated return looks weaker than the return from the high zero-crossing long strategy, we still can expect this long-only strategy to perform well.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/high_variance_top.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>High variance distance approach long strategy analysis (Top 20 stocks)</i></p><h2 id="Selecting-pairs-with-higher-Pearson’s-correlation"><a href="#Selecting-pairs-with-higher-Pearson’s-correlation" class="headerlink" title="Selecting pairs with higher Pearson’s correlation"></a>Selecting pairs with higher <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson’s correlation</a></h2><p>This method is relatively more complex than the above methods. This variant is mentioned in the paper <a href="http://www.pbcsf.tsinghua.edu.cn/research/chenzhuo/paper/Empirical%20Investigation%20of%20an%20Equity%20Pairs%20Trading%20Strategy.pdf">Chen et al. (2012): Empirical Investigation of an Equity Pairs Trading Strategy</a>, and the paper <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3608896">Christopher Krauss (2015): Statistical arbitrage pairs trading strategies: Review and outlook</a>.</p><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/one_track_many.jpeg" class="" width="400"><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>One tracks a group of assets instead of tracking just one</i></p><p>The idea of this method is that we’re going to use the composition of 50 stocks as the benchmark to calculate the spread against the target asset. In this way, we’ll be able to diversify the specific risk by comparing it to a basket of stocks. To do this, we will need to use Pearson’s correlation to pick out the 50 most related assets to construct the benchmark portfolio of the target asset. Then instead of using historical deviation ($1.5 \sigma$) as the threshold to trigger our trading signals, we use <strong><a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html">linear regression</a></strong> to construct the relation between two stocks and then use calculated $\alpha$ and $\beta$ to calculate the deviation. The higher the number of the deviation, the more likely deviation will revert.</p><script type="math/tex; mode=display">Deviation = R_{jt} - \alpha\ +\ \beta \times R_{it}</script><p>$where$</p><p>$R_{jt}$ is the return of the pairs portfolio</p><p>$R_{it}$ is the stock return</p><h3 id="Stratified-analysis-4"><a href="#Stratified-analysis-4" class="headerlink" title="Stratified analysis"></a>Stratified analysis</h3><p>This time we do something easier. We pick the top 20 stocks that deviate the most from its benchmark portfolio and long them and pick the bottom 20 pairs that deviate least and short them.</p><p>This would be the perfect variant to formulate both the market-neutral strategy and the long-only strategy. The return of the stocks we long go straight up and the return of the stocks we short go down. In the meantime, both lines are negatively correlated. When the green line drop below the bottom and break through the zero lines, the red line (the return of the stocks we short) revert and recover the loss from the green line. By longing the top 20 and shorting the bottom 20, we perfectly form the market-neutral strategy that still makes a positive return over 12 months including the bear market.<br><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/pearson_correlation.png" class="" width="600"></p><p style="font-size: 0.8em; text-align:center; color: grey;">    <i>Pearson's correlation distance approach market neutral strategy</i></p><p><br></p><p><br><div style="border: 2pt solid lightgrey;border-radius: 4pt;box-shadow: 7px 7px lightgrey;padding: 1.3em;width:50%;margin:auto;"><i><b style="font-size:1.3em;padding: 1.3em;color:grey;">"Home Run!"</b></i><img data-src="/2021/08/30/2021-08-30-pair-trading-distance-approach/homerun.jpg" class="" width="300"></div><br></p><h1 id="Final-words-and-next-step"><a href="#Final-words-and-next-step" class="headerlink" title="Final words and next step"></a>Final words and next step</h1><p>Through the above researches, you can tell that the pair trading strategy is consist of four parts:</p><ol><li>Pair selection</li><li>Model formation (to form $\sigma$ or benchmark return in Pearson’s correlation variant)</li><li>Monitoring the current stats</li><li>Generate trading signals against the trained model</li></ol><p>The most important part I believe would be the pair selection part as I believe it’s crucial to find the pair/stock that does bounce back when the spread/price hit the ceiling and the floor. So essentially it’s still considered a mean reversion strategy.</p><p>Even though we have found our perfect strategy among these five variants, there are many things that we haven’t looked at such as:</p><ol><li>Should we use the rolling window to constantly update our model?</li><li>Should we trade more than 20 stocks at a time?</li><li>Should we find some other formulas to replace the Pearson’s correlation in order to find the more correlated paired stocks?</li><li>Should we expand the <strong>whole</strong> universe instead of only looking at the stocks in S&amp;P 500?</li></ol><p>These can be the potential improvements that can be experimented with. Also, make sure you run the proper backtest using the backtesting platform as <a href="https://www.quantconnect.com/">QuantConnect</a> or <a href="https://www.joinquant.com/">JointQaunt</a> to make sure you validate your algorithm against the real-world scenario.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://opencodecom.net/post/2021-04-30-pairs-trading-replicating-gatev-goetzmann-and-rouwenhorst-2006/">Pairs Trading: Replicating Gatev, Goetzmann and Rouwenhorst (2006)</a></li><li><a href="https://hudsonthames.org/research/">Hudson &amp; Thames Official website</a></li><li><a href="https://www.youtube.com/channel/UC8hI87gt0dmTAIEupEcsckA">Hudson &amp; Thames Youtube channel</a></li><li><a href="http://www.pbcsf.tsinghua.edu.cn/research/chenzhuo/paper/Empirical%20Investigation%20of%20an%20Equity%20Pairs%20Trading%20Strategy.pdf">Empirical Investigation of an Equity Pairs Trading Strategy</a></li><li><a href="https://www.quantconnect.com/tutorials/strategy-library/pairs-trading-with-stocks">QuantConnect Tutorials - Pair trading with stocks</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/08/30/2021-08-30-pair-trading-distance-approach/cover.jpg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;font-size: 0.8em; text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;&lt;/i&gt;
&lt;/p&gt;

&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;strong&gt;Previous readings&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/&quot;&gt;【Pair Trading】Introduction to pair trading strategy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;After knowing what the pair trading strategy is about from the &lt;a href=&quot;https://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/&quot;&gt;previous post&lt;/a&gt;, we’re going to use the &lt;a href=&quot;https://www.quantconnect.com/&quot;&gt;QuantConnect platform&lt;/a&gt; to research and validate each variation of the &lt;strong&gt;&lt;em&gt;distance method&lt;/em&gt;&lt;/strong&gt;. The agenda of this post would be:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Introduction&lt;/strong&gt;: what is the distance approach and what are its variants&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Research methodology&lt;/strong&gt;: the methodology we use to conduct this research&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Research and performance analysis&lt;/strong&gt;: Implement each variation and compare&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let’s get it started!&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Research" scheme="http://mikelhsia.github.io/tags/Research/"/>
    
    <category term="Pair Trading" scheme="http://mikelhsia.github.io/tags/Pair-Trading/"/>
    
  </entry>
  
  <entry>
    <title>【Pair Trading】Part 1. Introduction to pair trading strategy</title>
    <link href="http://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/"/>
    <id>http://mikelhsia.github.io/2021/08/02/2021-08-12-pair-trading/</id>
    <published>2021-08-02T07:02:21.000Z</published>
    <updated>2021-10-12T12:21:24.470Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/08/02/2021-08-12-pair-trading/cover.jpg" class="" width="600"><p style="text-align:center; color: grey;">    <i>Pair trading is just like a man leashing a dog. They never apart too far away.</i></p><p>New Column started! In this new column, we’re going to start by introducing the idea and principle behind this famous strategy. In the later posts, we’ll do research using different famous methods in pair trading. Hopefully, we’ll cover the fundamental knowledge of pair trading as much as possible.</p><p>Pairs trading is among the most popular trading strategies in many markets. This particular strategy involves simultaneous taking two correlated assets in different directions, using one asset in the pair to hedge the risk of the other one. Essentially, it is a market-neutral strategy.</p><a id="more"></a><h1 id="What-is-the-pair-strategy"><a href="#What-is-the-pair-strategy" class="headerlink" title="What is the pair strategy?"></a>What is the pair strategy?</h1><p>Imagine this, if there are two convenience stores (A &amp; B) opened in one area. They import their ingredients from the same farm and sell the same meat product at the same price <code>$10</code>. Both stores are making a good profit. As the product price of both stores tracks closely to each other, it’s expected that there won’t be a big difference in prices.</p><img data-src="/2021/08/02/2021-08-12-pair-trading/stores.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>Store A and store B</i></p><p>One day, the farm raises the price of the ingredient, causing the owner of store A to decide to raise the price to <code>$12</code> to spread the cost to his customers. Unfortunately, the owner of store B was out of town so the price in store B stays at <code>$10</code>. According to our past experience, we expect the price difference to converge after the owner of store B comes back to town. As a clever consumer, what you should do to get benefits from this opportunity?</p><p>Should we buy more products from store B and store them in our warehouse at a cheaper price? Nah…. What if the farm again drops the price so that the product price would incline to drop as well. Our stock in the warehouse would be considered overpriced. The risk of taking either asset in one direction would be considered tremendous.</p><p>…</p><p>I believe as clever as you have already come up with the plan. We can buy the lower-priced product from store B, and sell it to the customers who want to buy the higher-priced product from store A. By doing that, there will be a <code>$2</code> profit <strong>per trade</strong>. We treat the price in store A and the price in store B as a pair. Whenever a price difference expands to certain degree, we could leverage the same strategy to buy the cheap one and sell the other expensive one. This can be exploited over and over again as long as the relationship between the price in store A and the price in store B doesn’t go away.</p><p>And, that is the pair trading strategy.</p><h1 id="History-of-pair-strategy"><a href="#History-of-pair-strategy" class="headerlink" title="History of pair strategy"></a>History of pair strategy</h1><p>Pair trading is a methodology and practice that derive from statistical arbitrage trading. It first appeared in the theory developed by Australian investor and hedge fund manager Alfred Winslow Jones in the 1950s. However, due to the nature of the pair trading strategy, these strategies were not made possible until the 1980s when computers gradually become popular.</p><p>In 1987, Morgan Stanley disclosed the fact that they have made over 50 million dollars on pair trading strategy. The money at that time was like 10 times more valuable than the same amount today. Therefore you could imagine the amount of money they have made with a single strategy. Even the details of this strategy were revealed over time, the pair strategy is still the most popular market-neutral strategy these days.</p><p>I learn from <a href="https://blog.pairtradefinder.com/best-trading-strategy-ever/">here</a> that pair strategy has been identified as the trading strategy used by <a href="https://en.wikipedia.org/wiki/Jim_Simons_(mathematician"><strong><em>Jim Simons</em></strong></a>), the most successful and smart hedge fund manager. He has publicly stated that the strategy his hedge fund adopting is contrarian: <code>often buying stocks (that) recently out of favor, and selling those recently in favor</code>.</p><p><div><iframe width='300' src="https://www.youtube.com/embed/lnSGgfv7Fv0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div></p><p style="text-align:center; color: grey;">  <i>The Founder and President of Renaissance Technologies had to say publicly in Congressional testimony</i></p><p><br><div style="border: 2pt solid lightgrey;border-radius: 4pt;box-shadow: 7px 7px lightgrey;padding: 1.3em;width:80%;margin:auto;"><i><b style="font-size:1.3em;padding: 1.3em;color:grey;">"We often buying stocks (that) recently out of favor, and selling those recently in favor"</b></i></div><br></p><h1 id="The-principle-of-pair-trading"><a href="#The-principle-of-pair-trading" class="headerlink" title="The principle of pair trading"></a>The principle of pair trading</h1><p>Even though with all these talks and examples to explain what pair trading is, the principle of the pair trading is actually surprisingly simple. First we need to find out the right pair that the price movements of two assets follow a pattern. Let’s take the stock pair <code>KEY-RF</code> for example.</p><img data-src="/2021/08/02/2021-08-12-pair-trading/step1.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>The correlation between KEY and RF is fairly high</i></p><p>The price movements of <strong>KeyCorp(<a href="https://finance.yahoo.com/quote/KEY/">KEY</a>)</strong> and <strong>Regions Financial Corporation(<a href="https://finance.yahoo.com/quote/RF/">RF</a>)</strong> are very similar. But how similar they are? One way to do it is to check the price difference between their prices, which is called the <code>spread</code>. Therefore in the second step, we create a diagram of the spread to monitor the historic spread movement. To better understand the movement of spread, we marked the mean of the spread with the black dotted line, marked the threshold <code>mean + 1.5 * STD</code> and <code>mean - 1.5 * STD</code> to denote the area above and under the threshold are anomalies. As long as the spread breaks through the upper threshold, then we consider this a long signal. Once the movement drops to the mean of the spread, we consider the movement has restored to the normal level, so close the related positions.</p><img data-src="/2021/08/02/2021-08-12-pair-trading/step2.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>The price spread between `KEY` and `RF`, and the green triangle denotes the long signal.</i></p><p>The last rule we need to follow is, we long the cheaper asset and short the more expensive asset in the pair. Again taking the <code>KEY-RF</code> pair for example, if we follow the trigger generated in the above diagram, we gain $\$19 - \$9 = \$10.0$ from the <code>KEY</code> we short, and we lost $\$15.8 - \$8 = \$7.8$ from the <code>RF</code> we long. Combining the P&amp;L of these paired assets, we actually earned $\$10.0 - \$7.8 = \$2.2$ in this trade. In short, the profit earned from the pair trading strategy is not from the movement of the stock’s intrinsic value, but from the anticipation of the shrinkage of the price spread.</p><img data-src="/2021/08/02/2021-08-12-pair-trading/step3.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>KEY has recovered more return than what RF lost</i></p><p>To summarize everything in very simple words, there are only three steps to implement and execute the pair trading strategy:</p><ol><li>Find the target paired assets and how they are correlated</li><li>Monitor the movement to see when to generate the trading signals</li><li>Long the cheaper and short the more expensive when we see the trading signals.</li></ol><h1 id="How-to-find-the-pair-that-works"><a href="#How-to-find-the-pair-that-works" class="headerlink" title="How to find the pair that works?"></a>How to find the pair that works?</h1><p>So it all comes down to the question of how to find the right pair to trade. If two assets in your selected pair are not correlated or if they are correlated but the spread will not converge, then they are not the right pair to trade. Here are three methods you can use to try finding the right pair.</p><h2 id="According-to-business-models"><a href="#According-to-business-models" class="headerlink" title="According to business models"></a>According to business models</h2><p>We can choose two assets that are similar in their business model because they are suffering the same environmental risk, business risk, infrastructure risk, …, as well as external opportunities. As a result, their price movement has the inclination to move in the same direction with the same magnitude. A potentially good pair could be <code>UBER</code> v.s. <code>LYFT</code>, or <code>CCL</code> v.s. <code>RCL</code>.</p><img data-src="/2021/08/02/2021-08-12-pair-trading/cclvsrcl.png" class="" width="500"><p style="text-align:center; color: grey;">  <i>CCL vs RCL in normalized price movement</i></p><h2 id="According-to-the-professional-knowledge"><a href="#According-to-the-professional-knowledge" class="headerlink" title="According to the professional knowledge"></a>According to the professional knowledge</h2><p>As the business models are the public information that is accessed by you and tens of thousands of people/institutions, the profit generated from this type of trading pair can fade away very quickly as so many parties are exploiting the same opportunity. To gain an edge competing with others, you need to study and work harder to keep yourself from competing with others in the red ocean.</p><p>If you understand the business models in a bigger picture, you can put all the small pieces of information together to solve the puzzles. For example, you get to learn that company B is the sole supplier of company A. So if company A makes a good profit in the fiscal year, then you can expect company B will make a good profits as well. If not, there might be a chance for arbitrages. Or, if you find out that an ETF was tracking with a stock index like S&amp;P 500, you can trade when the spread between the ETF and the index expends and close this trade when the spread converges. You can spot more and more opportunities like this when you understand the assets or the market more,</p><h2 id="According-to-the-pair-correlation-and-cointegration"><a href="#According-to-the-pair-correlation-and-cointegration" class="headerlink" title="According to the pair correlation and cointegration"></a>According to the pair correlation and cointegration</h2><p>This method is more of a mathematical way to find the right pair of assets. This post is already long enough, so you can check out this <a href="https://www.quora.com/What-is-the-difference-between-correlation-and-cointegration-Is-cointegration-a-good-measure-of-risk">Quora thread</a> before we get to this topic in the following post.</p><h1 id="Pair-trading-methods"><a href="#Pair-trading-methods" class="headerlink" title="Pair trading methods"></a>Pair trading methods</h1><p>Christopher Krauss has summarized various pair trading methods in his dissertation on <a href="https://www.econstor.eu/bitstream/10419/116783/1/833997289.pdf">Statistical arbitrage pairs trading strategies</a>. The methods are:</p><img data-src="/2021/08/02/2021-08-12-pair-trading/methods.png" class="" width="600"><p style="text-align:center; color: grey;">  <i>Extracted from <a href='https://www.youtube.com/watch?v=gd009r7QUuM&list=PLfv9eTYgatm3oz8uq8G17-50ed_s-n5ds&index=2&t=238s'>Pairs Trading: The Distance Approach</a> by <a href='https://www.youtube.com/channel/UC8hI87gt0dmTAIEupEcsckA'>Hudson & Thames</a></i></p><p>We will cover these methods one by one in the following series.</p><h1 id="Pair-trading-resources"><a href="#Pair-trading-resources" class="headerlink" title="Pair trading resources"></a>Pair trading resources</h1><ul><li><a href="https://hudsonthames.org/">Hudson &amp; Thames</a><ul><li>It’s a research institution that puts a lot of effort into working on pair trading strategies. It also has a dedicated python library for people who are interested in working with pair trading strategies. Check out <a href="https://hudsonthames.org/research/">their blog here</a> for more articles related to what they are doing.</li></ul></li><li><a href="https://blog.pairtradefinder.com/">Pair Trading Finder</a> is a blog that publishes its research regularly. Other than telling you their latest research results, they even share the best pair of stocks of the month to be traded.</li></ul><p>In the next post, we’ll start looking at how to build our first pair trading strategy using the distance approach.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://www.newtraderu.com/2017/06/05/nature-pair-stock-trading-history/">The Nature of Pair Stock Trading History</a></li><li><a href="https://en.wikipedia.org/wiki/Pairs_trade">Pairs trade from Wikipedia</a></li><li><a href="https://www.investopedia.com/terms/p/pairstrade.asp">Pairs trade from investopedia</a></li><li><a href="https://blog.pairtradefinder.com/best-trading-strategy-ever/">The Best Trading Strategy Ever? The Results Speak for Themselves…</a></li><li><a href="https://algotrading101.com/learn/pairs-trading-guide/">Pairs Trading – A Real-World Guide</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/08/02/2021-08-12-pair-trading/cover.jpg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p style=&quot;text-align:center; color: grey;&quot;&gt;
    &lt;i&gt;Pair trading is just like a man leashing a dog. They never apart too far away.&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;New Column started! In this new column, we’re going to start by introducing the idea and principle behind this famous strategy. In the later posts, we’ll do research using different famous methods in pair trading. Hopefully, we’ll cover the fundamental knowledge of pair trading as much as possible.&lt;/p&gt;
&lt;p&gt;Pairs trading is among the most popular trading strategies in many markets. This particular strategy involves simultaneous taking two correlated assets in different directions, using one asset in the pair to hedge the risk of the other one. Essentially, it is a market-neutral strategy.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Research" scheme="http://mikelhsia.github.io/tags/Research/"/>
    
    <category term="Pair Trading" scheme="http://mikelhsia.github.io/tags/Pair-Trading/"/>
    
  </entry>
  
  <entry>
    <title>Optimize your MACD strategies with advanced indicators</title>
    <link href="http://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/"/>
    <id>http://mikelhsia.github.io/2021/07/19/2021-07-20-advanced-macd-strategy/</id>
    <published>2021-07-18T18:35:44.000Z</published>
    <updated>2021-11-09T04:14:24.293Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/cover.png" class="" width="600"><style>.foo table th:nth-of-type(1){width: 5%;}.foo table th:nth-of-type(2){width: 10%;}.foo table th:nth-of-type(3){width: 10%;}.foo table th:nth-of-type(4){width: 45%;}.foo table th:nth-of-type(5){width: 30%;}</style><p><br><br>In the post <a href="https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/">How to save your silver bullets with MACD strategy?</a>, we have backtested the strategy of MACD and the other six different momentum indicators. In the end, the combination of MACD and the awesome oscillator is the better and seemingly profitable one among all six combinations. But, we won’t stop right there. In order to raise our portfolio win rate and return, we will discuss a few variants of MACD and Awesome Oscillator to derive different buy and sell signals.</p><a id="more"></a><hr><h1 id="Objective"><a href="#Objective" class="headerlink" title="Objective"></a>Objective</h1><p>How to calculate the MACD and awesome oscillator and the others have been introduced in <a href="https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/">How to save your silver bullets with MACD strategy?</a>, so we’re skipping all the entry-level knowledge. Instead, we’re going to touch on how to utilize the generated indicators to put together the strategies that are profitable.</p><p>I have found three different ways to generate MACD trading signals and four to generate awesome oscillator trading signals. Therefore, we will conduct $3 * 4 = 12$ backtest to see which combination would bring us more profits.</p><hr><h1 id="About-the-trading-strategy"><a href="#About-the-trading-strategy" class="headerlink" title="About the trading strategy"></a>About the trading strategy</h1><h2 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h2><p>As said in the previous post, Quantopian has already retired from the market. So I need to migrate the original trading script from Quantopian to <a href="https://www.quantconnect.com/">QuantConnect</a>. To know more details about QuantConnect, you can check out the post <a href="https://mikelhsia.github.io/2021/07/18/2021-07-05-pros-cons-of-quantconnect/">Step up your game in Quant trading - Backtest platforms QuantConnect v.s. Quantopian review</a></p><h2 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h2><p>Universe stands for a group of specific securities that are traded in the market. We are not going to put all the tradable securities in our basket because:</p><ul><li>Save memory and time while running our trading script.</li><li>Not all securities in the market work well with the momentum strategy.</li><li>Remove market noise by selecting the best fitting securities and put them into our universe.</li></ul><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/decidophobia.png" class="" width="600"><p style="text-align:center; color: grey;">    <i>Universe could help you focus on the securities that best-fit your strategy</i></p><p>So picking our universe would be an essential step to avoid decidophobia in selecting the numerous securities in the market.</p><p>Here my assumption is that the securities in the <code>technology</code> sector would be influenced by the momentum factor the most. So we’re picking the technology stocks and sort them by <code>pbRatio</code>, <code>EPS</code>, <code>ROE</code>.</p><h2 id="Prepping-MACD-and-Awesome-Oscillator-indicators"><a href="#Prepping-MACD-and-Awesome-Oscillator-indicators" class="headerlink" title="Prepping MACD and Awesome Oscillator indicators"></a>Prepping MACD and Awesome Oscillator indicators</h2><p>We are using the traditional MACD and awesome oscillator setup and no additional twist.</p><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/indicators.png" class="" width="500"><p style="text-align:center; color: grey;">    <i>MACD and Awesome Oscillator indicators setup</i></p><h2 id="MACD-and-Awesome-Oscillator-signals"><a href="#MACD-and-Awesome-Oscillator-signals" class="headerlink" title="MACD and Awesome Oscillator signals"></a>MACD and Awesome Oscillator signals</h2><p>To follow the mindset of our previous strategy setup, we need both MACD and awesome oscillator trading signals to be true in order to trigger buy or sell actions. Here we extend our strategy and use three different ways to generate trading signals using MACD indicators:</p><blockquote><p>I. Simple MACD: We set our MACD trading signal to <code>True</code> when MACD is greater than 0, and to <code>False</code> when MACD is lower than 0.</p></blockquote><p>By the definition of <code>Talib</code> python package, MACD indicates $EMA_{short\ term} - EMA_{long\ term}$. So the <code>True</code> trading signal essentially telling you that the target stock price rising speed is faster than before.</p><blockquote><p>II. Signal MACD: We set our MACD trading signal to <code>True</code> when our MACD signal is over MACD, and set to <code>False</code> when MACD signal is below MACD.</p></blockquote><p>MACD signal passing above MACD shows the start of the up-trending momentum.</p><blockquote><p>III. Historic MACD: Set MACD trading signal to <code>True</code> when Hist[n] &gt; 0 and Hist[n-1] &lt; 0 and Hist[n-2] &lt; 0, while n is the current date.</p></blockquote><p>This strategy is meant to capture the scenarios when the momentum is about to revert. So we are going to buy when the MACD histogram bar turns from red to green, and to sell when the bar turns from green to red in order to capture the movement between peak and bottom. See the below illustration for the exact trading timing.</p><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/macd_hist.png" class="" width="400"><p style="text-align:center; color: grey;">    <i>MACD histogram stands for the beginning of a upward/downward trend</i></p><p>In the meantime, there are four different ways to generate trading signals using awesome indicators:</p><blockquote><p>I. Simple AO: We set our AO trading signal to <code>True</code> when the value of AO is greater than 0.</p></blockquote><p>By the definition of the AO indicator, we will execute the buy and sell action only when</p><script type="math/tex; mode=display">SMA(\frac{(High - Low)}{2},\ 5\ periods) > SMA(\frac{(High - Low)}{2},\ 34\ periods)</script><p>, which shows a strong up/down trending momentum in the recent five days.</p><blockquote><p>II. Historic AO: We set our AO trading signal to <code>True</code> when AO[n-2], AO[n-1] &lt; 0, AO[n] &gt; 0 where n is the current date.</p></blockquote><p>The disadvantage of the previous method is that we couldn’t judge whether the signal was triggered at the beginning or at the end of the up-trend. To be able to do that, we can add a queue to store the AO values of the previous day. So we can advance our strategy to <code>Turn green light when we have a green bar after we received two consecutive red bars</code>.</p><blockquote><p>III. AO Saucer</p></blockquote><p>This is a traditional AO strategy. We set our buy signal to <code>True</code> when the AO is above the zero-line and the AO histogram having two consecutive red bars where the second red bar is smaller than the first red one and the third bar of the histogram is green. On the contrary, we’ll launch a sell signal when the opposite signals were triggered.</p><blockquote><p>IV. Lame Oscillator</p></blockquote><p>This is an alternative AO strategy that I found in <a href="https://medium.com/swlh/creating-a-profitable-version-of-the-macd-oscillator-trading-differently-ae3da2fe9728">this post</a>. The Lame Oscillator is the mirror view image of the Awesome Oscillator, where</p><script type="math/tex; mode=display">Lame Oscillator = - Awesome Oscillator = - (EMA_{short\ term} - EMA_{long\ term})</script><p>And with <code>go long (buy) whenever the bars change to green</code>, you actually turning a momentum indicator (<em>awesome oscillator</em>) into a mean-reversion indicator (<em>lame oscillator</em>).</p><h2 id="Backtest-setup"><a href="#Backtest-setup" class="headerlink" title="Backtest setup"></a>Backtest setup</h2><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>We started our backtest from 2020/01/03 to 2021/06/30.</p><p>During this backtest period, there are events that caused the market to be very volatile, such as:</p><ol><li>COVID-19 caused the market to plummet at the beginning of 2020</li><li>US oil prices turned negative for the first time in history on April 20th, 2020.</li><li>Tesla stock price rocket high since added into S&amp;P 500 on Dec 21st, 2020.</li><li>Nasdaq and S&amp;P 500 to record high on June 22nd, 2021.</li></ol><p>This process of gradually recovering from the great landslide is an excellent case to validate whether our portfolio outgrows the other securities.</p><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/spy.png" class="" width="600"><p style="text-align:center; color: grey;">    <i>SPY benchmark return from 2020/01/03 to 2021/06/30</i></p><h3 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a>Capacity</h3><p>The maximum number of positions in our portfolio is <code>20</code>. This is a number that I feel comfortable with and enough to diversify the risk. Also keeping the capacity at 20 won’t generate too much transaction cost to reduce our profit earned.</p><h3 id="Benchmark-equity"><a href="#Benchmark-equity" class="headerlink" title="Benchmark equity"></a>Benchmark equity</h3><p><code>SPDR S&amp;P 500 (SPY)</code></p><hr><h1 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h1><p>As instructed in <a href="https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/">How to save your silver bullets with MACD strategy?</a>, we combined our MACD indicator with secondary indicator, awesome indicator, and place buy/sell order only when both signals are <code>True</code>. By having three types of MACD trading signals and four types of awesome oscillator trading signals, we’re going to conduct backtest against each combination in order to find valuable insights:</p><table><thead><tr style='background: lightgrey;'><th>No.</th><th>MACD</th><th>AO</th><th>PSR</th><th>Unrealized</th><th>Fee</th><th>Net profit</th><th>Return</th><th>Total Trades</th><th>Sharpe</th><th>Average Win</th><th>Average Loss</th><th>Compounding annual return</th><th>Profit-loss ratio</th><th>Win rate</th><th>Alpha</th><th>Beta</th><th>Annual STD</th><th>Information ratio</th><th>Treynor ratio</th></tr></thead><tbody><tr><td style='background: green; color: white;'>1</td><td style='background: green; color: white;'>simple</td><td style='background: green; color: white;'>simple</td><td>63.632%</td><td>12580.06</td><td>-901.77</td><td>66572.85</td><td>78.28%</td><td>386</td><td>1.53</td><td>0.57%</td><td>-0.42%</td><td>47.336%</td><td>1.34</td><td>71%</td><td>0.479</td><td>-0.194</td><td>0.284</td><td>0.505</td><td>-2.246</td></tr><tr><td style='background: green; color: white;'>2</td><td style='background: green; color: white;'>simple</td><td style='background: green; color: white;'>history</td><td>34.555$</td><td>5468.21</td><td>-602.82</td><td>81386.32</td><td>86.30%</td><td>235</td><td>1.024</td><td>1.09%</td><td>-0.62%</td><td>51.747%</td><td>1.76</td><td>71%</td><td>0.75</td><td>-0.141</td><td>0.702</td><td>0.65</td><td>-5.101</td></tr><tr><td style='background: green; color: white;'>3</td><td style='background: green; color: white;'>simple</td><td style='background: green; color: white;'>saucer</td><td>85.070%</td><td style='background: red; color: white;'>77031.19</td><td>-67.35</td><td>10746.71</td><td>87.77%</td><td style='background: red; color: white;'>30</td><td>2.152</td><td>2.66%</td><td>-0.28%</td><td>52.547%</td><td>9.68</td><td>80%</td><td>0.457</td><td>-0.037</td><td>0.208</td><td>0.659</td><td>-12.102</td></tr><tr><td style='background: green; color: white;'>4</td><td style='background: green; color: white;'>simple</td><td style='background: green; color: white;'>lame</td><td>77.616%</td><td style='background: red; color: white;'>89100.19</td><td>-626.11</td><td>34429.91</td><td>122.96%</td><td>310</td><td>2.038</td><td>1.10%</td><td>-0.55%</td><td>71.163%</td><td>1.98</td><td style='background: red; color: white;'>46%</td><td>0.667</td><td>-0.133</td><td>0.313</td><td>0.966</td><td>-4.8</td></tr><tr><td style='background: green; color: white;'>5</td><td style='background: green; color: white;'>signal</td><td style='background: green; color: white;'>simple</td><td>62.294%</td><td>2891.42</td><td>-1552.71</td><td>81655.38</td><td>77.26%</td><td>784</td><td>1.504</td><td>0.39%</td><td>-0.55%</td><td>46.771%</td><td>0.72</td><td>75%</td><td>0.474</td><td>-0.192</td><td>0.287</td><td>0.494</td><td>-2.247</td></tr><tr><td style='background: green; color: white;'>6</td><td style='background: green; color: white;'>signal</td><td style='background: green; color: white;'>history</td><td>64.655%</td><td>18826.02</td><td>-865.60</td><td>80217.01</td><td>98.23%</td><td>370</td><td>1.613</td><td>0.78%</td><td>-0.81%</td><td>58.193%</td><td>0.96</td><td>74%</td><td>0.595</td><td>-0.21</td><td>0.34</td><td>0.705</td><td>-2.606</td></tr><tr><td style='background: green; color: white;'>7</td><td style='background: green; color: white;'>signal</td><td style='background: green; color: white;'>saucer</td><td>58.717%</td><td>9274.61</td><td>-498.98</td><td>60188.65</td><td>69.03%</td><td>210</td><td>1.386</td><td>0.93%</td><td>-1.01%</td><td>42.165%</td><td>0.92</td><td>78%</td><td>0.427</td><td>-0.152</td><td>0.283</td><td>0.41</td><td>-2.588</td></tr><tr><td style='background: green; color: white;'>8</td><td style='background: green; color: white;'>signal</td><td style='background: green; color: white;'>lame</td><td>45.533%</td><td>3227.54</td><td>-1648.22</td><td>45332.09</td><td style='background: red; color: white;'>46.94%</td><td>842</td><td>1.038</td><td>0.46%</td><td>-0.42%</td><td>29.427%</td><td>1.08</td><td style='background: red; color: white;'>58%</td><td>0.326</td><td>-0.178</td><td>0.275</td><td>0.15</td><td>-1.602</td></tr><tr><td style='background: green; color: white;'>9</td><td style='background: green; color: white;'>history</td><td style='background: green; color: white;'>simple</td><td>61.309%</td><td>2243.49</td><td>-1079.29</td><td>69660.57</td><td>70.87%</td><td>393</td><td>1.449</td><td>0.64%</td><td>-0.46%</td><td>43.203%</td><td>1.39</td><td>67%</td><td>0.436</td><td>-0.173</td><td>0.274</td><td>0.425</td><td>-2.3</td></tr><tr><td style='background: green; color: white;'>10</td><td style='background: green; color: white;'>history</td><td style='background: green; color: white;'>history</td><td>61.450%</td><td>2289.94</td><td>-1098.91</td><td>70060.83</td><td>71.30%</td><td>336</td><td>1.453</td><td>0.64%</td><td>-0.45%</td><td>43.442%</td><td>1.41</td><td>67%</td><td>0.438</td><td>-0.173</td><td>0.275</td><td>0.429</td><td>-2.307</td></tr><tr><td style='background: green; color: white;'>11</td><td style='background: green; color: white;'>history</td><td style='background: green; color: white;'>saucer</td><td>90.552%</td><td style='background: red; color: white;'>83437.15</td><td>-85.20</td><td>39405.77</td><td>122.79%</td><td style='background: red; color: white;'>34</td><td>2.53</td><td>4.46%</td><td>-1.29%</td><td>71.079%</td><td>3.46</td><td>89%</td><td>0.616</td><td>-0.057</td><td>0.238</td><td>1.044</td><td>-10.545</td></tr><tr><td style='background: green; color: white;'>12</td><td style='background: green; color: white;'>history</td><td style='background: green; color: white;'>lame</td><td>47.657%</td><td>20467.80</td><td>-164.71</td><td>31814.14</td><td>52.15%</td><td>88</td><td>1.098</td><td>1.97%</td><td>-0.77%</td><td>32.488%</td><td>2.57</td><td style='background: red; color: white;'>59%</td><td>0.345</td><td>-0.135</td><td>0.287</td><td>0.221</td><td>-2.332</td></tr></tbody></table><p>I believe it is a good practice to set up some baselines before starting to look at the line chart of our portfolio return over time. These basic guidelines stand for the limitations and capabilities of the strategy to our own knowledge. In our backtest results, we marked anomaly numbers from the summarized table above in <strong><i style="color: red;">RED</i></strong> color.</p><ol><li>First of all, we drop the backtests that have little <code>trades (number of transactions)</code>. Our strategy aims to capture the momentum between the buy signals and sell signals, so 30 trades generated in one and a half years doesn’t mean our strategy is ineffective. We simply wouldn’t be able to judge whether our strategy is consistently profitable over years with this little in samples.</li><li>The same logic applies to <code>Unrealized (return)</code>. We consider trades to be successful when we buy security, hold for a period, and then sell to close the position. Without closing the positions, we won’t be able to test the profit-taking ability of our strategy. Therefore we wouldn’t prefer these scenarios.</li><li>Other factors like the <code>winning rate</code> and the <code>total portfolio return</code> are also things for us to decide whether it’s a good strategy or not. Here we ruled out the strategies that have a low winning rate or total return.</li></ol><p>Once we have our baselines in place, let’s summarize our comments in the below table.</p><div class='foo'><div class="table-container"><table><thead><tr><th>No.</th><th>MACD</th><th>AO</th><th>Diagram</th><th>Comment</th></tr></thead><tbody><tr><td>1</td><td>simple</td><td>simple</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/simple-simple.png" class="" width="400"></td><td>This is a great example of our desired strategy. <br>Even though our total return plummets during the COVID-19 event, our portfolio managed to grow steadily and to grow in the spread between total return and the benchmark return. Compounding annual rate 47.336% is good enough to be a quant strategy to trade on daily basis.</td></tr><tr><td>2</td><td>simple</td><td>history</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/simple-history.png" class="" width="400"></td><td>Even though we have an attractive portfolio return, you’ll notice that our portfolio return has no difference from the benchmark return the 90% of the time. Our only profit gain started in a spike in Feb 2021. As our aim is to find a strategy that can create consistent profit, I wouldn’t say this strategy is appropriate and meet our goal.</td></tr><tr><td>3</td><td>simple</td><td>saucer</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/simple-saucer.png" class="" width="400"></td><td>At first glance, this seems to be the perfect strategy as we don’t see a drastic drop during COVID-19, and the portfolio return outgrows steadily compared to benchmark return. However, this test scenario is against the guidelines that the number of trades is too little for us to confirm this signal as valid.</td></tr><tr><td>4</td><td>simple</td><td>lame</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/simple-lame.png" class="" width="400"></td><td>Apparently the <code>Lame</code> indicator would be able to help us locate the good-quality stock, but couldn’t close the position under our exit strategy. This would be a good strategy if we can improve the exit strategy of this scenario.</td></tr><tr><td>5</td><td>signal</td><td>simple</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/signal-simple.png" class="" width="400"></td><td>This strategy is not impressive as it took too long to recover from the pandemic collapse.</td></tr><tr><td>6</td><td>signal</td><td>history</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/signal-history.png" class="" width="400"></td><td>Same as above</td></tr><tr><td>7</td><td>signal</td><td>saucer</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/signal-saucer.png" class="" width="400"></td><td>Same as above</td></tr><tr><td>8</td><td>signal</td><td>lame</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/signal-lame.png" class="" width="400"></td><td>Same as above</td></tr><tr><td>9</td><td>history</td><td>simple</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/history-simple.png" class="" width="400"></td><td>Same as the strategies in 5, 6, 7, 8, that this strategy took too long to surpass the benchmark return.</td></tr><tr><td>10</td><td>history</td><td>history</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/history-history.png" class="" width="400"></td><td>Same as the strategies in 5, 6, 7, 8, that this strategy took too long to surpass the benchmark return.</td></tr><tr><td>11</td><td>history</td><td>saucer</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/history-saucer.png" class="" width="400"></td><td>Same as scenario 3, the positions were built up too slowly as there were too few trading signals triggered. Could be a profitable strategy, but we need more signals and valid trades to justify whether this is a valid strategy.</td></tr><tr><td>12</td><td>history</td><td>lame</td><td><img data-src="/2021/07/19/2021-07-20-advanced-macd-strategy/history-lame.png" class="" width="400"></td><td>Same as the strategies in 5, 6, 7, 8, that this strategy took too long to surpass the benchmark return.</td></tr></tbody></table></div></div><hr><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>Unfortunately, the new methods to generate trading signals didn’t really help to improve the quality of our MACD trading strategy. The <code>Signal MACD</code> and the <code>Historic MACD</code> based scenarios didn’t produce a better performance at all. So once again we can confirm that our original MACD strategy with <code>Simple MACD</code> and <code>Simple AO</code> is a good enough strategy for now. But in the meantime, we have discovered two more possible optional strategies with <code>AO Saucer</code> indicators in backtesting 3 and 11. As long as we can generate more samples, we can justify our backtest results to see whether these newly generated samples are still giving the edge to make a consistent profit.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://medium.com/swlh/creating-a-profitable-version-of-the-macd-oscillator-trading-differently-ae3da2fe9728">Creating a profitable MACD strategy</a></li><li><a href="https://medium.com/codex/bitcoin-trade-automation-with-awesome-oscillator-in-python-51f2c52c5b25">Bitcoin trade automation with awesome oscillator</a></li><li><a href="https://medium.com/pi-capital-union/awesome-oscillator-f1f58d99a155">Advanced strategy in awesome oscillator</a></li><li><a href="https://medium.com/@voltzuk/using-the-awesome-oscillator-to-find-bitcoin-buy-and-sell-signals-46dedcd9eb22">Using the awesome oscillator to find bitcoin buy and sell signals</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/07/19/2021-07-20-advanced-macd-strategy/cover.png&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;style&gt;
.foo table th:nth-of-type(1){
width: 5%;
}
.foo table th:nth-of-type(2){
width: 10%
;
}
.foo table th:nth-of-type(3){
width: 10%;
}
.foo table th:nth-of-type(4){
width: 45%;
}
.foo table th:nth-of-type(5){
width: 30%;
}
&lt;/style&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;In the post &lt;a href=&quot;https://mikelhsia.github.io/2020/10/10/2020-10-10-macd-strategy/&quot;&gt;How to save your silver bullets with MACD strategy?&lt;/a&gt;, we have backtested the strategy of MACD and the other six different momentum indicators. In the end, the combination of MACD and the awesome oscillator is the better and seemingly profitable one among all six combinations. But, we won’t stop right there. In order to raise our portfolio win rate and return, we will discuss a few variants of MACD and Awesome Oscillator to derive different buy and sell signals.&lt;/p&gt;</summary>
    
    
    
    <category term="Quantitative Trading" scheme="http://mikelhsia.github.io/categories/Quantitative-Trading/"/>
    
    
    <category term="Strategy" scheme="http://mikelhsia.github.io/tags/Strategy/"/>
    
    <category term="Momentum" scheme="http://mikelhsia.github.io/tags/Momentum/"/>
    
    <category term="Technical Analysis" scheme="http://mikelhsia.github.io/tags/Technical-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Step up your game in Quant trading - Backtest platforms QuantConnect v.s. Quantopian  review</title>
    <link href="http://mikelhsia.github.io/2021/07/18/2021-07-05-pros-cons-of-quantconnect/"/>
    <id>http://mikelhsia.github.io/2021/07/18/2021-07-05-pros-cons-of-quantconnect/</id>
    <published>2021-07-18T08:49:16.000Z</published>
    <updated>2021-09-15T06:26:10.946Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/07/18/2021-07-05-pros-cons-of-quantconnect/cover.png" class="" width="400"><p>Backtesting is the most important stage of testing and verifying the result of your trading strategy. You can either build your own backtesting script or use a python package such as <code>backtrader</code> to simulate your portfolio return with downloaded stock prices CSV files. Either way would require you to download the stock price in minute or day bar beforehand. Also, you need to deal with the stock market events such as stock splitting, ticker name changing, or delisting. So effectively using an existing online tool like <a href="https://www.quantconnect.com/">QuantConnect</a> could save you a lot of time dealing with edge cases yourself.</p><p>I’ve been spending my time learning how to work with QuantConnect platform and its features in the past month. So in this post, I’m going to introduce the web-based backtest platform by finding out the common things between Quantopian and QuantConnect. Then I’ll talk about the good and bad I found in trying out these two platforms. Hopefully, the experience that I shared in this post can better help people who are looking for a solution of validating their trading ideas.</p><a id="more"></a><hr><h1 id="Quantopian-and-QuantConnect-in-common"><a href="#Quantopian-and-QuantConnect-in-common" class="headerlink" title="Quantopian and QuantConnect in common"></a>Quantopian and QuantConnect in common</h1><p>Since <strong>Quantopian</strong> has announced its retirement on Nov 14th, 2020, I’ve been struggling to find a substitution for backtesting the strategy. <a href="https://www.quantconnect.com/">QuantConnect</a> is a seemingly promising one that I can find so far. Both Quantopian and <a href="https://www.quantconnect.com/">QuantConnect</a> are <strong>web-based backtest platforms</strong> that allow you to use code to construct your trading strategy with the tools provided. In their <strong>built-in IDE</strong>, you can decide your target universe and work on the indicators that trigger the buy-in or sell-off instructions. After you put together your trading strategy, it simply costs you one click to <strong>backtest</strong> your strategy with historic data. The visualized portfolio performance and key stats are the things for you to evaluate whether you have constructed a high-alpha strategy or not.</p><p>So basically, Quantopian and <a href="https://www.quantconnect.com/">QuantConnect</a> are quite similar in terms of their functionalities to fulfill a quant’s basic needs.</p><h1 id="Quantopian-and-QuantConnect-in-different"><a href="#Quantopian-and-QuantConnect-in-different" class="headerlink" title="Quantopian and QuantConnect in different"></a>Quantopian and QuantConnect in different</h1><p>While constructing a trading strategy, I’ve encountered a few concepts and features that are a bit hard for me to grasp in the first place. Here I bring them up so that you can pay more attention to when you start working with <a href="https://www.quantconnect.com/">QuantConnect</a> platform.</p><ul><li>Built-in IDE</li><li>Fewer helper functions in QuantConnect</li><li>Community and forum</li><li>Platform stability</li><li>Differences in data structure and concepts between two platforms</li></ul><h2 id="Built-in-IDE"><a href="#Built-in-IDE" class="headerlink" title="Built-in IDE"></a>Built-in IDE</h2><p>From the experience of being a former product/project manager in the software industry, I’ve learned that the UI/UX of your product will set the tone and draw a particular group of your product audience. So we can try to identify the target audience of Quantopian and <a href="https://www.quantconnect.com/">QuantConnect</a> by looking at their most important page: <strong>built-in IDE</strong>.</p><div class="table-container"><table><thead><tr><th>Quantopian</th><th>QuantConnect</th></tr></thead><tbody><tr><td><img data-src="/2021/07/18/2021-07-05-pros-cons-of-quantconnect/quantopian.png" class="" width="300"><br><p style="text-align:center; color: grey;"> <i>Quantopian research IDE</i> </p></td><td><img data-src="/2021/07/18/2021-07-05-pros-cons-of-quantconnect/quantconnect.png" class="" width="300"><br><p style="text-align:center; color: grey;"> <i>QuantConnect research IDE</i> </p></td></tr></tbody></table></div><p>Quantopian’s IDE is designed to be elevating the users’ speed to develop profitable strategies. There are two types of backtesting you can execute: quick performance backtesting and deep analysis backtesting. If you are constructing your alpha strategy from the scratch, you can code in the left area and run a quick performance backtest to see the result on the right. This result contains only the portfolio return graph and other crucial KPIs which take less time to generate. When you feel confident with your trading strategy, you can run a deep analysis backtest to see details such as the exact order you have submitted and what is your sector-specific exposure. Personally, I like this design as I can quickly try and error to build the strategy with the performance backtest and spent less time to see how it worked out and fine-tune the strategy while running a deep analysis backtest to print out a log message every time will be wasting time and resources.</p><p>On the other hand, <a href="https://www.quantconnect.com/">QuantConnect</a> seems taking a different route to approach their end-users. <a href="https://www.quantconnect.com/">QuantConnect</a> provides only one type of backtesting with analysis and separates their IDE from their backtest result into two different tabs. Therefore, even with the tiniest change in your code, you are obligated to rebuild your code and run a full-fledged backtest that might not necessary. However, unlike Quantopian who treats every trading strategy as a script, <a href="https://www.quantconnect.com/">QuantConnect</a> does treat each trading strategy as an individual project. The IDE inspects and monitors how many times you have run backtest against this specific strategy, how many parameters you have used in it, and how much time you have been spending on this script. These are all deemed as indicators to be referenced while you’re doubting the level of <a href="https://www.quantconnect.com/docs/key-concepts/research-guide#Research-Guide-Algorithm-Parameters">over-fitting</a> of your trading strategy.</p><h2 id="Fewer-helper-functions-in-QuantConnect"><a href="#Fewer-helper-functions-in-QuantConnect" class="headerlink" title="Fewer helper functions in QuantConnect"></a>Fewer helper functions in QuantConnect</h2><p>Helper functions are like small gadgets that make you complete your work much easier. Quantopian provides a lot of helper functions, such as <code>get_open_orders()</code>, <code>set_slippage()</code>, and <code>get_calendar()</code>, that help you focus more on constructing your trading strategy and less on spending time on the underlying data structure.</p><p>On the other hand, <a href="https://www.quantconnect.com/">QuantConnect</a> encapsulates the data needed in important objects such as <code>portfolio</code> and <code>securities</code>. Instead of providing helper functions, <a href="https://www.quantconnect.com/">QuantConnect</a> decides to expose these properties to calculate what they want when they need to.</p><p>Personally speaking, I prefer the Quantopian way as having more helper functions could help users pay more attention to the most essential things, building the trading strategy.</p><h2 id="Community-and-forum"><a href="#Community-and-forum" class="headerlink" title="Community and forum"></a>Community and forum</h2><p>Quantopian no doubt used to have the most active open community in the quantitative trading industry. All the members actively exchange their ideas and thoughts, and the staffs are also very involved in each crucial topic to provide assistants when needed. But, the <a href="https://www.quantconnect.com/forum">QuantConnect community</a> somehow looks to me missing the engagement between quant traders and thriving atmosphere.</p><h2 id="Platform-stability"><a href="#Platform-stability" class="headerlink" title="Platform stability"></a>Platform stability</h2><p>I still remember the first time when I tried to work with QuantConnect, I’ve been trying to run my first backtest several times yet no successful result. My backtest has been hung in one of the steps for hours and then got logged out for unknown reasons. Then, I was having issues logging back in to the platform. I was so frustrated so I moved on to another substitution.</p><p>Thankfully, everything went pretty smoothly this time. Also, if you want to know the stability of QuantConnect server, there’s another tool that you can utilize: <a href="http://status.quantconnect.com/">QuantConnect Status Monitor</a>.</p><p>During my time using Quantopian, everything went well.</p><h2 id="Differences-in-data-structure-and-concepts-between-two-platforms"><a href="#Differences-in-data-structure-and-concepts-between-two-platforms" class="headerlink" title="Differences in data structure and concepts between two platforms"></a>Differences in data structure and concepts between two platforms</h2><p>There are still a lot of differences between these two platforms. I’m not going to bother you with these details. Instead, I put these at the <a href="#anchor">end of this post</a> so that you can refer to them whenever you need them.</p><hr><h1 id="Advanced-features-that-QuantConnect-provides"><a href="#Advanced-features-that-QuantConnect-provides" class="headerlink" title="Advanced features that QuantConnect provides"></a>Advanced features that QuantConnect provides</h1><p>Below is a list of features that <a href="https://www.quantconnect.com/">QuantConnect</a> does well and is beneficial to the users:</p><ul><li>The built-in debugger in IDE</li><li>Live trading support</li><li>Algorithm Framework</li><li>Alpha streams</li></ul><h2 id="The-built-in-debugger-in-IDE"><a href="#The-built-in-debugger-in-IDE" class="headerlink" title="The built-in debugger in IDE"></a>The built-in debugger in IDE</h2><p>Debugging accounts for a crucial part while building your trading strategy. We usually use an IDE-built-in debugger or python package <code>pdb</code> to help us debug local scripts. Yet, it’s really interesting to see a built-in debugger in this web-based IDE. If you have a variable that you want to monitor in each iteration, this debugger would definitely come in handy.</p><h2 id="Live-trading-support"><a href="#Live-trading-support" class="headerlink" title="Live trading support"></a>Live trading support</h2><p>Live trading would be the last piece of the puzzle to activate your trading strategy. Once you complete the backtest and decide to throw this trading strategy into the live market, live trading support would make sure you can seamlessly connect your trading strategy to the brokers.</p><p>Quantopian collaborates with <a href="https://www.ibkr.hk/cn/index.php?f=36942">Interactive Brokers</a> so that you can connect your strategy to your own IB accounts to start trading live.</p><p><a href="https://www.quantconnect.com/">QuantConnect</a> supports even more live trading brokers such as IB, Oanda, Coinbase, Bloomberg, …etc. This feature is quite attractive as you’re able to run multiple strategies under the same QuantConnect account as long as you have accounts under each broker.<br><img data-src="/2021/07/18/2021-07-05-pros-cons-of-quantconnect/live.png" class="" width="600"></p><p style="text-align:center; color: grey;">    <i>Brokers supported on QuantConnect</i></p><h2 id="Algorithm-Framework"><a href="#Algorithm-Framework" class="headerlink" title="Algorithm Framework"></a>Algorithm Framework</h2><p>Unlike Quantopian who treats every trading strategy as an individual script, <a href="https://www.quantconnect.com/">QuantConnect</a> separates a trading strategy into five unique models: universe selection, Alpha, portfolio construction, risk, and execution. Each of them is responsible for a unique task:</p><ul><li><strong>Universe selection model</strong> is responsible for filtering the target securities and add to your target universe.</li><li><strong>Alpha model</strong> processes the data and emits the trading insights according to the trading directions.</li><li><strong>Portfolio construction model</strong> takes the insights from Alpha model and decides how much money you would like to allocate to each security.</li><li><strong>Risk model</strong> monitors the performance of your portfolio and drops certain securities when a downside trend appears.</li><li><strong>Execution model</strong> control how each order gets executed.</li></ul><img data-src="/2021/07/18/2021-07-05-pros-cons-of-quantconnect/datain.png" class="" width="500"><p style="text-align:center; color: grey;">    <i>Data flow in QuantConnect</i></p><p>By splitting the responsibilities into each model, you can focus on build one model that can be reused in another strategy in the future.</p><h2 id="Alpha-Streams"><a href="#Alpha-Streams" class="headerlink" title="Alpha Streams"></a>Alpha Streams</h2><p>Quantopian held competitions to have quants to share and compete for their strategies. Once your strategy is outstanding and lucrative enough, Quantopian would allocate a part of their asset to construct a fund with the strategy you designed. The profit would be shared together between you and Quantopian. This is also the business model of Quantopian who acts as a supervisor and hand-pick the best strategy within the organization.</p><p>On the other hand, QuantConnect acts as a broker between quants and organizational investors. The quant can construct his/her own strategy and run backtest through certain years. Once the organizational investors have scouted your strategy and believe that your strategy is fitting their needs and profitable enough, they can pay you the money to subscribe to your strategy in order to receive the trading signals that your strategy produced. QuantConnect will charge 30% of your subscription fee as the cost of hosting your code and everything.</p><p>Essentially, these are the differences between their business models. We won’t be able to judge which model is better than the other, but knowing the fact that you might have a chance to make money by writing strategy is a plus for QuantConnect users.</p><hr><h1 id="Last-but-not-least"><a href="#Last-but-not-least" class="headerlink" title="Last but not least"></a>Last but not least</h1><p>This post is not a short summary of either Quantopian or QuantConnect is better, but is more of personal learning tracks and feelings of what QuantConnect can do better in the future. For those who are interested in utilizing their personal skills to make money and in learning investors’ mentalities and behaviors by reading the market, QuantConnect could be a tool that is worth your time to learn and a community to join.</p><hr><p><a name="anchor"></a></p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="Q-amp-A-and-tips"><a href="#Q-amp-A-and-tips" class="headerlink" title="Q&amp;A and tips"></a>Q&amp;A and tips</h2><blockquote><ol><li>Definition of <code>self.portfolio</code> is different</li></ol></blockquote><p><strong>Quantopian</strong>: It’s a list of objects of your invested positions<br><strong>QuantConnect</strong>: It’s a dictionary of your monitored universe</p><p><strong><em>Comment</em></strong>:<br>The term <code>portfolio</code> has different meanings in these two platforms. In Quantopian, the portfolio means a group of securities you currently hold. In QuantConnect, the term indicates the stock universe that is on your watchlist, no matter you have bought this stock or not. <br><br> The way that QuantConnect defines <code>portfolio</code> could lead to confusion and extra work when inspecting the status of your portfolio.</p><blockquote><ol><li>How to subscribe data you needed</li></ol></blockquote><p><strong>Quantopian</strong>: You subscribe to the data you need by telling <code>def make_pipeline()</code> the data specification, such as what stocks you would like to include, what fundamental data you need, and what indicator you would like to see. In the end, you’ll get a huge piece of dataframe as the output from the daily pipeline data processing.<br><strong>QuantConnect</strong>: You first need to register the security you would like to add to your watchlist with <code>self.AddEquity(symbol)</code>. You’ll receive all the data of the securities on your watchlist every trading day. What about the indicators? You need to calculate and update yourself.</p><p><strong><em>Comment</em></strong>:<br>The way that Quantopian deals with the data subscription is quite straightforward. You simply need to use your code to describe how you want the data to be like, and then you’ll get a big sheet for you to play with. Yet, data from QuantConnect requires more works from you in order to stitch the data into the form you would like them to be.</p><blockquote><ol><li>QuantConnect introduced the concept of <code>Symbol</code>, Quantopian identify securities by <code>ticker</code></li></ol></blockquote><p><strong>Quantopian</strong>: You need to specify security using string. However, it’s not quite clear to me how Quantopian deals with the events of changing ticker or delist.<br><strong>QuantConnect</strong>: QuantConnect uses<code>self.AddEquity(symbol)</code> to transform a string-like ticker into an object that QuantConnect understands. Therefore, it doesn’t matter whether the ticker of security has been changed or delisted.</p><p><strong><em>Comment</em></strong>:<br>It is a very good concept that waives the users’ concerns of dealing with these events. However, by looking at the API documentation of QuantConnect, the APIs were not consistent regarding using either a symbol object or a ticker string. Therefore this increases further difficulties for users to learn how to use their APIs.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/07/18/2021-07-05-pros-cons-of-quantconnect/cover.png&quot; class=&quot;&quot; width=&quot;400&quot;&gt;
&lt;p&gt;Backtesting is the most important stage of testing and verifying the result of your trading strategy. You can either build your own backtesting script or use a python package such as &lt;code&gt;backtrader&lt;/code&gt; to simulate your portfolio return with downloaded stock prices CSV files. Either way would require you to download the stock price in minute or day bar beforehand. Also, you need to deal with the stock market events such as stock splitting, ticker name changing, or delisting. So effectively using an existing online tool like &lt;a href=&quot;https://www.quantconnect.com/&quot;&gt;QuantConnect&lt;/a&gt; could save you a lot of time dealing with edge cases yourself.&lt;/p&gt;
&lt;p&gt;I’ve been spending my time learning how to work with QuantConnect platform and its features in the past month. So in this post, I’m going to introduce the web-based backtest platform by finding out the common things between Quantopian and QuantConnect. Then I’ll talk about the good and bad I found in trying out these two platforms. Hopefully, the experience that I shared in this post can better help people who are looking for a solution of validating their trading ideas.&lt;/p&gt;</summary>
    
    
    
    <category term="Readings" scheme="http://mikelhsia.github.io/categories/Readings/"/>
    
    
    <category term="Backtesting" scheme="http://mikelhsia.github.io/tags/Backtesting/"/>
    
  </entry>
  
  <entry>
    <title>【ML algo trading】 III - 5 myths about practicing quant trading with machine learning</title>
    <link href="http://mikelhsia.github.io/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/"/>
    <id>http://mikelhsia.github.io/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/</id>
    <published>2021-06-14T06:44:49.000Z</published>
    <updated>2022-08-24T18:00:02.297Z</updated>
    
    <content type="html"><![CDATA[<img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/cover.jpg" class="" width="600"><p>In the post <a href="https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/">【Machine Learning】 Part II - How to build a machine learning boilerplate?</a>, we have successfully built our machine learning boilerplate. By having this template, we can develop an advanced machine learning trading strategy upon. However, even with the strategy result that looks profoundly profitable, we still won’t be able to know how much money we can make by looking at the accuracy rate of our machine learning trading algorithm.</p><p>In order to better understand whether the results from the output of our model are really concerning our portfolio return, I put together a rather simple strategy and run several backtests with different parameters. In the end, we’re going to answer several frequently asked questions in order to decrypt the myths of machine learning trading algorithms.</p><a id="more"></a><p>Here I introduced the <a href="https://www.joinquant.com/">JoinQuant platform</a> into our toolset in order to backtest our strategy. After several times of tuning and research to further advance our preliminary machine learning boilerplate, I’ve executed 108 backtest on the JoinQuant platform to see how well the strategy could perform if we launch this machine learning strategy to the stock market. By summarizing the results from these 108 backtest, there are a few things that are interesting for beginners of quant trading to learn before developing their own machine learning quantitative trading strategies.</p><h1 id="Setup-before-we-start"><a href="#Setup-before-we-start" class="headerlink" title="Setup before we start"></a>Setup before we start</h1><h2 id="Quick-introduction-of-the-machine-learning-models"><a href="#Quick-introduction-of-the-machine-learning-models" class="headerlink" title="Quick introduction of the machine learning models"></a>Quick introduction of the machine learning models</h2><p>I picked three different machine learning models to see whether different models will greatly impact the outcome of the strategy. Three models are: <code>Logistic regression</code>, <code>SVM</code> with Gaussian kernel, and <code>XGBoost</code>. I’m not going to cover the theory of each model as our focus in this article is to extract some valuable insights from the backtest results.</p><h3 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h3><p><code>Logistic regression</code> is one of the most commonly used algorithms in the field. Similar to the theory of linear regression as we explain <strong>Supervised Learning</strong> <a href="https://mikelhsia.github.io/2021/04/22/2021-04-22-machine-learning-intro/">here</a>, the input data will be fed into the pipeline to produce a final score. Logistic regression simply applies the <strong><a href="https://en.wikipedia.org/wiki/Sigmoid_function">Sigmoid function</a></strong> to convert the final score into either 0 or 1. We’re going to get an array of [1, 0, 0, 1, …, 0] as the outcome from the logistic regression, which we can reinterpret the array into [True, False, False, True, …, False] as our final results.</p><p>In other words, we’re trying to find the exact line to separate the 0’s and the 1’s.<br><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/LR.png" class="" width="500"></p><p style="text-align:center; color: grey;">    <i>The classic linear regression model</i></p><h3 id="SVM-Support-Vector-Machine"><a href="#SVM-Support-Vector-Machine" class="headerlink" title="SVM (Support Vector Machine)"></a>SVM (Support Vector Machine)</h3><p><code>SVM</code> is a variant of <code>logistic regression</code>. Instead of finding the exact line to separate all the 0’s and the 1’s, we’re adding a buffer parameter (the penalty term <em>C</em> in the diagram) into the model. By adding this buffer, the model would be much more resilient to the test data.</p><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/SVM.png" class="" width="500"><p style="text-align:center; color: grey;">    <i>SVM is a more flexible classification model</i></p><h3 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h3><p>XGBoost is a tree-like classification model. By inputting data into the tree-like trained model, the model will generate relative scores in each end leaf. After adding up all the scores presented in the leaves and applying the <strong>sigmoid function</strong>, we will have our final prediction for that specific test data. Essentially, it’s a different technique than the previous two algorithms.<br><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/XGBoost.png" class="" width="500"></p><p style="text-align:center; color: grey;">    <i>XGBoost is essentially a type of decision tree</i></p><h2 id="Data-and-factors"><a href="#Data-and-factors" class="headerlink" title="Data and factors"></a>Data and factors</h2><p>Below are the data and factors that I used to train the model. You can reference <a href="https://www.joinquant.com/help/api/help#name:factor_values">here</a> to know what these factors stand for.<br><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/data.png" class="" width="200"></p><p style="text-align:center; color: grey;">    <i>Factor data</i></p><p>Also, I neutralized the data against the industry category and market capitalization, and winsorized the data to mitigate the extreme data as standard steps to process the data.</p><h2 id="How-to-train-the-model"><a href="#How-to-train-the-model" class="headerlink" title="How to train the model"></a>How to train the model</h2><p>I’m going to train the data as we said in <a href="https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/">this article</a>. I didn’t split the CV data from the original data, as our purpose is to train the model constantly with the latest data instead of using the same batch of data over and over again. Standardization and Principal Component Analysis (PCA) were also applied to the data before training the model.</p><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/training.png" class="" width="500"><p style="text-align:center; color: grey;">    <i>Rolling over the data to include new data and exclude old data</i></p><h2 id="Our-strategy"><a href="#Our-strategy" class="headerlink" title="Our strategy"></a>Our strategy</h2><p>Let’s quickly put together our trade strategy to be used in this backtest experiment:</p><ol><li>Collect and adjust our portfolio on monthly basis.</li><li>Label the stocks that have the top 30% daily return as +ve data, and the stocks that have the bottom 30% as -ve data. This label is what we used in the <code>y_data</code> to train our model.</li><li>Portfolio capacity set to be 20, meaning we can hold at most 20 stocks at the same time.</li><li>There are two variants regarding how to pick the stocks we’re going to buy:<br>4.1. Buy the top 20 stocks that have the highest probabilities to be +ve.<br>4.2. Buy the stocks that were predicted +ve.</li><li>We set our stop-gain point at 70%, and stop-loss point at 8%. 70% of stop gain would not stop us from gaining the margin of the top 30% stocks, and 8% would simply be my personal risk-aversion level.</li></ol><h1 id="Resolving-myths"><a href="#Resolving-myths" class="headerlink" title="Resolving myths"></a>Resolving myths</h1><p>These 108 backtest were conducted with the test data from 2019-09-29 to 2021-05-07. The parameters include: the types of machine learning algorithms, the length of training periods, the number of selected factors, when to place orders, … etc. The benchmark is the <a href="https://baike.baidu.com/item/%E4%B8%AD%E8%AF%81500%E6%8C%87%E6%95%B0/9192904?fromtitle=%E4%B8%AD%E8%AF%81500&amp;fromid=17200509&amp;fr=aladdin"><code>ZZ500 index</code></a>, and the benchmark return during the test period is <strong>28.74%</strong>.</p><p>To show you what the result would be like, I screenshot one of the backtest results:<br><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/sample.png" class="" width="500"></p><p style="text-align:center; color: grey;">    <i>Backtest results ran on JoinQuant</i></p><p>However, it’s still quite difficult to find out what is the best case that has all the parameters right simply by looking at the numbers and chart. Here I put all the data into one CSV sheet and visualized the data to extract a few insights from different angles. Hopefully, we can get an idea of what are the most crucial parameters that we need to consider before we throw this strategy into the market. They are:</p><ul><li>Which of the machine learning algorithms has better performance?</li><li>How many features we should use?</li><li>How much data we should use to train our model?</li><li>When should we trade our target stock?</li><li>Is AUC the indicator we use to evaluate our model?</li></ul><h2 id="Which-of-the-machine-learning-algorithms-has-better-performance"><a href="#Which-of-the-machine-learning-algorithms-has-better-performance" class="headerlink" title="Which of the machine learning algorithms has better performance?"></a>Which of the machine learning algorithms has better performance?</h2><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/excess_rtn.png" class="" width="400"><p style="text-align:center; color: grey;">    <i>Excess return by machine learning models</i>    <br>    <small></small><i>The red dots indicate the excess return compares to the ZZ500 benchmark return of 28.74%</i></small></p><p>The <code>LogisticRegression</code> from sklearn.linear_model seems to have the most stable excess portfolio return ranging from ~15% to ~70%. <code>XGBoost</code> seems to be the best model as it gave us the best potential portfolio return ranging from 18% to 120%. As for the <code>svm.svc (support vector machine model)</code>, which has too much downside risk and could potentially cause us to lose money, would be the least desirable model to utilize at the first glance.</p><h2 id="How-many-features-we-should-use"><a href="#How-many-features-we-should-use" class="headerlink" title="How many features we should use?"></a>How many features we should use?</h2><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/n_features_vs_AUC.png" class="" width="400"><p style="text-align:center; color: grey;">    <i>AUC v.s. number of features selected</i></p><p>I’ve run the backtest with 20, 30, 40 features using function <code>RFE (Recursive feature elimination)</code> in sklearn.feature_selection, which will analyze the features and then select the most relevant features. By looking at the diagram, you can tell that except for the <code>Logistic Regression</code> model, the higher AUC you will get if you picked more features to train your model. That might indicates that our model is capable of predicting more accurately if more features were accounted for.</p><blockquote><p>AUC: AUC is the model evaluation indicator ranging from 0 to 1, which is used to evaluate the accuracy of your classification model. When 0.5 &lt; AUC &lt; 1, you actually own a pretty good machine learning model that classifies True or False.</p></blockquote><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/n_features_vs_excess_rtn.png" class="" width="400"><p style="text-align:center; color: grey;">    <i>Excess return by the number of features selected</i></p><p>There is no clear increase of excess return even though we have higher AUC when you look at the above diagram. The red dots of excess return are dispersed all over the chart. The distribution of red dots is even more separated if we picked 40 features. This phenomenon potentially tells us that our model is over-fitting with 40-feature data, rendering a lower ability to predict the future. On the other hand, if we look at the scenario of <code>XGBoost</code> model with 40 features, this is the scenario that gives us the highest excess return with tolerable variance. So this could be one of our parameter combinations to apply to our final model.</p><h2 id="How-much-data-we-should-use-to-train-our-model"><a href="#How-much-data-we-should-use-to-train-our-model" class="headerlink" title="How much data we should use to train our model?"></a>How much data we should use to train our model?</h2><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/relation_tperiod_AUC.png" class="" width="400"><p style="text-align:center; color: grey;">    <i>Training periods v.s. AUC</i></p><p>Machine learning is an algorithm that aggregates historical data to form a pattern and further uses this pattern to predict the future. The more data you feed into the model, the algorithm will have much more ideas to decide whether a specific scenario will happen or not. However, this doesn’t 100% apply to the stock market as there are too many variables and events that cannot be quantified as inputs to feed into the model. Also, stock prices and indicators are time series that the recent data is more relevant than the data three years ago. The above diagram perfectly explains that the accuracy and AUC of the model won’t hugely increase even you have more data to train your model.</p><p>On the contrary, longer periods of training data seem to sabotage the accuracy and AUC. As presented in the below diagram, both excess return of <code>svm.svc</code> and excess return of <code>XGBoost</code> decrease when the training periods increase. Seems the <strong>‘freshness’</strong> of financial data will dissipate over time.</p><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/excess_rtn_by_tperiod.png" class="" width="400"><p style="text-align:center; color: grey;">    <i>Excess return by training periods</i></p><h2 id="When-should-we-trade-our-target-stock"><a href="#When-should-we-trade-our-target-stock" class="headerlink" title="When should we trade our target stock?"></a>When should we trade our target stock?</h2><p>If you’re an algo trader who adjusts your portfolio on a daily/weekly/monthly basis, I believe you have the same question as I do: <strong><em>When should I place my order on the day I adjust my portfolio?</em></strong>. The stock prices fluctuate in one intraday. Therefore the timing we place our order could potentially impact our portfolio return.</p><p>Here I did a quick experiment by backtesting each scenario two times, one scenario places orders around 09:30 after the market is open, and the other places orders around 14:40 before the market closes. Interestingly, the second scenario has a 77.78% probability to win the first. Meaning, if we place our orders before the market closes, we will have a 77.78% of chance to generate more profit. See the below diagram for the distribution of return differences by models:</p><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/c_m_o.png" class="" width="400"><p style="text-align:center; color: grey;">    <i>Return difference between placing orders after the market is opened and placing orders before the market closed</i></p><p>There are a few possible reasons I have in mind that might explain why this is happening:</p><ul><li>In the training process, I use close price to label the stocks instead of the open price. So, placing orders before the market closes will help me get closer to the trained model.</li><li>When there’s bad news happening, the stock prices incline to move a lot faster than any other time. Stock prices drop drastically in the pre-market, and will reach our stop -oss point right after the market opened. However, a movement like this tends to bounce back more or less on the same day in the afternoon. So placing orders in the afternoon would prevent us from stopping loss too early.</li><li>A lot of intraday traders and speculators tend to close their positions before the market closes as they have done their work exploiting insider news or any other news. When all the speculations have been digested by the market, the stock price will be much more reasonable and stable.</li></ul><h2 id="Is-AUC-the-indicator-we-use-to-evaluate-our-models"><a href="#Is-AUC-the-indicator-we-use-to-evaluate-our-models" class="headerlink" title="Is AUC the indicator we use to evaluate our models?"></a>Is AUC the indicator we use to evaluate our models?</h2><p>As explained in the above questions, AUC is the indicator to evaluate the accuracy of your classification model. But, does the AUC has a positive relationship with our portfolio return? Let’s first take a look at the regression plot between the AUC and the portfolio return of all our backtest below.</p><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/auc_vs_rtn.png" class="" width="400"><p style="text-align:center; color: grey;">    <i>AUC v.s. return</i></p><p>The diagram above doesn’t imply a positive correlation between AUC and portfolio return. The regression slope is quite flat, indicating AUC has a close-to-zero connection with the portfolio return. So it almost is a random walk. No way!! How could weeks of work tell me that this model is useless!?</p><p>Calm down. Let me use another angle to diagnose this plot again. I’m adding another dimension to separate the dots by the model we use. Now let’s see how it looks like.</p><img data-src="/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/auc_vs_rtn_by_kernel.png" class="" width="400"><p style="text-align:center; color: grey;">    <i>AUC v.s. return(by models)</i></p><p>Wow wow! Now it looks different. The diagram actually tells me that the <code>XGBoost</code> model and the <code>Logistic Regression</code> model contain a certain degree of positive correlation between AUC and portfolio return. This relationship will be buried if we look at each dot is from the identical model.</p><p>There are two possible reasons that why the first diagram can’t tell us there’s a potential positive correlation but the second one can:</p><ul><li>The regression was contaminated by the outlier examples lies in the bottom right quadrant.</li><li>We shouldn’t compare AUC across different models.</li></ul><h1 id="Before-we-close-this-topic"><a href="#Before-we-close-this-topic" class="headerlink" title="Before we close this topic"></a>Before we close this topic</h1><p>I believe that 108 backtests are actually not enough to help us cover every spectrum in order to answer these questions. However, I think this could be a starting point for you to understand how we can approach these types of questions in order to evaluate the effectiveness of our machine learning trading algorithm.</p><p>See you next time.</p>]]></content>
    
    
    <summary type="html">&lt;img data-src=&quot;/2021/06/14/2021-06-14-N-insights-found-while-implementing-machine-learning-trading-algorithm/cover.jpg&quot; class=&quot;&quot; width=&quot;600&quot;&gt;
&lt;p&gt;In the post &lt;a href=&quot;https://mikelhsia.github.io/2021/05/10/2021-05-14-machine-learning-prototype/&quot;&gt;【Machine Learning】 Part II - How to build a machine learning boilerplate?&lt;/a&gt;, we have successfully built our machine learning boilerplate. By having this template, we can develop an advanced machine learning trading strategy upon. However, even with the strategy result that looks profoundly profitable, we still won’t be able to know how much money we can make by looking at the accuracy rate of our machine learning trading algorithm.&lt;/p&gt;
&lt;p&gt;In order to better understand whether the results from the output of our model are really concerning our portfolio return, I put together a rather simple strategy and run several backtests with different parameters. In the end, we’re going to answer several frequently asked questions in order to decrypt the myths of machine learning trading algorithms.&lt;/p&gt;</summary>
    
    
    
    <category term="Machine Learning" scheme="http://mikelhsia.github.io/categories/Machine-Learning/"/>
    
    
    <category term="Research" scheme="http://mikelhsia.github.io/tags/Research/"/>
    
  </entry>
  
</feed>
